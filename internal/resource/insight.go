package resource

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/hashicorp/terraform-plugin-framework/diag"
	"github.com/hashicorp/terraform-plugin-framework/resource"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/boolplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/int64planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/planmodifier"
	"github.com/hashicorp/terraform-plugin-framework/resource/schema/stringplanmodifier"
	"github.com/hashicorp/terraform-plugin-framework/types"
	"github.com/posthog/terraform-provider/internal/httpclient"
	"github.com/posthog/terraform-provider/internal/resource/core"
)

func NewInsight() resource.Resource {
	return core.NewGenericResource[InsightResourceTFModel, httpclient.InsightRequest, httpclient.Insight](InsightOps{})
}

type InsightResourceTFModel struct {
	core.BaseInt64Identifiable
	Name           types.String `tfsdk:"name"`
	DerivedName    types.String `tfsdk:"derived_name"`
	Description    types.String `tfsdk:"description"`
	QueryJSON      types.String `tfsdk:"query_json"`
	Tags           types.Set    `tfsdk:"tags"`
	CreateInFolder types.String `tfsdk:"create_in_folder"`
	DashboardIDs   types.Set    `tfsdk:"dashboard_ids"`
	Deleted        types.Bool   `tfsdk:"deleted"`
}

type InsightOps struct{}

func (o InsightOps) ResourceName() string {
	return "Insight"
}

func (o InsightOps) Schema() schema.Schema {
	return schema.Schema{
		MarkdownDescription: "Manage PostHog insights via the insights endpoints.",
		Attributes: map[string]schema.Attribute{
			"id": schema.Int64Attribute{
				Computed:            true,
				MarkdownDescription: "Numeric ID of the insight.",
				PlanModifiers: []planmodifier.Int64{
					int64planmodifier.UseStateForUnknown(),
				},
			},
			"name": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Insight name.",
			},
			"derived_name": schema.StringAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Insight derived name. This is auto-generated by PostHog when the name is not set.",
				PlanModifiers: []planmodifier.String{
					stringplanmodifier.UseStateForUnknown(),
				},
			},
			"description": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "Insight description.",
			},
			"query_json": schema.StringAttribute{
				Required:            true,
				MarkdownDescription: "Raw JSON serialized query payload accepted by PostHog (for example an `InsightVizNode` with a `TrendsQuery`).",
			},
			"tags": schema.SetAttribute{
				Optional:            true,
				ElementType:         types.StringType,
				MarkdownDescription: "List of tags to apply to the insight.",
			},
			"create_in_folder": schema.StringAttribute{
				Optional:            true,
				MarkdownDescription: "The folder where the insight is created.",
			},
			"dashboard_ids": schema.SetAttribute{
				Optional:            true,
				ElementType:         types.Int32Type,
				MarkdownDescription: "List of dashboard ids which should contain the insight.",
			},
			"deleted": schema.BoolAttribute{
				Optional:            true,
				Computed:            true,
				MarkdownDescription: "Whether the insight is deleted (soft delete)",
				PlanModifiers: []planmodifier.Bool{
					boolplanmodifier.UseStateForUnknown(),
				},
			},
		},
	}
}

func (o InsightOps) BuildCreateRequest(ctx context.Context, model InsightResourceTFModel) (httpclient.InsightRequest, diag.Diagnostics) {
	var diags diag.Diagnostics

	input := httpclient.InsightRequest{}

	// Parse query JSON
	if !model.QueryJSON.IsNull() && !model.QueryJSON.IsUnknown() {
		raw := strings.TrimSpace(model.QueryJSON.ValueString())
		if raw == "" {
			diags.AddError("Invalid query_json", "query_json cannot be empty")
			return input, diags
		}
		var query map[string]interface{}
		if err := json.Unmarshal([]byte(raw), &query); err != nil {
			diags.AddError("Invalid query_json", "query_json must be valid JSON: "+err.Error())
			return input, diags
		}
		input.Query = query
	}

	if !model.Name.IsNull() && !model.Name.IsUnknown() {
		name := model.Name.ValueString()
		input.Name = &name
	}
	if !model.DerivedName.IsNull() && !model.DerivedName.IsUnknown() {
		derivedName := model.DerivedName.ValueString()
		input.DerivedName = &derivedName
	}
	if !model.Description.IsNull() && !model.Description.IsUnknown() {
		desc := model.Description.ValueString()
		input.Description = &desc
	}
	if !model.CreateInFolder.IsNull() && !model.CreateInFolder.IsUnknown() {
		folder := model.CreateInFolder.ValueString()
		input.CreateInFolder = &folder
	}

	// Tags
	if !model.Tags.IsNull() && !model.Tags.IsUnknown() {
		tags, d := core.ExtractTags(ctx, model.Tags)
		diags.Append(d...)
		if diags.HasError() {
			return input, diags
		}
		input.Tags = tags
	}

	// Dashboard IDs
	if !model.DashboardIDs.IsUnknown() {
		if model.DashboardIDs.IsNull() {
			input.Dashboards = []int32{}
		} else {
			var ids []int32
			diags.Append(model.DashboardIDs.ElementsAs(ctx, &ids, false)...)
			if diags.HasError() {
				return input, diags
			}
			input.Dashboards = ids
		}
	}

	return input, diags
}

func (o InsightOps) BuildUpdateRequest(ctx context.Context, plan, state InsightResourceTFModel) (httpclient.InsightRequest, diag.Diagnostics) {
	req, diags := o.BuildCreateRequest(ctx, plan)

	// Clear description if removed from config
	if core.ShouldClearString(plan.Description, state.Description) {
		req.Description = core.StringPtr("")
	}

	if !plan.Deleted.IsNull() {
		deleted := plan.Deleted.ValueBool()
		req.Deleted = &deleted
	}

	return req, diags
}

func (o InsightOps) MapResponseToModel(ctx context.Context, resp httpclient.Insight, model *InsightResourceTFModel) diag.Diagnostics {
	var diags diag.Diagnostics

	model.ID = types.Int64Value(resp.ID)
	model.Deleted = core.PtrToBool(resp.Deleted)

	// String fields - convert empty/whitespace to null
	model.Name = core.PtrToStringNullIfEmptyTrimmed(resp.Name)
	model.DerivedName = core.PtrToStringNullIfEmptyTrimmed(resp.DerivedName)
	model.Description = core.PtrToStringNullIfEmptyTrimmed(resp.Description)
	model.CreateInFolder = core.PtrToStringNullIfEmptyTrimmed(resp.CreateInFolder)

	// Tags - preserve empty set if configured
	tagsSet, d := core.TagsToSetPreserveEmpty(ctx, resp.Tags, model.Tags)
	diags.Append(d...)
	model.Tags = tagsSet

	// Dashboard IDs - preserve empty set if configured
	dashSet, d := core.Int32SetPreserveEmpty(ctx, resp.Dashboards, model.DashboardIDs)
	diags.Append(d...)
	model.DashboardIDs = dashSet

	// Query - filter API response to only include fields from user's config
	// This enables drift detection for user-specified fields while ignoring server-added fields
	if resp.Query != nil {
		userQueryJSON := ""
		if !model.QueryJSON.IsNull() && !model.QueryJSON.IsUnknown() {
			userQueryJSON = model.QueryJSON.ValueString()
		}
		normalizedQuery, err := normalizeQueryForState(resp.Query, userQueryJSON)
		if err != nil {
			diags.AddError("Failed to normalize query", err.Error())
			return diags
		}
		model.QueryJSON = types.StringValue(normalizedQuery)
	}

	return diags
}

func (o InsightOps) Create(ctx context.Context, client httpclient.PosthogClient, req httpclient.InsightRequest) (httpclient.Insight, error) {
	return client.CreateInsight(ctx, req)
}

func (o InsightOps) Read(ctx context.Context, client httpclient.PosthogClient, id string) (httpclient.Insight, httpclient.HTTPStatusCode, error) {
	return client.GetInsight(ctx, id)
}

func (o InsightOps) Update(ctx context.Context, client httpclient.PosthogClient, id string, req httpclient.InsightRequest) (httpclient.Insight, httpclient.HTTPStatusCode, error) {
	return client.UpdateInsight(ctx, id, req)
}

func (o InsightOps) Delete(ctx context.Context, client httpclient.PosthogClient, id string) (httpclient.HTTPStatusCode, error) {
	return client.DeleteInsight(ctx, id)
}

// normalizeQueryForState takes the API response query and the user's configured query,
// filters the API response to only include fields the user specified, and returns
// canonical JSON. This enables drift detection without needing to maintain a list
// of server-only fields.
func normalizeQueryForState(apiQuery map[string]interface{}, userQueryJSON string) (string, error) {
	if apiQuery == nil {
		return "", nil
	}

	// Parse user's query to know which fields to keep
	var userQuery map[string]interface{}
	if err := json.Unmarshal([]byte(userQueryJSON), &userQuery); err != nil {
		// If we can't parse user's query, fall back to returning API query as canonical JSON
		return marshalJSON(apiQuery)
	}

	filtered := filterToOnlyIncludeUserFields(userQuery, apiQuery)
	return marshalJSON(filtered)
}

func marshalJSON(v interface{}) (string, error) {
	data, err := json.Marshal(v)
	if err != nil {
		return "", fmt.Errorf("failed to marshal canonical JSON: %w", err)
	}
	return string(data), nil
}

// filterToOnlyIncludeUserFields filters apiData to only include fields present in userData.
// This allows drift detection for fields the user cares about while ignoring
// server-added fields (like "result", "hogql", "is_cached", etc.) automatically.
func filterToOnlyIncludeUserFields(userData, apiData interface{}) interface{} {
	switch userVal := userData.(type) {
	case map[string]interface{}:
		apiMap, ok := apiData.(map[string]interface{})
		if !ok {
			// Type mismatch - return API data as-is to surface the drift
			return apiData
		}
		result := make(map[string]interface{})
		for key, userValue := range userVal {
			if apiValue, exists := apiMap[key]; exists {
				// Recursively filter nested structures
				result[key] = filterToOnlyIncludeUserFields(userValue, apiValue)
			}
			// If key doesn't exist in API response, don't include it
			// This will surface as drift when compared to user's config
		}
		return result

	case []interface{}:
		apiSlice, ok := apiData.([]interface{})
		if !ok {
			// Type mismatch - return API data as-is to surface the drift
			return apiData
		}
		result := make([]interface{}, len(apiSlice))
		for i, apiItem := range apiSlice {
			if i < len(userVal) {
				// Filter each array element against corresponding user element
				result[i] = filterToOnlyIncludeUserFields(userVal[i], apiItem)
			} else {
				// API has more elements than user specified
				result[i] = apiItem
			}
		}
		return result

	default:
		// Primitive value - return API's value to detect drift
		return apiData
	}
}

/*
PostHog API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package posthogapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// LiveDebuggerBreakpointsAPIService LiveDebuggerBreakpointsAPI service
type LiveDebuggerBreakpointsAPIService service

type ApiLiveDebuggerBreakpointsActiveRetrieveRequest struct {
	ctx context.Context
	ApiService *LiveDebuggerBreakpointsAPIService
	projectId string
	enabled *bool
	filename *string
	repository *string
}

// Only return enabled breakpoints
func (r ApiLiveDebuggerBreakpointsActiveRetrieveRequest) Enabled(enabled bool) ApiLiveDebuggerBreakpointsActiveRetrieveRequest {
	r.enabled = &enabled
	return r
}

// Filter breakpoints for a specific file
func (r ApiLiveDebuggerBreakpointsActiveRetrieveRequest) Filename(filename string) ApiLiveDebuggerBreakpointsActiveRetrieveRequest {
	r.filename = &filename
	return r
}

// Filter breakpoints for a specific repository (e.g., &#39;PostHog/posthog&#39;)
func (r ApiLiveDebuggerBreakpointsActiveRetrieveRequest) Repository(repository string) ApiLiveDebuggerBreakpointsActiveRetrieveRequest {
	r.repository = &repository
	return r
}

func (r ApiLiveDebuggerBreakpointsActiveRetrieveRequest) Execute() (*ActiveBreakpointsResponse, *http.Response, error) {
	return r.ApiService.LiveDebuggerBreakpointsActiveRetrieveExecute(r)
}

/*
LiveDebuggerBreakpointsActiveRetrieve Get active breakpoints (External API)

External API endpoint for client applications to fetch active breakpoints using Project API key. This endpoint allows external client applications (like Python scripts, Node.js apps, etc.) to fetch the list of active breakpoints so they can instrument their code accordingly. 

Authentication: Requires a Project API Key in the Authorization header: `Authorization: Bearer phs_<your-project-api-key>`. You can find your Project API Key in PostHog at: Settings → Project → Project API Key

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiLiveDebuggerBreakpointsActiveRetrieveRequest
*/
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsActiveRetrieve(ctx context.Context, projectId string) ApiLiveDebuggerBreakpointsActiveRetrieveRequest {
	return ApiLiveDebuggerBreakpointsActiveRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ActiveBreakpointsResponse
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsActiveRetrieveExecute(r ApiLiveDebuggerBreakpointsActiveRetrieveRequest) (*ActiveBreakpointsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ActiveBreakpointsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveDebuggerBreakpointsAPIService.LiveDebuggerBreakpointsActiveRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/live_debugger_breakpoints/active/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "form", "")
	}
	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	}
	if r.repository != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "repository", r.repository, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest struct {
	ctx context.Context
	ApiService *LiveDebuggerBreakpointsAPIService
	projectId string
	breakpointIds *string
	limit *int32
	offset *int32
}

// Filter hits for specific breakpoints (repeat parameter for multiple IDs, e.g., ?breakpoint_ids&#x3D;uuid1&amp;breakpoint_ids&#x3D;uuid2)
func (r ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest) BreakpointIds(breakpointIds string) ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest {
	r.breakpointIds = &breakpointIds
	return r
}

// Number of hits to return (default: 100, max: 1000)
func (r ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest) Limit(limit int32) ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest {
	r.limit = &limit
	return r
}

// Pagination offset for retrieving additional results (default: 0)
func (r ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest) Offset(offset int32) ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest {
	r.offset = &offset
	return r
}

func (r ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest) Execute() (*BreakpointHitsResponse, *http.Response, error) {
	return r.ApiService.LiveDebuggerBreakpointsBreakpointHitsRetrieveExecute(r)
}

/*
LiveDebuggerBreakpointsBreakpointHitsRetrieve Get breakpoint hits

Retrieve breakpoint hit events from ClickHouse with optional filtering and pagination. Returns hit events containing stack traces, local variables, and execution context from your application's runtime. 

Security: Breakpoint IDs are filtered to only include those belonging to the current team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest
*/
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsBreakpointHitsRetrieve(ctx context.Context, projectId string) ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest {
	return ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BreakpointHitsResponse
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsBreakpointHitsRetrieveExecute(r ApiLiveDebuggerBreakpointsBreakpointHitsRetrieveRequest) (*BreakpointHitsResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BreakpointHitsResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveDebuggerBreakpointsAPIService.LiveDebuggerBreakpointsBreakpointHitsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/live_debugger_breakpoints/breakpoint_hits/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.breakpointIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "breakpoint_ids", r.breakpointIds, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveDebuggerBreakpointsCreateRequest struct {
	ctx context.Context
	ApiService *LiveDebuggerBreakpointsAPIService
	projectId string
	liveDebuggerBreakpoint *LiveDebuggerBreakpoint
}

func (r ApiLiveDebuggerBreakpointsCreateRequest) LiveDebuggerBreakpoint(liveDebuggerBreakpoint LiveDebuggerBreakpoint) ApiLiveDebuggerBreakpointsCreateRequest {
	r.liveDebuggerBreakpoint = &liveDebuggerBreakpoint
	return r
}

func (r ApiLiveDebuggerBreakpointsCreateRequest) Execute() (*LiveDebuggerBreakpoint, *http.Response, error) {
	return r.ApiService.LiveDebuggerBreakpointsCreateExecute(r)
}

/*
LiveDebuggerBreakpointsCreate Method for LiveDebuggerBreakpointsCreate

Create, Read, Update and Delete breakpoints for live debugging.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiLiveDebuggerBreakpointsCreateRequest
*/
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsCreate(ctx context.Context, projectId string) ApiLiveDebuggerBreakpointsCreateRequest {
	return ApiLiveDebuggerBreakpointsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return LiveDebuggerBreakpoint
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsCreateExecute(r ApiLiveDebuggerBreakpointsCreateRequest) (*LiveDebuggerBreakpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveDebuggerBreakpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveDebuggerBreakpointsAPIService.LiveDebuggerBreakpointsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/live_debugger_breakpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveDebuggerBreakpoint == nil {
		return localVarReturnValue, nil, reportError("liveDebuggerBreakpoint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveDebuggerBreakpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveDebuggerBreakpointsDestroyRequest struct {
	ctx context.Context
	ApiService *LiveDebuggerBreakpointsAPIService
	id string
	projectId string
}

func (r ApiLiveDebuggerBreakpointsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.LiveDebuggerBreakpointsDestroyExecute(r)
}

/*
LiveDebuggerBreakpointsDestroy Method for LiveDebuggerBreakpointsDestroy

Create, Read, Update and Delete breakpoints for live debugging.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this live debugger breakpoint.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiLiveDebuggerBreakpointsDestroyRequest
*/
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsDestroy(ctx context.Context, id string, projectId string) ApiLiveDebuggerBreakpointsDestroyRequest {
	return ApiLiveDebuggerBreakpointsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsDestroyExecute(r ApiLiveDebuggerBreakpointsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveDebuggerBreakpointsAPIService.LiveDebuggerBreakpointsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/live_debugger_breakpoints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiLiveDebuggerBreakpointsListRequest struct {
	ctx context.Context
	ApiService *LiveDebuggerBreakpointsAPIService
	projectId string
	filename *string
	limit *int32
	offset *int32
	repository *string
}

func (r ApiLiveDebuggerBreakpointsListRequest) Filename(filename string) ApiLiveDebuggerBreakpointsListRequest {
	r.filename = &filename
	return r
}

// Number of results to return per page.
func (r ApiLiveDebuggerBreakpointsListRequest) Limit(limit int32) ApiLiveDebuggerBreakpointsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiLiveDebuggerBreakpointsListRequest) Offset(offset int32) ApiLiveDebuggerBreakpointsListRequest {
	r.offset = &offset
	return r
}

func (r ApiLiveDebuggerBreakpointsListRequest) Repository(repository string) ApiLiveDebuggerBreakpointsListRequest {
	r.repository = &repository
	return r
}

func (r ApiLiveDebuggerBreakpointsListRequest) Execute() (*PaginatedLiveDebuggerBreakpointList, *http.Response, error) {
	return r.ApiService.LiveDebuggerBreakpointsListExecute(r)
}

/*
LiveDebuggerBreakpointsList Method for LiveDebuggerBreakpointsList

Create, Read, Update and Delete breakpoints for live debugging.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiLiveDebuggerBreakpointsListRequest
*/
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsList(ctx context.Context, projectId string) ApiLiveDebuggerBreakpointsListRequest {
	return ApiLiveDebuggerBreakpointsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedLiveDebuggerBreakpointList
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsListExecute(r ApiLiveDebuggerBreakpointsListRequest) (*PaginatedLiveDebuggerBreakpointList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedLiveDebuggerBreakpointList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveDebuggerBreakpointsAPIService.LiveDebuggerBreakpointsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/live_debugger_breakpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.filename != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filename", r.filename, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.repository != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "repository", r.repository, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveDebuggerBreakpointsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *LiveDebuggerBreakpointsAPIService
	id string
	projectId string
	patchedLiveDebuggerBreakpoint *PatchedLiveDebuggerBreakpoint
}

func (r ApiLiveDebuggerBreakpointsPartialUpdateRequest) PatchedLiveDebuggerBreakpoint(patchedLiveDebuggerBreakpoint PatchedLiveDebuggerBreakpoint) ApiLiveDebuggerBreakpointsPartialUpdateRequest {
	r.patchedLiveDebuggerBreakpoint = &patchedLiveDebuggerBreakpoint
	return r
}

func (r ApiLiveDebuggerBreakpointsPartialUpdateRequest) Execute() (*LiveDebuggerBreakpoint, *http.Response, error) {
	return r.ApiService.LiveDebuggerBreakpointsPartialUpdateExecute(r)
}

/*
LiveDebuggerBreakpointsPartialUpdate Method for LiveDebuggerBreakpointsPartialUpdate

Create, Read, Update and Delete breakpoints for live debugging.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this live debugger breakpoint.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiLiveDebuggerBreakpointsPartialUpdateRequest
*/
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsPartialUpdate(ctx context.Context, id string, projectId string) ApiLiveDebuggerBreakpointsPartialUpdateRequest {
	return ApiLiveDebuggerBreakpointsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return LiveDebuggerBreakpoint
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsPartialUpdateExecute(r ApiLiveDebuggerBreakpointsPartialUpdateRequest) (*LiveDebuggerBreakpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveDebuggerBreakpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveDebuggerBreakpointsAPIService.LiveDebuggerBreakpointsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/live_debugger_breakpoints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedLiveDebuggerBreakpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveDebuggerBreakpointsRetrieveRequest struct {
	ctx context.Context
	ApiService *LiveDebuggerBreakpointsAPIService
	id string
	projectId string
}

func (r ApiLiveDebuggerBreakpointsRetrieveRequest) Execute() (*LiveDebuggerBreakpoint, *http.Response, error) {
	return r.ApiService.LiveDebuggerBreakpointsRetrieveExecute(r)
}

/*
LiveDebuggerBreakpointsRetrieve Method for LiveDebuggerBreakpointsRetrieve

Create, Read, Update and Delete breakpoints for live debugging.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this live debugger breakpoint.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiLiveDebuggerBreakpointsRetrieveRequest
*/
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsRetrieve(ctx context.Context, id string, projectId string) ApiLiveDebuggerBreakpointsRetrieveRequest {
	return ApiLiveDebuggerBreakpointsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return LiveDebuggerBreakpoint
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsRetrieveExecute(r ApiLiveDebuggerBreakpointsRetrieveRequest) (*LiveDebuggerBreakpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveDebuggerBreakpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveDebuggerBreakpointsAPIService.LiveDebuggerBreakpointsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/live_debugger_breakpoints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiLiveDebuggerBreakpointsUpdateRequest struct {
	ctx context.Context
	ApiService *LiveDebuggerBreakpointsAPIService
	id string
	projectId string
	liveDebuggerBreakpoint *LiveDebuggerBreakpoint
}

func (r ApiLiveDebuggerBreakpointsUpdateRequest) LiveDebuggerBreakpoint(liveDebuggerBreakpoint LiveDebuggerBreakpoint) ApiLiveDebuggerBreakpointsUpdateRequest {
	r.liveDebuggerBreakpoint = &liveDebuggerBreakpoint
	return r
}

func (r ApiLiveDebuggerBreakpointsUpdateRequest) Execute() (*LiveDebuggerBreakpoint, *http.Response, error) {
	return r.ApiService.LiveDebuggerBreakpointsUpdateExecute(r)
}

/*
LiveDebuggerBreakpointsUpdate Method for LiveDebuggerBreakpointsUpdate

Create, Read, Update and Delete breakpoints for live debugging.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this live debugger breakpoint.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiLiveDebuggerBreakpointsUpdateRequest
*/
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsUpdate(ctx context.Context, id string, projectId string) ApiLiveDebuggerBreakpointsUpdateRequest {
	return ApiLiveDebuggerBreakpointsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return LiveDebuggerBreakpoint
func (a *LiveDebuggerBreakpointsAPIService) LiveDebuggerBreakpointsUpdateExecute(r ApiLiveDebuggerBreakpointsUpdateRequest) (*LiveDebuggerBreakpoint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *LiveDebuggerBreakpoint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "LiveDebuggerBreakpointsAPIService.LiveDebuggerBreakpointsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/live_debugger_breakpoints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.liveDebuggerBreakpoint == nil {
		return localVarReturnValue, nil, reportError("liveDebuggerBreakpoint is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.liveDebuggerBreakpoint
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
PostHog API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package posthogapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// PersonsAPIService PersonsAPI service
type PersonsAPIService service

type ApiPersonsActivityRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
}

func (r ApiPersonsActivityRetrieveRequest) Format(format string) ApiPersonsActivityRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsActivityRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsActivityRetrieveExecute(r)
}

/*
PersonsActivityRetrieve Method for PersonsActivityRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsActivityRetrieveRequest
*/
func (a *PersonsAPIService) PersonsActivityRetrieve(ctx context.Context, projectId string) ApiPersonsActivityRetrieveRequest {
	return ApiPersonsActivityRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsActivityRetrieveExecute(r ApiPersonsActivityRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsActivityRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsActivityRetrieve2Request struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiPersonsActivityRetrieve2Request) Format(format string) ApiPersonsActivityRetrieve2Request {
	r.format = &format
	return r
}

func (r ApiPersonsActivityRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.PersonsActivityRetrieve2Execute(r)
}

/*
PersonsActivityRetrieve2 Method for PersonsActivityRetrieve2

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsActivityRetrieve2Request
*/
func (a *PersonsAPIService) PersonsActivityRetrieve2(ctx context.Context, id int32, projectId string) ApiPersonsActivityRetrieve2Request {
	return ApiPersonsActivityRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsActivityRetrieve2Execute(r ApiPersonsActivityRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsActivityRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsBulkDeleteCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	deleteEvents *bool
	distinctIds *map[string]interface{}
	format *string
	ids *map[string]interface{}
	person *Person
}

// If true, a task to delete all events associated with this person will be created and queued. The task does not run immediately and instead is batched together and at 5AM UTC every Sunday
func (r ApiPersonsBulkDeleteCreateRequest) DeleteEvents(deleteEvents bool) ApiPersonsBulkDeleteCreateRequest {
	r.deleteEvents = &deleteEvents
	return r
}

// A list of distinct IDs, up to 1000 of them. We&#39;ll delete all persons associated with those distinct IDs.
func (r ApiPersonsBulkDeleteCreateRequest) DistinctIds(distinctIds map[string]interface{}) ApiPersonsBulkDeleteCreateRequest {
	r.distinctIds = &distinctIds
	return r
}

func (r ApiPersonsBulkDeleteCreateRequest) Format(format string) ApiPersonsBulkDeleteCreateRequest {
	r.format = &format
	return r
}

// A list of PostHog person IDs, up to 1000 of them. We&#39;ll delete all the persons listed.
func (r ApiPersonsBulkDeleteCreateRequest) Ids(ids map[string]interface{}) ApiPersonsBulkDeleteCreateRequest {
	r.ids = &ids
	return r
}

func (r ApiPersonsBulkDeleteCreateRequest) Person(person Person) ApiPersonsBulkDeleteCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsBulkDeleteCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsBulkDeleteCreateExecute(r)
}

/*
PersonsBulkDeleteCreate Method for PersonsBulkDeleteCreate

This endpoint allows you to bulk delete persons, either by the PostHog person IDs or by distinct IDs. You can pass in a maximum of 1000 IDs per call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsBulkDeleteCreateRequest
*/
func (a *PersonsAPIService) PersonsBulkDeleteCreate(ctx context.Context, projectId string) ApiPersonsBulkDeleteCreateRequest {
	return ApiPersonsBulkDeleteCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsBulkDeleteCreateExecute(r ApiPersonsBulkDeleteCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsBulkDeleteCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/bulk_delete/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", r.deleteEvents, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", defaultValue, "form", "")
        r.deleteEvents = &defaultValue
	}
	if r.distinctIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct_ids", r.distinctIds, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsCohortsRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
}

func (r ApiPersonsCohortsRetrieveRequest) Format(format string) ApiPersonsCohortsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsCohortsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsCohortsRetrieveExecute(r)
}

/*
PersonsCohortsRetrieve Method for PersonsCohortsRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsCohortsRetrieveRequest
*/
func (a *PersonsAPIService) PersonsCohortsRetrieve(ctx context.Context, projectId string) ApiPersonsCohortsRetrieveRequest {
	return ApiPersonsCohortsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsCohortsRetrieveExecute(r ApiPersonsCohortsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsCohortsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/cohorts/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsDeleteEventsCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiPersonsDeleteEventsCreateRequest) Format(format string) ApiPersonsDeleteEventsCreateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsDeleteEventsCreateRequest) Person(person Person) ApiPersonsDeleteEventsCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsDeleteEventsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsDeleteEventsCreateExecute(r)
}

/*
PersonsDeleteEventsCreate Method for PersonsDeleteEventsCreate

Queue deletion of all events associated with this person. The task runs during non-peak hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsDeleteEventsCreateRequest
*/
func (a *PersonsAPIService) PersonsDeleteEventsCreate(ctx context.Context, id int32, projectId string) ApiPersonsDeleteEventsCreateRequest {
	return ApiPersonsDeleteEventsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsDeleteEventsCreateExecute(r ApiPersonsDeleteEventsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsDeleteEventsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/delete_events/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsDeletePropertyCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	unset *string
	id int32
	projectId string
	format *string
	person *Person
}

// Specify the property key to delete
func (r ApiPersonsDeletePropertyCreateRequest) Unset(unset string) ApiPersonsDeletePropertyCreateRequest {
	r.unset = &unset
	return r
}

func (r ApiPersonsDeletePropertyCreateRequest) Format(format string) ApiPersonsDeletePropertyCreateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsDeletePropertyCreateRequest) Person(person Person) ApiPersonsDeletePropertyCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsDeletePropertyCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsDeletePropertyCreateExecute(r)
}

/*
PersonsDeletePropertyCreate Method for PersonsDeletePropertyCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsDeletePropertyCreateRequest
*/
func (a *PersonsAPIService) PersonsDeletePropertyCreate(ctx context.Context, id int32, projectId string) ApiPersonsDeletePropertyCreateRequest {
	return ApiPersonsDeletePropertyCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsDeletePropertyCreateExecute(r ApiPersonsDeletePropertyCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsDeletePropertyCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/delete_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unset == nil {
		return nil, reportError("unset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "$unset", r.unset, "form", "")
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsDeleteRecordingsCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiPersonsDeleteRecordingsCreateRequest) Format(format string) ApiPersonsDeleteRecordingsCreateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsDeleteRecordingsCreateRequest) Person(person Person) ApiPersonsDeleteRecordingsCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsDeleteRecordingsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsDeleteRecordingsCreateExecute(r)
}

/*
PersonsDeleteRecordingsCreate Method for PersonsDeleteRecordingsCreate

Queue deletion of all recordings associated with this person.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsDeleteRecordingsCreateRequest
*/
func (a *PersonsAPIService) PersonsDeleteRecordingsCreate(ctx context.Context, id int32, projectId string) ApiPersonsDeleteRecordingsCreateRequest {
	return ApiPersonsDeleteRecordingsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsDeleteRecordingsCreateExecute(r ApiPersonsDeleteRecordingsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsDeleteRecordingsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/delete_recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsDestroyRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	deleteEvents *bool
	format *string
}

// If true, a task to delete all events associated with this person will be created and queued. The task does not run immediately and instead is batched together and at 5AM UTC every Sunday
func (r ApiPersonsDestroyRequest) DeleteEvents(deleteEvents bool) ApiPersonsDestroyRequest {
	r.deleteEvents = &deleteEvents
	return r
}

func (r ApiPersonsDestroyRequest) Format(format string) ApiPersonsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiPersonsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsDestroyExecute(r)
}

/*
PersonsDestroy Method for PersonsDestroy

Use this endpoint to delete individual persons. For bulk deletion, use the bulk_delete endpoint instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsDestroyRequest
*/
func (a *PersonsAPIService) PersonsDestroy(ctx context.Context, id int32, projectId string) ApiPersonsDestroyRequest {
	return ApiPersonsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsDestroyExecute(r ApiPersonsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", r.deleteEvents, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", defaultValue, "form", "")
        r.deleteEvents = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsFunnelCorrelationCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiPersonsFunnelCorrelationCreateRequest) Format(format string) ApiPersonsFunnelCorrelationCreateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsFunnelCorrelationCreateRequest) Person(person Person) ApiPersonsFunnelCorrelationCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsFunnelCorrelationCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsFunnelCorrelationCreateExecute(r)
}

/*
PersonsFunnelCorrelationCreate Method for PersonsFunnelCorrelationCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsFunnelCorrelationCreateRequest
*/
func (a *PersonsAPIService) PersonsFunnelCorrelationCreate(ctx context.Context, projectId string) ApiPersonsFunnelCorrelationCreateRequest {
	return ApiPersonsFunnelCorrelationCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsFunnelCorrelationCreateExecute(r ApiPersonsFunnelCorrelationCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsFunnelCorrelationCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/funnel/correlation/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsFunnelCorrelationRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
}

func (r ApiPersonsFunnelCorrelationRetrieveRequest) Format(format string) ApiPersonsFunnelCorrelationRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsFunnelCorrelationRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsFunnelCorrelationRetrieveExecute(r)
}

/*
PersonsFunnelCorrelationRetrieve Method for PersonsFunnelCorrelationRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsFunnelCorrelationRetrieveRequest
*/
func (a *PersonsAPIService) PersonsFunnelCorrelationRetrieve(ctx context.Context, projectId string) ApiPersonsFunnelCorrelationRetrieveRequest {
	return ApiPersonsFunnelCorrelationRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsFunnelCorrelationRetrieveExecute(r ApiPersonsFunnelCorrelationRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsFunnelCorrelationRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/funnel/correlation/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsFunnelCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiPersonsFunnelCreateRequest) Format(format string) ApiPersonsFunnelCreateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsFunnelCreateRequest) Person(person Person) ApiPersonsFunnelCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsFunnelCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsFunnelCreateExecute(r)
}

/*
PersonsFunnelCreate Method for PersonsFunnelCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsFunnelCreateRequest
*/
func (a *PersonsAPIService) PersonsFunnelCreate(ctx context.Context, projectId string) ApiPersonsFunnelCreateRequest {
	return ApiPersonsFunnelCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsFunnelCreateExecute(r ApiPersonsFunnelCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsFunnelCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/funnel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsFunnelRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
}

func (r ApiPersonsFunnelRetrieveRequest) Format(format string) ApiPersonsFunnelRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsFunnelRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsFunnelRetrieveExecute(r)
}

/*
PersonsFunnelRetrieve Method for PersonsFunnelRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsFunnelRetrieveRequest
*/
func (a *PersonsAPIService) PersonsFunnelRetrieve(ctx context.Context, projectId string) ApiPersonsFunnelRetrieveRequest {
	return ApiPersonsFunnelRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsFunnelRetrieveExecute(r ApiPersonsFunnelRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsFunnelRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/funnel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsLifecycleRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
}

func (r ApiPersonsLifecycleRetrieveRequest) Format(format string) ApiPersonsLifecycleRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsLifecycleRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsLifecycleRetrieveExecute(r)
}

/*
PersonsLifecycleRetrieve Method for PersonsLifecycleRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsLifecycleRetrieveRequest
*/
func (a *PersonsAPIService) PersonsLifecycleRetrieve(ctx context.Context, projectId string) ApiPersonsLifecycleRetrieveRequest {
	return ApiPersonsLifecycleRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsLifecycleRetrieveExecute(r ApiPersonsLifecycleRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsLifecycleRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/lifecycle/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsListRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	distinctId *string
	email *string
	format *string
	limit *int32
	offset *int32
	properties *[]Property
	search *string
}

// Filter list by distinct id.
func (r ApiPersonsListRequest) DistinctId(distinctId string) ApiPersonsListRequest {
	r.distinctId = &distinctId
	return r
}

// Filter persons by email (exact match)
func (r ApiPersonsListRequest) Email(email string) ApiPersonsListRequest {
	r.email = &email
	return r
}

func (r ApiPersonsListRequest) Format(format string) ApiPersonsListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiPersonsListRequest) Limit(limit int32) ApiPersonsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiPersonsListRequest) Offset(offset int32) ApiPersonsListRequest {
	r.offset = &offset
	return r
}

// Filter Persons by person properties.
func (r ApiPersonsListRequest) Properties(properties []Property) ApiPersonsListRequest {
	r.properties = &properties
	return r
}

// Search persons, either by email (full text search) or distinct_id (exact match).
func (r ApiPersonsListRequest) Search(search string) ApiPersonsListRequest {
	r.search = &search
	return r
}

func (r ApiPersonsListRequest) Execute() (*PaginatedPersonList, *http.Response, error) {
	return r.ApiService.PersonsListExecute(r)
}

/*
PersonsList Method for PersonsList

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsListRequest
*/
func (a *PersonsAPIService) PersonsList(ctx context.Context, projectId string) ApiPersonsListRequest {
	return ApiPersonsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedPersonList
func (a *PersonsAPIService) PersonsListExecute(r ApiPersonsListRequest) (*PaginatedPersonList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPersonList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinctId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct_id", r.distinctId, "form", "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPersonsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	format *string
	patchedPerson *PatchedPerson
}

func (r ApiPersonsPartialUpdateRequest) Format(format string) ApiPersonsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsPartialUpdateRequest) PatchedPerson(patchedPerson PatchedPerson) ApiPersonsPartialUpdateRequest {
	r.patchedPerson = &patchedPerson
	return r
}

func (r ApiPersonsPartialUpdateRequest) Execute() (*Person, *http.Response, error) {
	return r.ApiService.PersonsPartialUpdateExecute(r)
}

/*
PersonsPartialUpdate Method for PersonsPartialUpdate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsPartialUpdateRequest
*/
func (a *PersonsAPIService) PersonsPartialUpdate(ctx context.Context, id int32, projectId string) ApiPersonsPartialUpdateRequest {
	return ApiPersonsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *PersonsAPIService) PersonsPartialUpdateExecute(r ApiPersonsPartialUpdateRequest) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPerson
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPersonsPropertiesTimelineRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiPersonsPropertiesTimelineRetrieveRequest) Format(format string) ApiPersonsPropertiesTimelineRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsPropertiesTimelineRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsPropertiesTimelineRetrieveExecute(r)
}

/*
PersonsPropertiesTimelineRetrieve Method for PersonsPropertiesTimelineRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsPropertiesTimelineRetrieveRequest
*/
func (a *PersonsAPIService) PersonsPropertiesTimelineRetrieve(ctx context.Context, id int32, projectId string) ApiPersonsPropertiesTimelineRetrieveRequest {
	return ApiPersonsPropertiesTimelineRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsPropertiesTimelineRetrieveExecute(r ApiPersonsPropertiesTimelineRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsPropertiesTimelineRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/properties_timeline/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsResetPersonDistinctIdCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiPersonsResetPersonDistinctIdCreateRequest) Format(format string) ApiPersonsResetPersonDistinctIdCreateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsResetPersonDistinctIdCreateRequest) Person(person Person) ApiPersonsResetPersonDistinctIdCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsResetPersonDistinctIdCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsResetPersonDistinctIdCreateExecute(r)
}

/*
PersonsResetPersonDistinctIdCreate Method for PersonsResetPersonDistinctIdCreate

Reset a distinct_id for a deleted person. This allows the distinct_id to be used again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsResetPersonDistinctIdCreateRequest
*/
func (a *PersonsAPIService) PersonsResetPersonDistinctIdCreate(ctx context.Context, projectId string) ApiPersonsResetPersonDistinctIdCreateRequest {
	return ApiPersonsResetPersonDistinctIdCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsResetPersonDistinctIdCreateExecute(r ApiPersonsResetPersonDistinctIdCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsResetPersonDistinctIdCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/reset_person_distinct_id/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiPersonsRetrieveRequest) Format(format string) ApiPersonsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsRetrieveRequest) Execute() (*Person, *http.Response, error) {
	return r.ApiService.PersonsRetrieveExecute(r)
}

/*
PersonsRetrieve Method for PersonsRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsRetrieveRequest
*/
func (a *PersonsAPIService) PersonsRetrieve(ctx context.Context, id int32, projectId string) ApiPersonsRetrieveRequest {
	return ApiPersonsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *PersonsAPIService) PersonsRetrieveExecute(r ApiPersonsRetrieveRequest) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPersonsSplitCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiPersonsSplitCreateRequest) Format(format string) ApiPersonsSplitCreateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsSplitCreateRequest) Person(person Person) ApiPersonsSplitCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsSplitCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsSplitCreateExecute(r)
}

/*
PersonsSplitCreate Method for PersonsSplitCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsSplitCreateRequest
*/
func (a *PersonsAPIService) PersonsSplitCreate(ctx context.Context, id int32, projectId string) ApiPersonsSplitCreateRequest {
	return ApiPersonsSplitCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsSplitCreateExecute(r ApiPersonsSplitCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsSplitCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/split/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsStickinessRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
}

func (r ApiPersonsStickinessRetrieveRequest) Format(format string) ApiPersonsStickinessRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsStickinessRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsStickinessRetrieveExecute(r)
}

/*
PersonsStickinessRetrieve Method for PersonsStickinessRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsStickinessRetrieveRequest
*/
func (a *PersonsAPIService) PersonsStickinessRetrieve(ctx context.Context, projectId string) ApiPersonsStickinessRetrieveRequest {
	return ApiPersonsStickinessRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsStickinessRetrieveExecute(r ApiPersonsStickinessRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsStickinessRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/stickiness/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsTrendsRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
}

func (r ApiPersonsTrendsRetrieveRequest) Format(format string) ApiPersonsTrendsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsTrendsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsTrendsRetrieveExecute(r)
}

/*
PersonsTrendsRetrieve Method for PersonsTrendsRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsTrendsRetrieveRequest
*/
func (a *PersonsAPIService) PersonsTrendsRetrieve(ctx context.Context, projectId string) ApiPersonsTrendsRetrieveRequest {
	return ApiPersonsTrendsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsTrendsRetrieveExecute(r ApiPersonsTrendsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsTrendsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/trends/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsUpdateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiPersonsUpdateRequest) Format(format string) ApiPersonsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsUpdateRequest) Person(person Person) ApiPersonsUpdateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsUpdateRequest) Execute() (*Person, *http.Response, error) {
	return r.ApiService.PersonsUpdateExecute(r)
}

/*
PersonsUpdate Method for PersonsUpdate

Only for setting properties on the person. "properties" from the request data will be updated via a "$set" event.
This means that only the properties listed will be updated, but other properties won't be removed nor updated.
If you would like to remove a property use the `delete_property` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsUpdateRequest
*/
func (a *PersonsAPIService) PersonsUpdate(ctx context.Context, id int32, projectId string) ApiPersonsUpdateRequest {
	return ApiPersonsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *PersonsAPIService) PersonsUpdateExecute(r ApiPersonsUpdateRequest) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPersonsUpdatePropertyCreateRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	id int32
	key *string
	projectId string
	value *interface{}
	format *string
	person *Person
}

// Specify the property key
func (r ApiPersonsUpdatePropertyCreateRequest) Key(key string) ApiPersonsUpdatePropertyCreateRequest {
	r.key = &key
	return r
}

// Specify the property value
func (r ApiPersonsUpdatePropertyCreateRequest) Value(value interface{}) ApiPersonsUpdatePropertyCreateRequest {
	r.value = &value
	return r
}

func (r ApiPersonsUpdatePropertyCreateRequest) Format(format string) ApiPersonsUpdatePropertyCreateRequest {
	r.format = &format
	return r
}

func (r ApiPersonsUpdatePropertyCreateRequest) Person(person Person) ApiPersonsUpdatePropertyCreateRequest {
	r.person = &person
	return r
}

func (r ApiPersonsUpdatePropertyCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsUpdatePropertyCreateExecute(r)
}

/*
PersonsUpdatePropertyCreate Method for PersonsUpdatePropertyCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsUpdatePropertyCreateRequest
*/
func (a *PersonsAPIService) PersonsUpdatePropertyCreate(ctx context.Context, id int32, projectId string) ApiPersonsUpdatePropertyCreateRequest {
	return ApiPersonsUpdatePropertyCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsUpdatePropertyCreateExecute(r ApiPersonsUpdatePropertyCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsUpdatePropertyCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/{id}/update_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.key == nil {
		return nil, reportError("key is required and must be specified")
	}
	if r.value == nil {
		return nil, reportError("value is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiPersonsValuesRetrieveRequest struct {
	ctx context.Context
	ApiService *PersonsAPIService
	projectId string
	format *string
}

func (r ApiPersonsValuesRetrieveRequest) Format(format string) ApiPersonsValuesRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiPersonsValuesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.PersonsValuesRetrieveExecute(r)
}

/*
PersonsValuesRetrieve Method for PersonsValuesRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiPersonsValuesRetrieveRequest
*/
func (a *PersonsAPIService) PersonsValuesRetrieve(ctx context.Context, projectId string) ApiPersonsValuesRetrieveRequest {
	return ApiPersonsValuesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *PersonsAPIService) PersonsValuesRetrieveExecute(r ApiPersonsValuesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PersonsAPIService.PersonsValuesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/persons/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
PostHog API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package posthogapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
	"reflect"
)


// EnvironmentsAPIService EnvironmentsAPI service
type EnvironmentsAPIService service

type ApiCreateSessionSummariesRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionSummaries *SessionSummaries
}

func (r ApiCreateSessionSummariesRequest) SessionSummaries(sessionSummaries SessionSummaries) ApiCreateSessionSummariesRequest {
	r.sessionSummaries = &sessionSummaries
	return r
}

func (r ApiCreateSessionSummariesRequest) Execute() (*SessionSummaries, *http.Response, error) {
	return r.ApiService.CreateSessionSummariesExecute(r)
}

/*
CreateSessionSummaries Method for CreateSessionSummaries

Generate AI summary for a group of session recordings to find patterns and generate a notebook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiCreateSessionSummariesRequest
*/
func (a *EnvironmentsAPIService) CreateSessionSummaries(ctx context.Context, projectId string) ApiCreateSessionSummariesRequest {
	return ApiCreateSessionSummariesRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionSummaries
func (a *EnvironmentsAPIService) CreateSessionSummariesExecute(r ApiCreateSessionSummariesRequest) (*SessionSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.CreateSessionSummaries")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_summaries/create_session_summaries/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionSummaries == nil {
		return localVarReturnValue, nil, reportError("sessionSummaries is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionSummaries
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSessionSummariesIndividuallyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionSummaries *SessionSummaries
}

func (r ApiCreateSessionSummariesIndividuallyRequest) SessionSummaries(sessionSummaries SessionSummaries) ApiCreateSessionSummariesIndividuallyRequest {
	r.sessionSummaries = &sessionSummaries
	return r
}

func (r ApiCreateSessionSummariesIndividuallyRequest) Execute() (*SessionSummaries, *http.Response, error) {
	return r.ApiService.CreateSessionSummariesIndividuallyExecute(r)
}

/*
CreateSessionSummariesIndividually Method for CreateSessionSummariesIndividually

Generate AI individual summary for each session, without grouping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiCreateSessionSummariesIndividuallyRequest
*/
func (a *EnvironmentsAPIService) CreateSessionSummariesIndividually(ctx context.Context, projectId string) ApiCreateSessionSummariesIndividuallyRequest {
	return ApiCreateSessionSummariesIndividuallyRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionSummaries
func (a *EnvironmentsAPIService) CreateSessionSummariesIndividuallyExecute(r ApiCreateSessionSummariesIndividuallyRequest) (*SessionSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.CreateSessionSummariesIndividually")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_summaries/create_session_summaries_individually/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionSummaries == nil {
		return localVarReturnValue, nil, reportError("sessionSummaries is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionSummaries
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSessionSummariesIndividually_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionSummaries *SessionSummaries
}

func (r ApiCreateSessionSummariesIndividually_0Request) SessionSummaries(sessionSummaries SessionSummaries) ApiCreateSessionSummariesIndividually_0Request {
	r.sessionSummaries = &sessionSummaries
	return r
}

func (r ApiCreateSessionSummariesIndividually_0Request) Execute() (*SessionSummaries, *http.Response, error) {
	return r.ApiService.CreateSessionSummariesIndividually_1Execute(r)
}

/*
CreateSessionSummariesIndividually_0 Method for CreateSessionSummariesIndividually_0

Generate AI individual summary for each session, without grouping.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiCreateSessionSummariesIndividually_0Request
*/
func (a *EnvironmentsAPIService) CreateSessionSummariesIndividually_1(ctx context.Context, projectId string) ApiCreateSessionSummariesIndividually_0Request {
	return ApiCreateSessionSummariesIndividually_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionSummaries
func (a *EnvironmentsAPIService) CreateSessionSummariesIndividually_1Execute(r ApiCreateSessionSummariesIndividually_0Request) (*SessionSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.CreateSessionSummariesIndividually_1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_summaries/create_session_summaries_individually/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionSummaries == nil {
		return localVarReturnValue, nil, reportError("sessionSummaries is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionSummaries
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateSessionSummaries_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionSummaries *SessionSummaries
}

func (r ApiCreateSessionSummaries_0Request) SessionSummaries(sessionSummaries SessionSummaries) ApiCreateSessionSummaries_0Request {
	r.sessionSummaries = &sessionSummaries
	return r
}

func (r ApiCreateSessionSummaries_0Request) Execute() (*SessionSummaries, *http.Response, error) {
	return r.ApiService.CreateSessionSummaries_2Execute(r)
}

/*
CreateSessionSummaries_0 Method for CreateSessionSummaries_0

Generate AI summary for a group of session recordings to find patterns and generate a notebook.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiCreateSessionSummaries_0Request
*/
func (a *EnvironmentsAPIService) CreateSessionSummaries_2(ctx context.Context, projectId string) ApiCreateSessionSummaries_0Request {
	return ApiCreateSessionSummaries_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionSummaries
func (a *EnvironmentsAPIService) CreateSessionSummaries_2Execute(r ApiCreateSessionSummaries_0Request) (*SessionSummaries, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionSummaries
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.CreateSessionSummaries_2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_summaries/create_session_summaries/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.sessionSummaries == nil {
		return localVarReturnValue, nil, reportError("sessionSummaries is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionSummaries
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsActivityRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsActivityRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsActivityRetrieveExecute(r)
}

/*
EnvironmentsActivityRetrieve Method for EnvironmentsActivityRetrieve

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsActivityRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsActivityRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsActivityRetrieveRequest {
	return ApiEnvironmentsActivityRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsActivityRetrieveExecute(r ApiEnvironmentsActivityRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsActivityRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAddProductIntentPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedTeam *PatchedTeam
}

func (r ApiEnvironmentsAddProductIntentPartialUpdateRequest) PatchedTeam(patchedTeam PatchedTeam) ApiEnvironmentsAddProductIntentPartialUpdateRequest {
	r.patchedTeam = &patchedTeam
	return r
}

func (r ApiEnvironmentsAddProductIntentPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAddProductIntentPartialUpdateExecute(r)
}

/*
EnvironmentsAddProductIntentPartialUpdate Method for EnvironmentsAddProductIntentPartialUpdate

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAddProductIntentPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsAddProductIntentPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsAddProductIntentPartialUpdateRequest {
	return ApiEnvironmentsAddProductIntentPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAddProductIntentPartialUpdateExecute(r ApiEnvironmentsAddProductIntentPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAddProductIntentPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/add_product_intent/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTeam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAppMetricsErrorDetailsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsAppMetricsErrorDetailsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAppMetricsErrorDetailsRetrieveExecute(r)
}

/*
EnvironmentsAppMetricsErrorDetailsRetrieve Method for EnvironmentsAppMetricsErrorDetailsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this plugin config.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAppMetricsErrorDetailsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsErrorDetailsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsAppMetricsErrorDetailsRetrieveRequest {
	return ApiEnvironmentsAppMetricsErrorDetailsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsErrorDetailsRetrieveExecute(r ApiEnvironmentsAppMetricsErrorDetailsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAppMetricsErrorDetailsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/app_metrics/{id}/error_details/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAppMetricsErrorDetailsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsAppMetricsErrorDetailsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAppMetricsErrorDetailsRetrieve_3Execute(r)
}

/*
EnvironmentsAppMetricsErrorDetailsRetrieve_0 Method for EnvironmentsAppMetricsErrorDetailsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this plugin config.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAppMetricsErrorDetailsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsErrorDetailsRetrieve_3(ctx context.Context, id int32, projectId string) ApiEnvironmentsAppMetricsErrorDetailsRetrieve_0Request {
	return ApiEnvironmentsAppMetricsErrorDetailsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsErrorDetailsRetrieve_3Execute(r ApiEnvironmentsAppMetricsErrorDetailsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAppMetricsErrorDetailsRetrieve_3")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/app_metrics/{id}/error_details/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAppMetricsHistoricalExportsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	pluginConfigId string
	projectId string
}

func (r ApiEnvironmentsAppMetricsHistoricalExportsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAppMetricsHistoricalExportsRetrieveExecute(r)
}

/*
EnvironmentsAppMetricsHistoricalExportsRetrieve Method for EnvironmentsAppMetricsHistoricalExportsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pluginConfigId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAppMetricsHistoricalExportsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsHistoricalExportsRetrieve(ctx context.Context, pluginConfigId string, projectId string) ApiEnvironmentsAppMetricsHistoricalExportsRetrieveRequest {
	return ApiEnvironmentsAppMetricsHistoricalExportsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		pluginConfigId: pluginConfigId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsHistoricalExportsRetrieveExecute(r ApiEnvironmentsAppMetricsHistoricalExportsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAppMetricsHistoricalExportsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/app_metrics/{plugin_config_id}/historical_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_config_id"+"}", url.PathEscape(parameterValueToString(r.pluginConfigId, "pluginConfigId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	pluginConfigId string
	projectId string
}

func (r ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAppMetricsHistoricalExportsRetrieve2Execute(r)
}

/*
EnvironmentsAppMetricsHistoricalExportsRetrieve2 Method for EnvironmentsAppMetricsHistoricalExportsRetrieve2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param pluginConfigId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2Request
*/
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsHistoricalExportsRetrieve2(ctx context.Context, id string, pluginConfigId string, projectId string) ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2Request {
	return ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		pluginConfigId: pluginConfigId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsHistoricalExportsRetrieve2Execute(r ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAppMetricsHistoricalExportsRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/app_metrics/{plugin_config_id}/historical_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_config_id"+"}", url.PathEscape(parameterValueToString(r.pluginConfigId, "pluginConfigId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	pluginConfigId string
	projectId string
}

func (r ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAppMetricsHistoricalExportsRetrieve2_4Execute(r)
}

/*
EnvironmentsAppMetricsHistoricalExportsRetrieve2_0 Method for EnvironmentsAppMetricsHistoricalExportsRetrieve2_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param pluginConfigId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsHistoricalExportsRetrieve2_4(ctx context.Context, id string, pluginConfigId string, projectId string) ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2_0Request {
	return ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		pluginConfigId: pluginConfigId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsHistoricalExportsRetrieve2_4Execute(r ApiEnvironmentsAppMetricsHistoricalExportsRetrieve2_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAppMetricsHistoricalExportsRetrieve2_4")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/app_metrics/{plugin_config_id}/historical_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_config_id"+"}", url.PathEscape(parameterValueToString(r.pluginConfigId, "pluginConfigId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAppMetricsHistoricalExportsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	pluginConfigId string
	projectId string
}

func (r ApiEnvironmentsAppMetricsHistoricalExportsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAppMetricsHistoricalExportsRetrieve_5Execute(r)
}

/*
EnvironmentsAppMetricsHistoricalExportsRetrieve_0 Method for EnvironmentsAppMetricsHistoricalExportsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pluginConfigId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAppMetricsHistoricalExportsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsHistoricalExportsRetrieve_5(ctx context.Context, pluginConfigId string, projectId string) ApiEnvironmentsAppMetricsHistoricalExportsRetrieve_0Request {
	return ApiEnvironmentsAppMetricsHistoricalExportsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		pluginConfigId: pluginConfigId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsHistoricalExportsRetrieve_5Execute(r ApiEnvironmentsAppMetricsHistoricalExportsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAppMetricsHistoricalExportsRetrieve_5")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/app_metrics/{plugin_config_id}/historical_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_config_id"+"}", url.PathEscape(parameterValueToString(r.pluginConfigId, "pluginConfigId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAppMetricsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsAppMetricsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAppMetricsRetrieveExecute(r)
}

/*
EnvironmentsAppMetricsRetrieve Method for EnvironmentsAppMetricsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this plugin config.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAppMetricsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsAppMetricsRetrieveRequest {
	return ApiEnvironmentsAppMetricsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsRetrieveExecute(r ApiEnvironmentsAppMetricsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAppMetricsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/app_metrics/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsAppMetricsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsAppMetricsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsAppMetricsRetrieve_6Execute(r)
}

/*
EnvironmentsAppMetricsRetrieve_0 Method for EnvironmentsAppMetricsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this plugin config.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsAppMetricsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsRetrieve_6(ctx context.Context, id int32, projectId string) ApiEnvironmentsAppMetricsRetrieve_0Request {
	return ApiEnvironmentsAppMetricsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsAppMetricsRetrieve_6Execute(r ApiEnvironmentsAppMetricsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsAppMetricsRetrieve_6")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/app_metrics/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsBackfillCreateRequest) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsBackfillCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsBackfillCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillCreateExecute(r)
}

/*
EnvironmentsBatchExportsBackfillCreate Method for EnvironmentsBatchExportsBackfillCreate

Trigger a backfill for a BatchExport.

Note: This endpoint is deprecated. Please use POST /batch_exports/<id>/backfills/ instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsBackfillCreateRequest {
	return ApiEnvironmentsBatchExportsBackfillCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillCreateExecute(r ApiEnvironmentsBatchExportsBackfillCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/backfill/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsBackfillCreate_0Request) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsBackfillCreate_0Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsBackfillCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillCreate_7Execute(r)
}

/*
EnvironmentsBatchExportsBackfillCreate_0 Method for EnvironmentsBatchExportsBackfillCreate_0

Trigger a backfill for a BatchExport.

Note: This endpoint is deprecated. Please use POST /batch_exports/<id>/backfills/ instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillCreate_7(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsBackfillCreate_0Request {
	return ApiEnvironmentsBatchExportsBackfillCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillCreate_7Execute(r ApiEnvironmentsBatchExportsBackfillCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillCreate_7")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/backfill/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillsCancelCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
	batchExportBackfill *BatchExportBackfill
}

func (r ApiEnvironmentsBatchExportsBackfillsCancelCreateRequest) BatchExportBackfill(batchExportBackfill BatchExportBackfill) ApiEnvironmentsBatchExportsBackfillsCancelCreateRequest {
	r.batchExportBackfill = &batchExportBackfill
	return r
}

func (r ApiEnvironmentsBatchExportsBackfillsCancelCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillsCancelCreateExecute(r)
}

/*
EnvironmentsBatchExportsBackfillsCancelCreate Method for EnvironmentsBatchExportsBackfillsCancelCreate

Cancel a batch export backfill.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export backfill.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillsCancelCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsCancelCreate(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsBackfillsCancelCreateRequest {
	return ApiEnvironmentsBatchExportsBackfillsCancelCreateRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsCancelCreateExecute(r ApiEnvironmentsBatchExportsBackfillsCancelCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillsCancelCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/backfills/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportBackfill == nil {
		return nil, reportError("batchExportBackfill is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportBackfill
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillsCancelCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
	batchExportBackfill *BatchExportBackfill
}

func (r ApiEnvironmentsBatchExportsBackfillsCancelCreate_0Request) BatchExportBackfill(batchExportBackfill BatchExportBackfill) ApiEnvironmentsBatchExportsBackfillsCancelCreate_0Request {
	r.batchExportBackfill = &batchExportBackfill
	return r
}

func (r ApiEnvironmentsBatchExportsBackfillsCancelCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillsCancelCreate_8Execute(r)
}

/*
EnvironmentsBatchExportsBackfillsCancelCreate_0 Method for EnvironmentsBatchExportsBackfillsCancelCreate_0

Cancel a batch export backfill.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export backfill.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillsCancelCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsCancelCreate_8(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsBackfillsCancelCreate_0Request {
	return ApiEnvironmentsBatchExportsBackfillsCancelCreate_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsCancelCreate_8Execute(r ApiEnvironmentsBatchExportsBackfillsCancelCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillsCancelCreate_8")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/backfills/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportBackfill == nil {
		return nil, reportError("batchExportBackfill is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportBackfill
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	projectId string
	batchExportBackfill *BatchExportBackfill
}

func (r ApiEnvironmentsBatchExportsBackfillsCreateRequest) BatchExportBackfill(batchExportBackfill BatchExportBackfill) ApiEnvironmentsBatchExportsBackfillsCreateRequest {
	r.batchExportBackfill = &batchExportBackfill
	return r
}

func (r ApiEnvironmentsBatchExportsBackfillsCreateRequest) Execute() (*BatchExportBackfill, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillsCreateExecute(r)
}

/*
EnvironmentsBatchExportsBackfillsCreate Method for EnvironmentsBatchExportsBackfillsCreate

Create a new backfill for a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsCreate(ctx context.Context, batchExportId string, projectId string) ApiEnvironmentsBatchExportsBackfillsCreateRequest {
	return ApiEnvironmentsBatchExportsBackfillsCreateRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportBackfill
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsCreateExecute(r ApiEnvironmentsBatchExportsBackfillsCreateRequest) (*BatchExportBackfill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportBackfill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/backfills/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportBackfill == nil {
		return localVarReturnValue, nil, reportError("batchExportBackfill is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportBackfill
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	projectId string
	batchExportBackfill *BatchExportBackfill
}

func (r ApiEnvironmentsBatchExportsBackfillsCreate_0Request) BatchExportBackfill(batchExportBackfill BatchExportBackfill) ApiEnvironmentsBatchExportsBackfillsCreate_0Request {
	r.batchExportBackfill = &batchExportBackfill
	return r
}

func (r ApiEnvironmentsBatchExportsBackfillsCreate_0Request) Execute() (*BatchExportBackfill, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillsCreate_9Execute(r)
}

/*
EnvironmentsBatchExportsBackfillsCreate_0 Method for EnvironmentsBatchExportsBackfillsCreate_0

Create a new backfill for a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsCreate_9(ctx context.Context, batchExportId string, projectId string) ApiEnvironmentsBatchExportsBackfillsCreate_0Request {
	return ApiEnvironmentsBatchExportsBackfillsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportBackfill
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsCreate_9Execute(r ApiEnvironmentsBatchExportsBackfillsCreate_0Request) (*BatchExportBackfill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportBackfill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillsCreate_9")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/backfills/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportBackfill == nil {
		return localVarReturnValue, nil, reportError("batchExportBackfill is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportBackfill
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	projectId string
	cursor *string
	ordering *string
}

// The pagination cursor value.
func (r ApiEnvironmentsBatchExportsBackfillsListRequest) Cursor(cursor string) ApiEnvironmentsBatchExportsBackfillsListRequest {
	r.cursor = &cursor
	return r
}

// Which field to use when ordering the results.
func (r ApiEnvironmentsBatchExportsBackfillsListRequest) Ordering(ordering string) ApiEnvironmentsBatchExportsBackfillsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiEnvironmentsBatchExportsBackfillsListRequest) Execute() (*PaginatedBatchExportBackfillList, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillsListExecute(r)
}

/*
EnvironmentsBatchExportsBackfillsList Method for EnvironmentsBatchExportsBackfillsList

ViewSet for BatchExportBackfill models.

Allows creating and reading backfills, but not updating or deleting them.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsList(ctx context.Context, batchExportId string, projectId string) ApiEnvironmentsBatchExportsBackfillsListRequest {
	return ApiEnvironmentsBatchExportsBackfillsListRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportBackfillList
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsListExecute(r ApiEnvironmentsBatchExportsBackfillsListRequest) (*PaginatedBatchExportBackfillList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportBackfillList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/backfills/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	projectId string
	cursor *string
	ordering *string
}

// The pagination cursor value.
func (r ApiEnvironmentsBatchExportsBackfillsList_0Request) Cursor(cursor string) ApiEnvironmentsBatchExportsBackfillsList_0Request {
	r.cursor = &cursor
	return r
}

// Which field to use when ordering the results.
func (r ApiEnvironmentsBatchExportsBackfillsList_0Request) Ordering(ordering string) ApiEnvironmentsBatchExportsBackfillsList_0Request {
	r.ordering = &ordering
	return r
}

func (r ApiEnvironmentsBatchExportsBackfillsList_0Request) Execute() (*PaginatedBatchExportBackfillList, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillsList_10Execute(r)
}

/*
EnvironmentsBatchExportsBackfillsList_0 Method for EnvironmentsBatchExportsBackfillsList_0

ViewSet for BatchExportBackfill models.

Allows creating and reading backfills, but not updating or deleting them.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsList_10(ctx context.Context, batchExportId string, projectId string) ApiEnvironmentsBatchExportsBackfillsList_0Request {
	return ApiEnvironmentsBatchExportsBackfillsList_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportBackfillList
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsList_10Execute(r ApiEnvironmentsBatchExportsBackfillsList_0Request) (*PaginatedBatchExportBackfillList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportBackfillList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillsList_10")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/backfills/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsBackfillsRetrieveRequest) Execute() (*BatchExportBackfill, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillsRetrieveExecute(r)
}

/*
EnvironmentsBatchExportsBackfillsRetrieve Method for EnvironmentsBatchExportsBackfillsRetrieve

ViewSet for BatchExportBackfill models.

Allows creating and reading backfills, but not updating or deleting them.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export backfill.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsRetrieve(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsBackfillsRetrieveRequest {
	return ApiEnvironmentsBatchExportsBackfillsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportBackfill
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsRetrieveExecute(r ApiEnvironmentsBatchExportsBackfillsRetrieveRequest) (*BatchExportBackfill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportBackfill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/backfills/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsBackfillsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsBackfillsRetrieve_0Request) Execute() (*BatchExportBackfill, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsBackfillsRetrieve_11Execute(r)
}

/*
EnvironmentsBatchExportsBackfillsRetrieve_0 Method for EnvironmentsBatchExportsBackfillsRetrieve_0

ViewSet for BatchExportBackfill models.

Allows creating and reading backfills, but not updating or deleting them.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export backfill.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsBackfillsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsRetrieve_11(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsBackfillsRetrieve_0Request {
	return ApiEnvironmentsBatchExportsBackfillsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportBackfill
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsBackfillsRetrieve_11Execute(r ApiEnvironmentsBatchExportsBackfillsRetrieve_0Request) (*BatchExportBackfill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportBackfill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsBackfillsRetrieve_11")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/backfills/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsCreateRequest) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsCreateRequest) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsCreateExecute(r)
}

/*
EnvironmentsBatchExportsCreate Method for EnvironmentsBatchExportsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsCreate(ctx context.Context, projectId string) ApiEnvironmentsBatchExportsCreateRequest {
	return ApiEnvironmentsBatchExportsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsCreateExecute(r ApiEnvironmentsBatchExportsCreateRequest) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return localVarReturnValue, nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsCreate_0Request) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsCreate_0Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsCreate_0Request) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsCreate_12Execute(r)
}

/*
EnvironmentsBatchExportsCreate_0 Method for EnvironmentsBatchExportsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsCreate_12(ctx context.Context, projectId string) ApiEnvironmentsBatchExportsCreate_0Request {
	return ApiEnvironmentsBatchExportsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsCreate_12Execute(r ApiEnvironmentsBatchExportsCreate_0Request) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsCreate_12")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return localVarReturnValue, nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsDestroyExecute(r)
}

/*
EnvironmentsBatchExportsDestroy Method for EnvironmentsBatchExportsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsDestroyRequest {
	return ApiEnvironmentsBatchExportsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsDestroyExecute(r ApiEnvironmentsBatchExportsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsDestroy_13Execute(r)
}

/*
EnvironmentsBatchExportsDestroy_0 Method for EnvironmentsBatchExportsDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsDestroy_13(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsDestroy_0Request {
	return ApiEnvironmentsBatchExportsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsDestroy_13Execute(r ApiEnvironmentsBatchExportsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsDestroy_13")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsBatchExportsListRequest) Limit(limit int32) ApiEnvironmentsBatchExportsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsBatchExportsListRequest) Offset(offset int32) ApiEnvironmentsBatchExportsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsBatchExportsListRequest) Execute() (*PaginatedBatchExportList, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsListExecute(r)
}

/*
EnvironmentsBatchExportsList Method for EnvironmentsBatchExportsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsList(ctx context.Context, projectId string) ApiEnvironmentsBatchExportsListRequest {
	return ApiEnvironmentsBatchExportsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportList
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsListExecute(r ApiEnvironmentsBatchExportsListRequest) (*PaginatedBatchExportList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsBatchExportsList_0Request) Limit(limit int32) ApiEnvironmentsBatchExportsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsBatchExportsList_0Request) Offset(offset int32) ApiEnvironmentsBatchExportsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsBatchExportsList_0Request) Execute() (*PaginatedBatchExportList, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsList_14Execute(r)
}

/*
EnvironmentsBatchExportsList_0 Method for EnvironmentsBatchExportsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsList_14(ctx context.Context, projectId string) ApiEnvironmentsBatchExportsList_0Request {
	return ApiEnvironmentsBatchExportsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportList
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsList_14Execute(r ApiEnvironmentsBatchExportsList_0Request) (*PaginatedBatchExportList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsList_14")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsLogsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsLogsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsLogsRetrieveExecute(r)
}

/*
EnvironmentsBatchExportsLogsRetrieve Method for EnvironmentsBatchExportsLogsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsLogsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsLogsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsLogsRetrieveRequest {
	return ApiEnvironmentsBatchExportsLogsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsLogsRetrieveExecute(r ApiEnvironmentsBatchExportsLogsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsLogsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsLogsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsLogsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsLogsRetrieve_15Execute(r)
}

/*
EnvironmentsBatchExportsLogsRetrieve_0 Method for EnvironmentsBatchExportsLogsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsLogsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsLogsRetrieve_15(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsLogsRetrieve_0Request {
	return ApiEnvironmentsBatchExportsLogsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsLogsRetrieve_15Execute(r ApiEnvironmentsBatchExportsLogsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsLogsRetrieve_15")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedBatchExport *PatchedBatchExport
}

func (r ApiEnvironmentsBatchExportsPartialUpdateRequest) PatchedBatchExport(patchedBatchExport PatchedBatchExport) ApiEnvironmentsBatchExportsPartialUpdateRequest {
	r.patchedBatchExport = &patchedBatchExport
	return r
}

func (r ApiEnvironmentsBatchExportsPartialUpdateRequest) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsPartialUpdateExecute(r)
}

/*
EnvironmentsBatchExportsPartialUpdate Method for EnvironmentsBatchExportsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsPartialUpdateRequest {
	return ApiEnvironmentsBatchExportsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsPartialUpdateExecute(r ApiEnvironmentsBatchExportsPartialUpdateRequest) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBatchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedBatchExport *PatchedBatchExport
}

func (r ApiEnvironmentsBatchExportsPartialUpdate_0Request) PatchedBatchExport(patchedBatchExport PatchedBatchExport) ApiEnvironmentsBatchExportsPartialUpdate_0Request {
	r.patchedBatchExport = &patchedBatchExport
	return r
}

func (r ApiEnvironmentsBatchExportsPartialUpdate_0Request) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsPartialUpdate_16Execute(r)
}

/*
EnvironmentsBatchExportsPartialUpdate_0 Method for EnvironmentsBatchExportsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsPartialUpdate_16(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsPartialUpdate_0Request {
	return ApiEnvironmentsBatchExportsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsPartialUpdate_16Execute(r ApiEnvironmentsBatchExportsPartialUpdate_0Request) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsPartialUpdate_16")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBatchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsPauseCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsPauseCreateRequest) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsPauseCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsPauseCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsPauseCreateExecute(r)
}

/*
EnvironmentsBatchExportsPauseCreate Method for EnvironmentsBatchExportsPauseCreate

Pause a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsPauseCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsPauseCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsPauseCreateRequest {
	return ApiEnvironmentsBatchExportsPauseCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsPauseCreateExecute(r ApiEnvironmentsBatchExportsPauseCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsPauseCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/pause/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsPauseCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsPauseCreate_0Request) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsPauseCreate_0Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsPauseCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsPauseCreate_17Execute(r)
}

/*
EnvironmentsBatchExportsPauseCreate_0 Method for EnvironmentsBatchExportsPauseCreate_0

Pause a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsPauseCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsPauseCreate_17(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsPauseCreate_0Request {
	return ApiEnvironmentsBatchExportsPauseCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsPauseCreate_17Execute(r ApiEnvironmentsBatchExportsPauseCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsPauseCreate_17")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/pause/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsRetrieveRequest) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRetrieveExecute(r)
}

/*
EnvironmentsBatchExportsRetrieve Method for EnvironmentsBatchExportsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsRetrieveRequest {
	return ApiEnvironmentsBatchExportsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRetrieveExecute(r ApiEnvironmentsBatchExportsRetrieveRequest) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsRetrieve_0Request) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRetrieve_18Execute(r)
}

/*
EnvironmentsBatchExportsRetrieve_0 Method for EnvironmentsBatchExportsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRetrieve_18(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsRetrieve_0Request {
	return ApiEnvironmentsBatchExportsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRetrieve_18Execute(r ApiEnvironmentsBatchExportsRetrieve_0Request) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRetrieve_18")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunTestStepCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsRunTestStepCreateRequest) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsRunTestStepCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsRunTestStepCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunTestStepCreateExecute(r)
}

/*
EnvironmentsBatchExportsRunTestStepCreate Method for EnvironmentsBatchExportsRunTestStepCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunTestStepCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunTestStepCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsRunTestStepCreateRequest {
	return ApiEnvironmentsBatchExportsRunTestStepCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunTestStepCreateExecute(r ApiEnvironmentsBatchExportsRunTestStepCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunTestStepCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/run_test_step/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunTestStepCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsRunTestStepCreate_0Request) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsRunTestStepCreate_0Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsRunTestStepCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunTestStepCreate_19Execute(r)
}

/*
EnvironmentsBatchExportsRunTestStepCreate_0 Method for EnvironmentsBatchExportsRunTestStepCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunTestStepCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunTestStepCreate_19(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsRunTestStepCreate_0Request {
	return ApiEnvironmentsBatchExportsRunTestStepCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunTestStepCreate_19Execute(r ApiEnvironmentsBatchExportsRunTestStepCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunTestStepCreate_19")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/run_test_step/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunTestStepNewCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsRunTestStepNewCreateRequest) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsRunTestStepNewCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsRunTestStepNewCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunTestStepNewCreateExecute(r)
}

/*
EnvironmentsBatchExportsRunTestStepNewCreate Method for EnvironmentsBatchExportsRunTestStepNewCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunTestStepNewCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunTestStepNewCreate(ctx context.Context, projectId string) ApiEnvironmentsBatchExportsRunTestStepNewCreateRequest {
	return ApiEnvironmentsBatchExportsRunTestStepNewCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunTestStepNewCreateExecute(r ApiEnvironmentsBatchExportsRunTestStepNewCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunTestStepNewCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/run_test_step_new/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunTestStepNewCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsRunTestStepNewCreate_0Request) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsRunTestStepNewCreate_0Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsRunTestStepNewCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunTestStepNewCreate_20Execute(r)
}

/*
EnvironmentsBatchExportsRunTestStepNewCreate_0 Method for EnvironmentsBatchExportsRunTestStepNewCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunTestStepNewCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunTestStepNewCreate_20(ctx context.Context, projectId string) ApiEnvironmentsBatchExportsRunTestStepNewCreate_0Request {
	return ApiEnvironmentsBatchExportsRunTestStepNewCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunTestStepNewCreate_20Execute(r ApiEnvironmentsBatchExportsRunTestStepNewCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunTestStepNewCreate_20")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/run_test_step_new/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsCancelCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
	batchExportRun *BatchExportRun
}

func (r ApiEnvironmentsBatchExportsRunsCancelCreateRequest) BatchExportRun(batchExportRun BatchExportRun) ApiEnvironmentsBatchExportsRunsCancelCreateRequest {
	r.batchExportRun = &batchExportRun
	return r
}

func (r ApiEnvironmentsBatchExportsRunsCancelCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsCancelCreateExecute(r)
}

/*
EnvironmentsBatchExportsRunsCancelCreate Method for EnvironmentsBatchExportsRunsCancelCreate

Cancel a batch export run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsCancelCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsCancelCreate(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsRunsCancelCreateRequest {
	return ApiEnvironmentsBatchExportsRunsCancelCreateRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsCancelCreateExecute(r ApiEnvironmentsBatchExportsRunsCancelCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsCancelCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportRun == nil {
		return nil, reportError("batchExportRun is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportRun
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsCancelCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
	batchExportRun *BatchExportRun
}

func (r ApiEnvironmentsBatchExportsRunsCancelCreate_0Request) BatchExportRun(batchExportRun BatchExportRun) ApiEnvironmentsBatchExportsRunsCancelCreate_0Request {
	r.batchExportRun = &batchExportRun
	return r
}

func (r ApiEnvironmentsBatchExportsRunsCancelCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsCancelCreate_21Execute(r)
}

/*
EnvironmentsBatchExportsRunsCancelCreate_0 Method for EnvironmentsBatchExportsRunsCancelCreate_0

Cancel a batch export run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsCancelCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsCancelCreate_21(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsRunsCancelCreate_0Request {
	return ApiEnvironmentsBatchExportsRunsCancelCreate_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsCancelCreate_21Execute(r ApiEnvironmentsBatchExportsRunsCancelCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsCancelCreate_21")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportRun == nil {
		return nil, reportError("batchExportRun is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportRun
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	projectId string
	cursor *string
	ordering *string
}

// The pagination cursor value.
func (r ApiEnvironmentsBatchExportsRunsListRequest) Cursor(cursor string) ApiEnvironmentsBatchExportsRunsListRequest {
	r.cursor = &cursor
	return r
}

// Which field to use when ordering the results.
func (r ApiEnvironmentsBatchExportsRunsListRequest) Ordering(ordering string) ApiEnvironmentsBatchExportsRunsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiEnvironmentsBatchExportsRunsListRequest) Execute() (*PaginatedBatchExportRunList, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsListExecute(r)
}

/*
EnvironmentsBatchExportsRunsList Method for EnvironmentsBatchExportsRunsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsList(ctx context.Context, batchExportId string, projectId string) ApiEnvironmentsBatchExportsRunsListRequest {
	return ApiEnvironmentsBatchExportsRunsListRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportRunList
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsListExecute(r ApiEnvironmentsBatchExportsRunsListRequest) (*PaginatedBatchExportRunList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportRunList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	projectId string
	cursor *string
	ordering *string
}

// The pagination cursor value.
func (r ApiEnvironmentsBatchExportsRunsList_0Request) Cursor(cursor string) ApiEnvironmentsBatchExportsRunsList_0Request {
	r.cursor = &cursor
	return r
}

// Which field to use when ordering the results.
func (r ApiEnvironmentsBatchExportsRunsList_0Request) Ordering(ordering string) ApiEnvironmentsBatchExportsRunsList_0Request {
	r.ordering = &ordering
	return r
}

func (r ApiEnvironmentsBatchExportsRunsList_0Request) Execute() (*PaginatedBatchExportRunList, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsList_22Execute(r)
}

/*
EnvironmentsBatchExportsRunsList_0 Method for EnvironmentsBatchExportsRunsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsList_22(ctx context.Context, batchExportId string, projectId string) ApiEnvironmentsBatchExportsRunsList_0Request {
	return ApiEnvironmentsBatchExportsRunsList_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportRunList
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsList_22Execute(r ApiEnvironmentsBatchExportsRunsList_0Request) (*PaginatedBatchExportRunList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportRunList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsList_22")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsLogsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsRunsLogsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsLogsRetrieveExecute(r)
}

/*
EnvironmentsBatchExportsRunsLogsRetrieve Method for EnvironmentsBatchExportsRunsLogsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsLogsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsLogsRetrieve(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsRunsLogsRetrieveRequest {
	return ApiEnvironmentsBatchExportsRunsLogsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsLogsRetrieveExecute(r ApiEnvironmentsBatchExportsRunsLogsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsLogsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsLogsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsRunsLogsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsLogsRetrieve_23Execute(r)
}

/*
EnvironmentsBatchExportsRunsLogsRetrieve_0 Method for EnvironmentsBatchExportsRunsLogsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsLogsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsLogsRetrieve_23(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsRunsLogsRetrieve_0Request {
	return ApiEnvironmentsBatchExportsRunsLogsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsLogsRetrieve_23Execute(r ApiEnvironmentsBatchExportsRunsLogsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsLogsRetrieve_23")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsRunsRetrieveRequest) Execute() (*BatchExportRun, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsRetrieveExecute(r)
}

/*
EnvironmentsBatchExportsRunsRetrieve Method for EnvironmentsBatchExportsRunsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsRetrieve(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsRunsRetrieveRequest {
	return ApiEnvironmentsBatchExportsRunsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportRun
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsRetrieveExecute(r ApiEnvironmentsBatchExportsRunsRetrieveRequest) (*BatchExportRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiEnvironmentsBatchExportsRunsRetrieve_0Request) Execute() (*BatchExportRun, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsRetrieve_24Execute(r)
}

/*
EnvironmentsBatchExportsRunsRetrieve_0 Method for EnvironmentsBatchExportsRunsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsRetrieve_24(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsRunsRetrieve_0Request {
	return ApiEnvironmentsBatchExportsRunsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportRun
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsRetrieve_24Execute(r ApiEnvironmentsBatchExportsRunsRetrieve_0Request) (*BatchExportRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsRetrieve_24")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsRetryCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
	batchExportRun *BatchExportRun
}

func (r ApiEnvironmentsBatchExportsRunsRetryCreateRequest) BatchExportRun(batchExportRun BatchExportRun) ApiEnvironmentsBatchExportsRunsRetryCreateRequest {
	r.batchExportRun = &batchExportRun
	return r
}

func (r ApiEnvironmentsBatchExportsRunsRetryCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsRetryCreateExecute(r)
}

/*
EnvironmentsBatchExportsRunsRetryCreate Method for EnvironmentsBatchExportsRunsRetryCreate

Retry a batch export run.

We use the same underlying mechanism as when backfilling a batch export, as retrying
a run is the same as backfilling one run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsRetryCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsRetryCreate(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsRunsRetryCreateRequest {
	return ApiEnvironmentsBatchExportsRunsRetryCreateRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsRetryCreateExecute(r ApiEnvironmentsBatchExportsRunsRetryCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsRetryCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/{id}/retry/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportRun == nil {
		return nil, reportError("batchExportRun is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportRun
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsRunsRetryCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	batchExportId string
	id string
	projectId string
	batchExportRun *BatchExportRun
}

func (r ApiEnvironmentsBatchExportsRunsRetryCreate_0Request) BatchExportRun(batchExportRun BatchExportRun) ApiEnvironmentsBatchExportsRunsRetryCreate_0Request {
	r.batchExportRun = &batchExportRun
	return r
}

func (r ApiEnvironmentsBatchExportsRunsRetryCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsRunsRetryCreate_25Execute(r)
}

/*
EnvironmentsBatchExportsRunsRetryCreate_0 Method for EnvironmentsBatchExportsRunsRetryCreate_0

Retry a batch export run.

We use the same underlying mechanism as when backfilling a batch export, as retrying
a run is the same as backfilling one run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsRunsRetryCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsRetryCreate_25(ctx context.Context, batchExportId string, id string, projectId string) ApiEnvironmentsBatchExportsRunsRetryCreate_0Request {
	return ApiEnvironmentsBatchExportsRunsRetryCreate_0Request{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsRunsRetryCreate_25Execute(r ApiEnvironmentsBatchExportsRunsRetryCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsRunsRetryCreate_25")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{batch_export_id}/runs/{id}/retry/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportRun == nil {
		return nil, reportError("batchExportRun is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportRun
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsTestRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsBatchExportsTestRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsTestRetrieveExecute(r)
}

/*
EnvironmentsBatchExportsTestRetrieve Method for EnvironmentsBatchExportsTestRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsTestRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsTestRetrieve(ctx context.Context, projectId string) ApiEnvironmentsBatchExportsTestRetrieveRequest {
	return ApiEnvironmentsBatchExportsTestRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsTestRetrieveExecute(r ApiEnvironmentsBatchExportsTestRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsTestRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/test/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsTestRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsBatchExportsTestRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsTestRetrieve_26Execute(r)
}

/*
EnvironmentsBatchExportsTestRetrieve_0 Method for EnvironmentsBatchExportsTestRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsTestRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsTestRetrieve_26(ctx context.Context, projectId string) ApiEnvironmentsBatchExportsTestRetrieve_0Request {
	return ApiEnvironmentsBatchExportsTestRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsTestRetrieve_26Execute(r ApiEnvironmentsBatchExportsTestRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsTestRetrieve_26")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/test/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsUnpauseCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsUnpauseCreateRequest) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsUnpauseCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsUnpauseCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsUnpauseCreateExecute(r)
}

/*
EnvironmentsBatchExportsUnpauseCreate Method for EnvironmentsBatchExportsUnpauseCreate

Unpause a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsUnpauseCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsUnpauseCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsUnpauseCreateRequest {
	return ApiEnvironmentsBatchExportsUnpauseCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsUnpauseCreateExecute(r ApiEnvironmentsBatchExportsUnpauseCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsUnpauseCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/unpause/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsUnpauseCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsUnpauseCreate_0Request) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsUnpauseCreate_0Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsUnpauseCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsUnpauseCreate_27Execute(r)
}

/*
EnvironmentsBatchExportsUnpauseCreate_0 Method for EnvironmentsBatchExportsUnpauseCreate_0

Unpause a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsUnpauseCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsUnpauseCreate_27(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsUnpauseCreate_0Request {
	return ApiEnvironmentsBatchExportsUnpauseCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsUnpauseCreate_27Execute(r ApiEnvironmentsBatchExportsUnpauseCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsUnpauseCreate_27")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/unpause/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsUpdateRequest) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsUpdateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsUpdateRequest) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsUpdateExecute(r)
}

/*
EnvironmentsBatchExportsUpdate Method for EnvironmentsBatchExportsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsUpdateRequest {
	return ApiEnvironmentsBatchExportsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsUpdateExecute(r ApiEnvironmentsBatchExportsUpdateRequest) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return localVarReturnValue, nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsBatchExportsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiEnvironmentsBatchExportsUpdate_0Request) BatchExport(batchExport BatchExport) ApiEnvironmentsBatchExportsUpdate_0Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiEnvironmentsBatchExportsUpdate_0Request) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.EnvironmentsBatchExportsUpdate_28Execute(r)
}

/*
EnvironmentsBatchExportsUpdate_0 Method for EnvironmentsBatchExportsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsBatchExportsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsUpdate_28(ctx context.Context, id string, projectId string) ApiEnvironmentsBatchExportsUpdate_0Request {
	return ApiEnvironmentsBatchExportsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *EnvironmentsAPIService) EnvironmentsBatchExportsUpdate_28Execute(r ApiEnvironmentsBatchExportsUpdate_0Request) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsBatchExportsUpdate_28")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return localVarReturnValue, nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsCompleteProductOnboardingPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedTeam *PatchedTeam
}

func (r ApiEnvironmentsCompleteProductOnboardingPartialUpdateRequest) PatchedTeam(patchedTeam PatchedTeam) ApiEnvironmentsCompleteProductOnboardingPartialUpdateRequest {
	r.patchedTeam = &patchedTeam
	return r
}

func (r ApiEnvironmentsCompleteProductOnboardingPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsCompleteProductOnboardingPartialUpdateExecute(r)
}

/*
EnvironmentsCompleteProductOnboardingPartialUpdate Method for EnvironmentsCompleteProductOnboardingPartialUpdate

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsCompleteProductOnboardingPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsCompleteProductOnboardingPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsCompleteProductOnboardingPartialUpdateRequest {
	return ApiEnvironmentsCompleteProductOnboardingPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsCompleteProductOnboardingPartialUpdateExecute(r ApiEnvironmentsCompleteProductOnboardingPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsCompleteProductOnboardingPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/complete_product_onboarding/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTeam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	team *Team
}

func (r ApiEnvironmentsCreateRequest) Team(team Team) ApiEnvironmentsCreateRequest {
	r.team = &team
	return r
}

func (r ApiEnvironmentsCreateRequest) Execute() (*Team, *http.Response, error) {
	return r.ApiService.EnvironmentsCreateExecute(r)
}

/*
EnvironmentsCreate Method for EnvironmentsCreate

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsCreate(ctx context.Context, projectId string) ApiEnvironmentsCreateRequest {
	return ApiEnvironmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Team
func (a *EnvironmentsAPIService) EnvironmentsCreateExecute(r ApiEnvironmentsCreateRequest) (*Team, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Team
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.team
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCollaboratorsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
	dashboardCollaborator *DashboardCollaborator
}

func (r ApiEnvironmentsDashboardsCollaboratorsCreateRequest) DashboardCollaborator(dashboardCollaborator DashboardCollaborator) ApiEnvironmentsDashboardsCollaboratorsCreateRequest {
	r.dashboardCollaborator = &dashboardCollaborator
	return r
}

func (r ApiEnvironmentsDashboardsCollaboratorsCreateRequest) Execute() (*DashboardCollaborator, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCollaboratorsCreateExecute(r)
}

/*
EnvironmentsDashboardsCollaboratorsCreate Method for EnvironmentsDashboardsCollaboratorsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCollaboratorsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsCreate(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsCollaboratorsCreateRequest {
	return ApiEnvironmentsDashboardsCollaboratorsCreateRequest{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DashboardCollaborator
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsCreateExecute(r ApiEnvironmentsDashboardsCollaboratorsCreateRequest) (*DashboardCollaborator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DashboardCollaborator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCollaboratorsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/collaborators/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dashboardCollaborator == nil {
		return localVarReturnValue, nil, reportError("dashboardCollaborator is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboardCollaborator
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCollaboratorsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
	dashboardCollaborator *DashboardCollaborator
}

func (r ApiEnvironmentsDashboardsCollaboratorsCreate_0Request) DashboardCollaborator(dashboardCollaborator DashboardCollaborator) ApiEnvironmentsDashboardsCollaboratorsCreate_0Request {
	r.dashboardCollaborator = &dashboardCollaborator
	return r
}

func (r ApiEnvironmentsDashboardsCollaboratorsCreate_0Request) Execute() (*DashboardCollaborator, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCollaboratorsCreate_29Execute(r)
}

/*
EnvironmentsDashboardsCollaboratorsCreate_0 Method for EnvironmentsDashboardsCollaboratorsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCollaboratorsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsCreate_29(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsCollaboratorsCreate_0Request {
	return ApiEnvironmentsDashboardsCollaboratorsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DashboardCollaborator
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsCreate_29Execute(r ApiEnvironmentsDashboardsCollaboratorsCreate_0Request) (*DashboardCollaborator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DashboardCollaborator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCollaboratorsCreate_29")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/collaborators/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dashboardCollaborator == nil {
		return localVarReturnValue, nil, reportError("dashboardCollaborator is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboardCollaborator
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCollaboratorsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
	userUuid string
}

func (r ApiEnvironmentsDashboardsCollaboratorsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCollaboratorsDestroyExecute(r)
}

/*
EnvironmentsDashboardsCollaboratorsDestroy Method for EnvironmentsDashboardsCollaboratorsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param userUuid
 @return ApiEnvironmentsDashboardsCollaboratorsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsDestroy(ctx context.Context, dashboardId int32, projectId string, userUuid string) ApiEnvironmentsDashboardsCollaboratorsDestroyRequest {
	return ApiEnvironmentsDashboardsCollaboratorsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
		userUuid: userUuid,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsDestroyExecute(r ApiEnvironmentsDashboardsCollaboratorsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCollaboratorsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/collaborators/{user__uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user__uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCollaboratorsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
	userUuid string
}

func (r ApiEnvironmentsDashboardsCollaboratorsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCollaboratorsDestroy_30Execute(r)
}

/*
EnvironmentsDashboardsCollaboratorsDestroy_0 Method for EnvironmentsDashboardsCollaboratorsDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param userUuid
 @return ApiEnvironmentsDashboardsCollaboratorsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsDestroy_30(ctx context.Context, dashboardId int32, projectId string, userUuid string) ApiEnvironmentsDashboardsCollaboratorsDestroy_0Request {
	return ApiEnvironmentsDashboardsCollaboratorsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
		userUuid: userUuid,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsDestroy_30Execute(r ApiEnvironmentsDashboardsCollaboratorsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCollaboratorsDestroy_30")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/collaborators/{user__uuid}/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"user__uuid"+"}", url.PathEscape(parameterValueToString(r.userUuid, "userUuid")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCollaboratorsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
}

func (r ApiEnvironmentsDashboardsCollaboratorsListRequest) Execute() ([]DashboardCollaborator, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCollaboratorsListExecute(r)
}

/*
EnvironmentsDashboardsCollaboratorsList Method for EnvironmentsDashboardsCollaboratorsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCollaboratorsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsList(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsCollaboratorsListRequest {
	return ApiEnvironmentsDashboardsCollaboratorsListRequest{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []DashboardCollaborator
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsListExecute(r ApiEnvironmentsDashboardsCollaboratorsListRequest) ([]DashboardCollaborator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DashboardCollaborator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCollaboratorsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/collaborators/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCollaboratorsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
}

func (r ApiEnvironmentsDashboardsCollaboratorsList_0Request) Execute() ([]DashboardCollaborator, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCollaboratorsList_31Execute(r)
}

/*
EnvironmentsDashboardsCollaboratorsList_0 Method for EnvironmentsDashboardsCollaboratorsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCollaboratorsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsList_31(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsCollaboratorsList_0Request {
	return ApiEnvironmentsDashboardsCollaboratorsList_0Request{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []DashboardCollaborator
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCollaboratorsList_31Execute(r ApiEnvironmentsDashboardsCollaboratorsList_0Request) ([]DashboardCollaborator, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []DashboardCollaborator
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCollaboratorsList_31")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/collaborators/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	dashboard *Dashboard
}

func (r ApiEnvironmentsDashboardsCreateRequest) Format(format string) ApiEnvironmentsDashboardsCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsCreateRequest) Dashboard(dashboard Dashboard) ApiEnvironmentsDashboardsCreateRequest {
	r.dashboard = &dashboard
	return r
}

func (r ApiEnvironmentsDashboardsCreateRequest) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCreateExecute(r)
}

/*
EnvironmentsDashboardsCreate Method for EnvironmentsDashboardsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreate(ctx context.Context, projectId string) ApiEnvironmentsDashboardsCreateRequest {
	return ApiEnvironmentsDashboardsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dashboard
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateExecute(r ApiEnvironmentsDashboardsCreateRequest) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	dashboard *Dashboard
}

func (r ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest) Format(format string) ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest) Dashboard(dashboard Dashboard) ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest {
	r.dashboard = &dashboard
	return r
}

func (r ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCreateFromTemplateJsonCreateExecute(r)
}

/*
EnvironmentsDashboardsCreateFromTemplateJsonCreate Method for EnvironmentsDashboardsCreateFromTemplateJsonCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateFromTemplateJsonCreate(ctx context.Context, projectId string) ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest {
	return ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateFromTemplateJsonCreateExecute(r ApiEnvironmentsDashboardsCreateFromTemplateJsonCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCreateFromTemplateJsonCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/create_from_template_json/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	dashboard *Dashboard
}

func (r ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request) Format(format string) ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request) Dashboard(dashboard Dashboard) ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request {
	r.dashboard = &dashboard
	return r
}

func (r ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCreateFromTemplateJsonCreate_32Execute(r)
}

/*
EnvironmentsDashboardsCreateFromTemplateJsonCreate_0 Method for EnvironmentsDashboardsCreateFromTemplateJsonCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateFromTemplateJsonCreate_32(ctx context.Context, projectId string) ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request {
	return ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateFromTemplateJsonCreate_32Execute(r ApiEnvironmentsDashboardsCreateFromTemplateJsonCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCreateFromTemplateJsonCreate_32")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/create_from_template_json/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	dashboard *Dashboard
}

func (r ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest) Format(format string) ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest) Dashboard(dashboard Dashboard) ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest {
	r.dashboard = &dashboard
	return r
}

func (r ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCreateUnlistedDashboardCreateExecute(r)
}

/*
EnvironmentsDashboardsCreateUnlistedDashboardCreate Method for EnvironmentsDashboardsCreateUnlistedDashboardCreate

Creates an unlisted dashboard from template by tag.
Enforces uniqueness (one per tag per team).
Returns 409 if unlisted dashboard with this tag already exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateUnlistedDashboardCreate(ctx context.Context, projectId string) ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest {
	return ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateUnlistedDashboardCreateExecute(r ApiEnvironmentsDashboardsCreateUnlistedDashboardCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCreateUnlistedDashboardCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/create_unlisted_dashboard/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	dashboard *Dashboard
}

func (r ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request) Format(format string) ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request) Dashboard(dashboard Dashboard) ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request {
	r.dashboard = &dashboard
	return r
}

func (r ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCreateUnlistedDashboardCreate_33Execute(r)
}

/*
EnvironmentsDashboardsCreateUnlistedDashboardCreate_0 Method for EnvironmentsDashboardsCreateUnlistedDashboardCreate_0

Creates an unlisted dashboard from template by tag.
Enforces uniqueness (one per tag per team).
Returns 409 if unlisted dashboard with this tag already exists.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateUnlistedDashboardCreate_33(ctx context.Context, projectId string) ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request {
	return ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreateUnlistedDashboardCreate_33Execute(r ApiEnvironmentsDashboardsCreateUnlistedDashboardCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCreateUnlistedDashboardCreate_33")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/create_unlisted_dashboard/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	dashboard *Dashboard
}

func (r ApiEnvironmentsDashboardsCreate_0Request) Format(format string) ApiEnvironmentsDashboardsCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsCreate_0Request) Dashboard(dashboard Dashboard) ApiEnvironmentsDashboardsCreate_0Request {
	r.dashboard = &dashboard
	return r
}

func (r ApiEnvironmentsDashboardsCreate_0Request) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsCreate_34Execute(r)
}

/*
EnvironmentsDashboardsCreate_0 Method for EnvironmentsDashboardsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreate_34(ctx context.Context, projectId string) ApiEnvironmentsDashboardsCreate_0Request {
	return ApiEnvironmentsDashboardsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dashboard
func (a *EnvironmentsAPIService) EnvironmentsDashboardsCreate_34Execute(r ApiEnvironmentsDashboardsCreate_0Request) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsCreate_34")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsDashboardsDestroyRequest) Format(format string) ApiEnvironmentsDashboardsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsDestroyExecute(r)
}

/*
EnvironmentsDashboardsDestroy Method for EnvironmentsDashboardsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsDestroy(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsDestroyRequest {
	return ApiEnvironmentsDashboardsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsDestroyExecute(r ApiEnvironmentsDashboardsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsDashboardsDestroy_0Request) Format(format string) ApiEnvironmentsDashboardsDestroy_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsDestroy_35Execute(r)
}

/*
EnvironmentsDashboardsDestroy_0 Method for EnvironmentsDashboardsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsDestroy_35(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsDestroy_0Request {
	return ApiEnvironmentsDashboardsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsDestroy_35Execute(r ApiEnvironmentsDashboardsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsDestroy_35")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	limit *int32
	offset *int32
}

func (r ApiEnvironmentsDashboardsListRequest) Format(format string) ApiEnvironmentsDashboardsListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsDashboardsListRequest) Limit(limit int32) ApiEnvironmentsDashboardsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDashboardsListRequest) Offset(offset int32) ApiEnvironmentsDashboardsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsDashboardsListRequest) Execute() (*PaginatedDashboardBasicList, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsListExecute(r)
}

/*
EnvironmentsDashboardsList Method for EnvironmentsDashboardsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsList(ctx context.Context, projectId string) ApiEnvironmentsDashboardsListRequest {
	return ApiEnvironmentsDashboardsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDashboardBasicList
func (a *EnvironmentsAPIService) EnvironmentsDashboardsListExecute(r ApiEnvironmentsDashboardsListRequest) (*PaginatedDashboardBasicList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDashboardBasicList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	limit *int32
	offset *int32
}

func (r ApiEnvironmentsDashboardsList_0Request) Format(format string) ApiEnvironmentsDashboardsList_0Request {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsDashboardsList_0Request) Limit(limit int32) ApiEnvironmentsDashboardsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDashboardsList_0Request) Offset(offset int32) ApiEnvironmentsDashboardsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsDashboardsList_0Request) Execute() (*PaginatedDashboardBasicList, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsList_36Execute(r)
}

/*
EnvironmentsDashboardsList_0 Method for EnvironmentsDashboardsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsList_36(ctx context.Context, projectId string) ApiEnvironmentsDashboardsList_0Request {
	return ApiEnvironmentsDashboardsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDashboardBasicList
func (a *EnvironmentsAPIService) EnvironmentsDashboardsList_36Execute(r ApiEnvironmentsDashboardsList_0Request) (*PaginatedDashboardBasicList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDashboardBasicList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsList_36")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	patchedDashboard *PatchedDashboard
}

func (r ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest) Format(format string) ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest) PatchedDashboard(patchedDashboard PatchedDashboard) ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest {
	r.patchedDashboard = &patchedDashboard
	return r
}

func (r ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsMoveTilePartialUpdateExecute(r)
}

/*
EnvironmentsDashboardsMoveTilePartialUpdate Method for EnvironmentsDashboardsMoveTilePartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsMoveTilePartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest {
	return ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsMoveTilePartialUpdateExecute(r ApiEnvironmentsDashboardsMoveTilePartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsMoveTilePartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/move_tile/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	patchedDashboard *PatchedDashboard
}

func (r ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request) Format(format string) ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request) PatchedDashboard(patchedDashboard PatchedDashboard) ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request {
	r.patchedDashboard = &patchedDashboard
	return r
}

func (r ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsMoveTilePartialUpdate_37Execute(r)
}

/*
EnvironmentsDashboardsMoveTilePartialUpdate_0 Method for EnvironmentsDashboardsMoveTilePartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsMoveTilePartialUpdate_37(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request {
	return ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsMoveTilePartialUpdate_37Execute(r ApiEnvironmentsDashboardsMoveTilePartialUpdate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsMoveTilePartialUpdate_37")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/move_tile/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	patchedDashboard *PatchedDashboard
}

func (r ApiEnvironmentsDashboardsPartialUpdateRequest) Format(format string) ApiEnvironmentsDashboardsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsPartialUpdateRequest) PatchedDashboard(patchedDashboard PatchedDashboard) ApiEnvironmentsDashboardsPartialUpdateRequest {
	r.patchedDashboard = &patchedDashboard
	return r
}

func (r ApiEnvironmentsDashboardsPartialUpdateRequest) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsPartialUpdateExecute(r)
}

/*
EnvironmentsDashboardsPartialUpdate Method for EnvironmentsDashboardsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsPartialUpdateRequest {
	return ApiEnvironmentsDashboardsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dashboard
func (a *EnvironmentsAPIService) EnvironmentsDashboardsPartialUpdateExecute(r ApiEnvironmentsDashboardsPartialUpdateRequest) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	patchedDashboard *PatchedDashboard
}

func (r ApiEnvironmentsDashboardsPartialUpdate_0Request) Format(format string) ApiEnvironmentsDashboardsPartialUpdate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsPartialUpdate_0Request) PatchedDashboard(patchedDashboard PatchedDashboard) ApiEnvironmentsDashboardsPartialUpdate_0Request {
	r.patchedDashboard = &patchedDashboard
	return r
}

func (r ApiEnvironmentsDashboardsPartialUpdate_0Request) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsPartialUpdate_38Execute(r)
}

/*
EnvironmentsDashboardsPartialUpdate_0 Method for EnvironmentsDashboardsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsPartialUpdate_38(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsPartialUpdate_0Request {
	return ApiEnvironmentsDashboardsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dashboard
func (a *EnvironmentsAPIService) EnvironmentsDashboardsPartialUpdate_38Execute(r ApiEnvironmentsDashboardsPartialUpdate_0Request) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsPartialUpdate_38")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsDashboardsRetrieveRequest) Format(format string) ApiEnvironmentsDashboardsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsRetrieveRequest) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsRetrieveExecute(r)
}

/*
EnvironmentsDashboardsRetrieve Method for EnvironmentsDashboardsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsRetrieveRequest {
	return ApiEnvironmentsDashboardsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dashboard
func (a *EnvironmentsAPIService) EnvironmentsDashboardsRetrieveExecute(r ApiEnvironmentsDashboardsRetrieveRequest) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsDashboardsRetrieve_0Request) Format(format string) ApiEnvironmentsDashboardsRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsRetrieve_0Request) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsRetrieve_39Execute(r)
}

/*
EnvironmentsDashboardsRetrieve_0 Method for EnvironmentsDashboardsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsRetrieve_39(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsRetrieve_0Request {
	return ApiEnvironmentsDashboardsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dashboard
func (a *EnvironmentsAPIService) EnvironmentsDashboardsRetrieve_39Execute(r ApiEnvironmentsDashboardsRetrieve_0Request) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsRetrieve_39")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsSharingListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
}

func (r ApiEnvironmentsDashboardsSharingListRequest) Execute() ([]SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsSharingListExecute(r)
}

/*
EnvironmentsDashboardsSharingList Method for EnvironmentsDashboardsSharingList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsSharingListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingList(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsSharingListRequest {
	return ApiEnvironmentsDashboardsSharingListRequest{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingListExecute(r ApiEnvironmentsDashboardsSharingListRequest) ([]SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsSharingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/sharing/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsSharingList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
}

func (r ApiEnvironmentsDashboardsSharingList_0Request) Execute() ([]SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsSharingList_40Execute(r)
}

/*
EnvironmentsDashboardsSharingList_0 Method for EnvironmentsDashboardsSharingList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsSharingList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingList_40(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsSharingList_0Request {
	return ApiEnvironmentsDashboardsSharingList_0Request{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingList_40Execute(r ApiEnvironmentsDashboardsSharingList_0Request) ([]SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsSharingList_40")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/sharing/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsSharingPasswordsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsDashboardsSharingPasswordsCreateRequest) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsDashboardsSharingPasswordsCreateRequest {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsDashboardsSharingPasswordsCreateRequest) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsSharingPasswordsCreateExecute(r)
}

/*
EnvironmentsDashboardsSharingPasswordsCreate Method for EnvironmentsDashboardsSharingPasswordsCreate

Create a new password for the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsSharingPasswordsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingPasswordsCreate(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsSharingPasswordsCreateRequest {
	return ApiEnvironmentsDashboardsSharingPasswordsCreateRequest{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingPasswordsCreateExecute(r ApiEnvironmentsDashboardsSharingPasswordsCreateRequest) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsSharingPasswordsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/sharing/passwords/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsSharingPasswordsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsDashboardsSharingPasswordsCreate_0Request) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsDashboardsSharingPasswordsCreate_0Request {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsDashboardsSharingPasswordsCreate_0Request) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsSharingPasswordsCreate_41Execute(r)
}

/*
EnvironmentsDashboardsSharingPasswordsCreate_0 Method for EnvironmentsDashboardsSharingPasswordsCreate_0

Create a new password for the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsSharingPasswordsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingPasswordsCreate_41(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsSharingPasswordsCreate_0Request {
	return ApiEnvironmentsDashboardsSharingPasswordsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingPasswordsCreate_41Execute(r ApiEnvironmentsDashboardsSharingPasswordsCreate_0Request) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsSharingPasswordsCreate_41")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/sharing/passwords/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsSharingPasswordsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	passwordId string
	projectId string
}

func (r ApiEnvironmentsDashboardsSharingPasswordsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsSharingPasswordsDestroyExecute(r)
}

/*
EnvironmentsDashboardsSharingPasswordsDestroy Method for EnvironmentsDashboardsSharingPasswordsDestroy

Delete a password from the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param passwordId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsSharingPasswordsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingPasswordsDestroy(ctx context.Context, dashboardId int32, passwordId string, projectId string) ApiEnvironmentsDashboardsSharingPasswordsDestroyRequest {
	return ApiEnvironmentsDashboardsSharingPasswordsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		passwordId: passwordId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingPasswordsDestroyExecute(r ApiEnvironmentsDashboardsSharingPasswordsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsSharingPasswordsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/sharing/passwords/{password_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"password_id"+"}", url.PathEscape(parameterValueToString(r.passwordId, "passwordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsSharingPasswordsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	passwordId string
	projectId string
}

func (r ApiEnvironmentsDashboardsSharingPasswordsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsSharingPasswordsDestroy_42Execute(r)
}

/*
EnvironmentsDashboardsSharingPasswordsDestroy_0 Method for EnvironmentsDashboardsSharingPasswordsDestroy_0

Delete a password from the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param passwordId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsSharingPasswordsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingPasswordsDestroy_42(ctx context.Context, dashboardId int32, passwordId string, projectId string) ApiEnvironmentsDashboardsSharingPasswordsDestroy_0Request {
	return ApiEnvironmentsDashboardsSharingPasswordsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		passwordId: passwordId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingPasswordsDestroy_42Execute(r ApiEnvironmentsDashboardsSharingPasswordsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsSharingPasswordsDestroy_42")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/sharing/passwords/{password_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"password_id"+"}", url.PathEscape(parameterValueToString(r.passwordId, "passwordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsSharingRefreshCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsDashboardsSharingRefreshCreateRequest) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsDashboardsSharingRefreshCreateRequest {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsDashboardsSharingRefreshCreateRequest) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsSharingRefreshCreateExecute(r)
}

/*
EnvironmentsDashboardsSharingRefreshCreate Method for EnvironmentsDashboardsSharingRefreshCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsSharingRefreshCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingRefreshCreate(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsSharingRefreshCreateRequest {
	return ApiEnvironmentsDashboardsSharingRefreshCreateRequest{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingRefreshCreateExecute(r ApiEnvironmentsDashboardsSharingRefreshCreateRequest) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsSharingRefreshCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/sharing/refresh/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsSharingRefreshCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	dashboardId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsDashboardsSharingRefreshCreate_0Request) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsDashboardsSharingRefreshCreate_0Request {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsDashboardsSharingRefreshCreate_0Request) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsSharingRefreshCreate_43Execute(r)
}

/*
EnvironmentsDashboardsSharingRefreshCreate_0 Method for EnvironmentsDashboardsSharingRefreshCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param dashboardId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsSharingRefreshCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingRefreshCreate_43(ctx context.Context, dashboardId int32, projectId string) ApiEnvironmentsDashboardsSharingRefreshCreate_0Request {
	return ApiEnvironmentsDashboardsSharingRefreshCreate_0Request{
		ApiService: a,
		ctx: ctx,
		dashboardId: dashboardId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsDashboardsSharingRefreshCreate_43Execute(r ApiEnvironmentsDashboardsSharingRefreshCreate_0Request) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsSharingRefreshCreate_43")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{dashboard_id}/sharing/refresh/"
	localVarPath = strings.Replace(localVarPath, "{"+"dashboard_id"+"}", url.PathEscape(parameterValueToString(r.dashboardId, "dashboardId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsStreamTilesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsDashboardsStreamTilesRetrieveRequest) Format(format string) ApiEnvironmentsDashboardsStreamTilesRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsStreamTilesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsStreamTilesRetrieveExecute(r)
}

/*
EnvironmentsDashboardsStreamTilesRetrieve Method for EnvironmentsDashboardsStreamTilesRetrieve

Stream dashboard metadata and tiles via Server-Sent Events. Sends metadata first, then tiles as they are rendered.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsStreamTilesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsStreamTilesRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsStreamTilesRetrieveRequest {
	return ApiEnvironmentsDashboardsStreamTilesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsStreamTilesRetrieveExecute(r ApiEnvironmentsDashboardsStreamTilesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsStreamTilesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/stream_tiles/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsStreamTilesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsDashboardsStreamTilesRetrieve_0Request) Format(format string) ApiEnvironmentsDashboardsStreamTilesRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsStreamTilesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsStreamTilesRetrieve_44Execute(r)
}

/*
EnvironmentsDashboardsStreamTilesRetrieve_0 Method for EnvironmentsDashboardsStreamTilesRetrieve_0

Stream dashboard metadata and tiles via Server-Sent Events. Sends metadata first, then tiles as they are rendered.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsStreamTilesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsStreamTilesRetrieve_44(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsStreamTilesRetrieve_0Request {
	return ApiEnvironmentsDashboardsStreamTilesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDashboardsStreamTilesRetrieve_44Execute(r ApiEnvironmentsDashboardsStreamTilesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsStreamTilesRetrieve_44")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/stream_tiles/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	dashboard *Dashboard
}

func (r ApiEnvironmentsDashboardsUpdateRequest) Format(format string) ApiEnvironmentsDashboardsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsUpdateRequest) Dashboard(dashboard Dashboard) ApiEnvironmentsDashboardsUpdateRequest {
	r.dashboard = &dashboard
	return r
}

func (r ApiEnvironmentsDashboardsUpdateRequest) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsUpdateExecute(r)
}

/*
EnvironmentsDashboardsUpdate Method for EnvironmentsDashboardsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsUpdateRequest {
	return ApiEnvironmentsDashboardsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dashboard
func (a *EnvironmentsAPIService) EnvironmentsDashboardsUpdateExecute(r ApiEnvironmentsDashboardsUpdateRequest) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDashboardsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	dashboard *Dashboard
}

func (r ApiEnvironmentsDashboardsUpdate_0Request) Format(format string) ApiEnvironmentsDashboardsUpdate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsDashboardsUpdate_0Request) Dashboard(dashboard Dashboard) ApiEnvironmentsDashboardsUpdate_0Request {
	r.dashboard = &dashboard
	return r
}

func (r ApiEnvironmentsDashboardsUpdate_0Request) Execute() (*Dashboard, *http.Response, error) {
	return r.ApiService.EnvironmentsDashboardsUpdate_45Execute(r)
}

/*
EnvironmentsDashboardsUpdate_0 Method for EnvironmentsDashboardsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this dashboard.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDashboardsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDashboardsUpdate_45(ctx context.Context, id int32, projectId string) ApiEnvironmentsDashboardsUpdate_0Request {
	return ApiEnvironmentsDashboardsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dashboard
func (a *EnvironmentsAPIService) EnvironmentsDashboardsUpdate_45Execute(r ApiEnvironmentsDashboardsUpdate_0Request) (*Dashboard, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dashboard
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDashboardsUpdate_45")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dashboards/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/event-stream"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dashboard
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	dataColorTheme *DataColorTheme
}

func (r ApiEnvironmentsDataColorThemesCreateRequest) DataColorTheme(dataColorTheme DataColorTheme) ApiEnvironmentsDataColorThemesCreateRequest {
	r.dataColorTheme = &dataColorTheme
	return r
}

func (r ApiEnvironmentsDataColorThemesCreateRequest) Execute() (*DataColorTheme, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesCreateExecute(r)
}

/*
EnvironmentsDataColorThemesCreate Method for EnvironmentsDataColorThemesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesCreate(ctx context.Context, projectId string) ApiEnvironmentsDataColorThemesCreateRequest {
	return ApiEnvironmentsDataColorThemesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataColorTheme
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesCreateExecute(r ApiEnvironmentsDataColorThemesCreateRequest) (*DataColorTheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataColorTheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataColorTheme == nil {
		return localVarReturnValue, nil, reportError("dataColorTheme is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataColorTheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	dataColorTheme *DataColorTheme
}

func (r ApiEnvironmentsDataColorThemesCreate_0Request) DataColorTheme(dataColorTheme DataColorTheme) ApiEnvironmentsDataColorThemesCreate_0Request {
	r.dataColorTheme = &dataColorTheme
	return r
}

func (r ApiEnvironmentsDataColorThemesCreate_0Request) Execute() (*DataColorTheme, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesCreate_46Execute(r)
}

/*
EnvironmentsDataColorThemesCreate_0 Method for EnvironmentsDataColorThemesCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesCreate_46(ctx context.Context, projectId string) ApiEnvironmentsDataColorThemesCreate_0Request {
	return ApiEnvironmentsDataColorThemesCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataColorTheme
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesCreate_46Execute(r ApiEnvironmentsDataColorThemesCreate_0Request) (*DataColorTheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataColorTheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesCreate_46")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataColorTheme == nil {
		return localVarReturnValue, nil, reportError("dataColorTheme is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataColorTheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsDataColorThemesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesDestroyExecute(r)
}

/*
EnvironmentsDataColorThemesDestroy Method for EnvironmentsDataColorThemesDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this data color theme.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesDestroy(ctx context.Context, id int32, projectId string) ApiEnvironmentsDataColorThemesDestroyRequest {
	return ApiEnvironmentsDataColorThemesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesDestroyExecute(r ApiEnvironmentsDataColorThemesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsDataColorThemesDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesDestroy_47Execute(r)
}

/*
EnvironmentsDataColorThemesDestroy_0 Method for EnvironmentsDataColorThemesDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this data color theme.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesDestroy_47(ctx context.Context, id int32, projectId string) ApiEnvironmentsDataColorThemesDestroy_0Request {
	return ApiEnvironmentsDataColorThemesDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesDestroy_47Execute(r ApiEnvironmentsDataColorThemesDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesDestroy_47")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsDataColorThemesListRequest) Limit(limit int32) ApiEnvironmentsDataColorThemesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDataColorThemesListRequest) Offset(offset int32) ApiEnvironmentsDataColorThemesListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsDataColorThemesListRequest) Execute() (*PaginatedDataColorThemeList, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesListExecute(r)
}

/*
EnvironmentsDataColorThemesList Method for EnvironmentsDataColorThemesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesList(ctx context.Context, projectId string) ApiEnvironmentsDataColorThemesListRequest {
	return ApiEnvironmentsDataColorThemesListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDataColorThemeList
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesListExecute(r ApiEnvironmentsDataColorThemesListRequest) (*PaginatedDataColorThemeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDataColorThemeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsDataColorThemesList_0Request) Limit(limit int32) ApiEnvironmentsDataColorThemesList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDataColorThemesList_0Request) Offset(offset int32) ApiEnvironmentsDataColorThemesList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsDataColorThemesList_0Request) Execute() (*PaginatedDataColorThemeList, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesList_48Execute(r)
}

/*
EnvironmentsDataColorThemesList_0 Method for EnvironmentsDataColorThemesList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesList_48(ctx context.Context, projectId string) ApiEnvironmentsDataColorThemesList_0Request {
	return ApiEnvironmentsDataColorThemesList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDataColorThemeList
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesList_48Execute(r ApiEnvironmentsDataColorThemesList_0Request) (*PaginatedDataColorThemeList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDataColorThemeList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesList_48")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedDataColorTheme *PatchedDataColorTheme
}

func (r ApiEnvironmentsDataColorThemesPartialUpdateRequest) PatchedDataColorTheme(patchedDataColorTheme PatchedDataColorTheme) ApiEnvironmentsDataColorThemesPartialUpdateRequest {
	r.patchedDataColorTheme = &patchedDataColorTheme
	return r
}

func (r ApiEnvironmentsDataColorThemesPartialUpdateRequest) Execute() (*DataColorTheme, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesPartialUpdateExecute(r)
}

/*
EnvironmentsDataColorThemesPartialUpdate Method for EnvironmentsDataColorThemesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this data color theme.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsDataColorThemesPartialUpdateRequest {
	return ApiEnvironmentsDataColorThemesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataColorTheme
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesPartialUpdateExecute(r ApiEnvironmentsDataColorThemesPartialUpdateRequest) (*DataColorTheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataColorTheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDataColorTheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedDataColorTheme *PatchedDataColorTheme
}

func (r ApiEnvironmentsDataColorThemesPartialUpdate_0Request) PatchedDataColorTheme(patchedDataColorTheme PatchedDataColorTheme) ApiEnvironmentsDataColorThemesPartialUpdate_0Request {
	r.patchedDataColorTheme = &patchedDataColorTheme
	return r
}

func (r ApiEnvironmentsDataColorThemesPartialUpdate_0Request) Execute() (*DataColorTheme, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesPartialUpdate_49Execute(r)
}

/*
EnvironmentsDataColorThemesPartialUpdate_0 Method for EnvironmentsDataColorThemesPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this data color theme.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesPartialUpdate_49(ctx context.Context, id int32, projectId string) ApiEnvironmentsDataColorThemesPartialUpdate_0Request {
	return ApiEnvironmentsDataColorThemesPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataColorTheme
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesPartialUpdate_49Execute(r ApiEnvironmentsDataColorThemesPartialUpdate_0Request) (*DataColorTheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataColorTheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesPartialUpdate_49")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDataColorTheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsDataColorThemesRetrieveRequest) Execute() (*DataColorTheme, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesRetrieveExecute(r)
}

/*
EnvironmentsDataColorThemesRetrieve Method for EnvironmentsDataColorThemesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this data color theme.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsDataColorThemesRetrieveRequest {
	return ApiEnvironmentsDataColorThemesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataColorTheme
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesRetrieveExecute(r ApiEnvironmentsDataColorThemesRetrieveRequest) (*DataColorTheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataColorTheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsDataColorThemesRetrieve_0Request) Execute() (*DataColorTheme, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesRetrieve_50Execute(r)
}

/*
EnvironmentsDataColorThemesRetrieve_0 Method for EnvironmentsDataColorThemesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this data color theme.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesRetrieve_50(ctx context.Context, id int32, projectId string) ApiEnvironmentsDataColorThemesRetrieve_0Request {
	return ApiEnvironmentsDataColorThemesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataColorTheme
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesRetrieve_50Execute(r ApiEnvironmentsDataColorThemesRetrieve_0Request) (*DataColorTheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataColorTheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesRetrieve_50")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	dataColorTheme *DataColorTheme
}

func (r ApiEnvironmentsDataColorThemesUpdateRequest) DataColorTheme(dataColorTheme DataColorTheme) ApiEnvironmentsDataColorThemesUpdateRequest {
	r.dataColorTheme = &dataColorTheme
	return r
}

func (r ApiEnvironmentsDataColorThemesUpdateRequest) Execute() (*DataColorTheme, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesUpdateExecute(r)
}

/*
EnvironmentsDataColorThemesUpdate Method for EnvironmentsDataColorThemesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this data color theme.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsDataColorThemesUpdateRequest {
	return ApiEnvironmentsDataColorThemesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataColorTheme
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesUpdateExecute(r ApiEnvironmentsDataColorThemesUpdateRequest) (*DataColorTheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataColorTheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataColorTheme == nil {
		return localVarReturnValue, nil, reportError("dataColorTheme is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataColorTheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDataColorThemesUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	dataColorTheme *DataColorTheme
}

func (r ApiEnvironmentsDataColorThemesUpdate_0Request) DataColorTheme(dataColorTheme DataColorTheme) ApiEnvironmentsDataColorThemesUpdate_0Request {
	r.dataColorTheme = &dataColorTheme
	return r
}

func (r ApiEnvironmentsDataColorThemesUpdate_0Request) Execute() (*DataColorTheme, *http.Response, error) {
	return r.ApiService.EnvironmentsDataColorThemesUpdate_51Execute(r)
}

/*
EnvironmentsDataColorThemesUpdate_0 Method for EnvironmentsDataColorThemesUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this data color theme.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDataColorThemesUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesUpdate_51(ctx context.Context, id int32, projectId string) ApiEnvironmentsDataColorThemesUpdate_0Request {
	return ApiEnvironmentsDataColorThemesUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataColorTheme
func (a *EnvironmentsAPIService) EnvironmentsDataColorThemesUpdate_51Execute(r ApiEnvironmentsDataColorThemesUpdate_0Request) (*DataColorTheme, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataColorTheme
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDataColorThemesUpdate_51")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/data_color_themes/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataColorTheme == nil {
		return localVarReturnValue, nil, reportError("dataColorTheme is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataColorTheme
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	datasetItem *DatasetItem
}

func (r ApiEnvironmentsDatasetItemsCreateRequest) DatasetItem(datasetItem DatasetItem) ApiEnvironmentsDatasetItemsCreateRequest {
	r.datasetItem = &datasetItem
	return r
}

func (r ApiEnvironmentsDatasetItemsCreateRequest) Execute() (*DatasetItem, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsCreateExecute(r)
}

/*
EnvironmentsDatasetItemsCreate Method for EnvironmentsDatasetItemsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsCreate(ctx context.Context, projectId string) ApiEnvironmentsDatasetItemsCreateRequest {
	return ApiEnvironmentsDatasetItemsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DatasetItem
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsCreateExecute(r ApiEnvironmentsDatasetItemsCreateRequest) (*DatasetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.datasetItem == nil {
		return localVarReturnValue, nil, reportError("datasetItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.datasetItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	datasetItem *DatasetItem
}

func (r ApiEnvironmentsDatasetItemsCreate_0Request) DatasetItem(datasetItem DatasetItem) ApiEnvironmentsDatasetItemsCreate_0Request {
	r.datasetItem = &datasetItem
	return r
}

func (r ApiEnvironmentsDatasetItemsCreate_0Request) Execute() (*DatasetItem, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsCreate_52Execute(r)
}

/*
EnvironmentsDatasetItemsCreate_0 Method for EnvironmentsDatasetItemsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsCreate_52(ctx context.Context, projectId string) ApiEnvironmentsDatasetItemsCreate_0Request {
	return ApiEnvironmentsDatasetItemsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DatasetItem
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsCreate_52Execute(r ApiEnvironmentsDatasetItemsCreate_0Request) (*DatasetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsCreate_52")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.datasetItem == nil {
		return localVarReturnValue, nil, reportError("datasetItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.datasetItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDatasetItemsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsDestroyExecute(r)
}

/*
EnvironmentsDatasetItemsDestroy Method for EnvironmentsDatasetItemsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset item.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetItemsDestroyRequest {
	return ApiEnvironmentsDatasetItemsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsDestroyExecute(r ApiEnvironmentsDatasetItemsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDatasetItemsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsDestroy_53Execute(r)
}

/*
EnvironmentsDatasetItemsDestroy_0 Method for EnvironmentsDatasetItemsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset item.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsDestroy_53(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetItemsDestroy_0Request {
	return ApiEnvironmentsDatasetItemsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsDestroy_53Execute(r ApiEnvironmentsDatasetItemsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsDestroy_53")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	dataset *string
	limit *int32
	offset *int32
}

// Filter by dataset ID
func (r ApiEnvironmentsDatasetItemsListRequest) Dataset(dataset string) ApiEnvironmentsDatasetItemsListRequest {
	r.dataset = &dataset
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsDatasetItemsListRequest) Limit(limit int32) ApiEnvironmentsDatasetItemsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDatasetItemsListRequest) Offset(offset int32) ApiEnvironmentsDatasetItemsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsDatasetItemsListRequest) Execute() (*PaginatedDatasetItemList, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsListExecute(r)
}

/*
EnvironmentsDatasetItemsList Method for EnvironmentsDatasetItemsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsList(ctx context.Context, projectId string) ApiEnvironmentsDatasetItemsListRequest {
	return ApiEnvironmentsDatasetItemsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDatasetItemList
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsListExecute(r ApiEnvironmentsDatasetItemsListRequest) (*PaginatedDatasetItemList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDatasetItemList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dataset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataset", r.dataset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	dataset *string
	limit *int32
	offset *int32
}

// Filter by dataset ID
func (r ApiEnvironmentsDatasetItemsList_0Request) Dataset(dataset string) ApiEnvironmentsDatasetItemsList_0Request {
	r.dataset = &dataset
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsDatasetItemsList_0Request) Limit(limit int32) ApiEnvironmentsDatasetItemsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDatasetItemsList_0Request) Offset(offset int32) ApiEnvironmentsDatasetItemsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsDatasetItemsList_0Request) Execute() (*PaginatedDatasetItemList, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsList_54Execute(r)
}

/*
EnvironmentsDatasetItemsList_0 Method for EnvironmentsDatasetItemsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsList_54(ctx context.Context, projectId string) ApiEnvironmentsDatasetItemsList_0Request {
	return ApiEnvironmentsDatasetItemsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDatasetItemList
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsList_54Execute(r ApiEnvironmentsDatasetItemsList_0Request) (*PaginatedDatasetItemList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDatasetItemList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsList_54")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.dataset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "dataset", r.dataset, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedDatasetItem *PatchedDatasetItem
}

func (r ApiEnvironmentsDatasetItemsPartialUpdateRequest) PatchedDatasetItem(patchedDatasetItem PatchedDatasetItem) ApiEnvironmentsDatasetItemsPartialUpdateRequest {
	r.patchedDatasetItem = &patchedDatasetItem
	return r
}

func (r ApiEnvironmentsDatasetItemsPartialUpdateRequest) Execute() (*DatasetItem, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsPartialUpdateExecute(r)
}

/*
EnvironmentsDatasetItemsPartialUpdate Method for EnvironmentsDatasetItemsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset item.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetItemsPartialUpdateRequest {
	return ApiEnvironmentsDatasetItemsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DatasetItem
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsPartialUpdateExecute(r ApiEnvironmentsDatasetItemsPartialUpdateRequest) (*DatasetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDatasetItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedDatasetItem *PatchedDatasetItem
}

func (r ApiEnvironmentsDatasetItemsPartialUpdate_0Request) PatchedDatasetItem(patchedDatasetItem PatchedDatasetItem) ApiEnvironmentsDatasetItemsPartialUpdate_0Request {
	r.patchedDatasetItem = &patchedDatasetItem
	return r
}

func (r ApiEnvironmentsDatasetItemsPartialUpdate_0Request) Execute() (*DatasetItem, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsPartialUpdate_55Execute(r)
}

/*
EnvironmentsDatasetItemsPartialUpdate_0 Method for EnvironmentsDatasetItemsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset item.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsPartialUpdate_55(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetItemsPartialUpdate_0Request {
	return ApiEnvironmentsDatasetItemsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DatasetItem
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsPartialUpdate_55Execute(r ApiEnvironmentsDatasetItemsPartialUpdate_0Request) (*DatasetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsPartialUpdate_55")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDatasetItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDatasetItemsRetrieveRequest) Execute() (*DatasetItem, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsRetrieveExecute(r)
}

/*
EnvironmentsDatasetItemsRetrieve Method for EnvironmentsDatasetItemsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset item.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetItemsRetrieveRequest {
	return ApiEnvironmentsDatasetItemsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DatasetItem
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsRetrieveExecute(r ApiEnvironmentsDatasetItemsRetrieveRequest) (*DatasetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDatasetItemsRetrieve_0Request) Execute() (*DatasetItem, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsRetrieve_56Execute(r)
}

/*
EnvironmentsDatasetItemsRetrieve_0 Method for EnvironmentsDatasetItemsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset item.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsRetrieve_56(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetItemsRetrieve_0Request {
	return ApiEnvironmentsDatasetItemsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DatasetItem
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsRetrieve_56Execute(r ApiEnvironmentsDatasetItemsRetrieve_0Request) (*DatasetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsRetrieve_56")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	datasetItem *DatasetItem
}

func (r ApiEnvironmentsDatasetItemsUpdateRequest) DatasetItem(datasetItem DatasetItem) ApiEnvironmentsDatasetItemsUpdateRequest {
	r.datasetItem = &datasetItem
	return r
}

func (r ApiEnvironmentsDatasetItemsUpdateRequest) Execute() (*DatasetItem, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsUpdateExecute(r)
}

/*
EnvironmentsDatasetItemsUpdate Method for EnvironmentsDatasetItemsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset item.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetItemsUpdateRequest {
	return ApiEnvironmentsDatasetItemsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DatasetItem
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsUpdateExecute(r ApiEnvironmentsDatasetItemsUpdateRequest) (*DatasetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.datasetItem == nil {
		return localVarReturnValue, nil, reportError("datasetItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.datasetItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetItemsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	datasetItem *DatasetItem
}

func (r ApiEnvironmentsDatasetItemsUpdate_0Request) DatasetItem(datasetItem DatasetItem) ApiEnvironmentsDatasetItemsUpdate_0Request {
	r.datasetItem = &datasetItem
	return r
}

func (r ApiEnvironmentsDatasetItemsUpdate_0Request) Execute() (*DatasetItem, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetItemsUpdate_57Execute(r)
}

/*
EnvironmentsDatasetItemsUpdate_0 Method for EnvironmentsDatasetItemsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset item.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetItemsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsUpdate_57(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetItemsUpdate_0Request {
	return ApiEnvironmentsDatasetItemsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DatasetItem
func (a *EnvironmentsAPIService) EnvironmentsDatasetItemsUpdate_57Execute(r ApiEnvironmentsDatasetItemsUpdate_0Request) (*DatasetItem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DatasetItem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetItemsUpdate_57")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/dataset_items/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.datasetItem == nil {
		return localVarReturnValue, nil, reportError("datasetItem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.datasetItem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	dataset *Dataset
}

func (r ApiEnvironmentsDatasetsCreateRequest) Dataset(dataset Dataset) ApiEnvironmentsDatasetsCreateRequest {
	r.dataset = &dataset
	return r
}

func (r ApiEnvironmentsDatasetsCreateRequest) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsCreateExecute(r)
}

/*
EnvironmentsDatasetsCreate Method for EnvironmentsDatasetsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsCreate(ctx context.Context, projectId string) ApiEnvironmentsDatasetsCreateRequest {
	return ApiEnvironmentsDatasetsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dataset
func (a *EnvironmentsAPIService) EnvironmentsDatasetsCreateExecute(r ApiEnvironmentsDatasetsCreateRequest) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataset == nil {
		return localVarReturnValue, nil, reportError("dataset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	dataset *Dataset
}

func (r ApiEnvironmentsDatasetsCreate_0Request) Dataset(dataset Dataset) ApiEnvironmentsDatasetsCreate_0Request {
	r.dataset = &dataset
	return r
}

func (r ApiEnvironmentsDatasetsCreate_0Request) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsCreate_58Execute(r)
}

/*
EnvironmentsDatasetsCreate_0 Method for EnvironmentsDatasetsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsCreate_58(ctx context.Context, projectId string) ApiEnvironmentsDatasetsCreate_0Request {
	return ApiEnvironmentsDatasetsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dataset
func (a *EnvironmentsAPIService) EnvironmentsDatasetsCreate_58Execute(r ApiEnvironmentsDatasetsCreate_0Request) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsCreate_58")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataset == nil {
		return localVarReturnValue, nil, reportError("dataset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDatasetsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsDestroyExecute(r)
}

/*
EnvironmentsDatasetsDestroy Method for EnvironmentsDatasetsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetsDestroyRequest {
	return ApiEnvironmentsDatasetsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDatasetsDestroyExecute(r ApiEnvironmentsDatasetsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDatasetsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsDestroy_59Execute(r)
}

/*
EnvironmentsDatasetsDestroy_0 Method for EnvironmentsDatasetsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsDestroy_59(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetsDestroy_0Request {
	return ApiEnvironmentsDatasetsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDatasetsDestroy_59Execute(r ApiEnvironmentsDatasetsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsDestroy_59")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	idIn *[]string
	limit *int32
	offset *int32
	orderBy *[]string
	search *string
}

// Multiple values may be separated by commas.
func (r ApiEnvironmentsDatasetsListRequest) IdIn(idIn []string) ApiEnvironmentsDatasetsListRequest {
	r.idIn = &idIn
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsDatasetsListRequest) Limit(limit int32) ApiEnvironmentsDatasetsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDatasetsListRequest) Offset(offset int32) ApiEnvironmentsDatasetsListRequest {
	r.offset = &offset
	return r
}

// Ordering  * &#x60;created_at&#x60; - Created At * &#x60;-created_at&#x60; - Created At (descending) * &#x60;updated_at&#x60; - Updated At * &#x60;-updated_at&#x60; - Updated At (descending)
func (r ApiEnvironmentsDatasetsListRequest) OrderBy(orderBy []string) ApiEnvironmentsDatasetsListRequest {
	r.orderBy = &orderBy
	return r
}

// Search in name, description, or metadata
func (r ApiEnvironmentsDatasetsListRequest) Search(search string) ApiEnvironmentsDatasetsListRequest {
	r.search = &search
	return r
}

func (r ApiEnvironmentsDatasetsListRequest) Execute() (*PaginatedDatasetList, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsListExecute(r)
}

/*
EnvironmentsDatasetsList Method for EnvironmentsDatasetsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsList(ctx context.Context, projectId string) ApiEnvironmentsDatasetsListRequest {
	return ApiEnvironmentsDatasetsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDatasetList
func (a *EnvironmentsAPIService) EnvironmentsDatasetsListExecute(r ApiEnvironmentsDatasetsListRequest) (*PaginatedDatasetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDatasetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__in", r.idIn, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "csv")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	idIn *[]string
	limit *int32
	offset *int32
	orderBy *[]string
	search *string
}

// Multiple values may be separated by commas.
func (r ApiEnvironmentsDatasetsList_0Request) IdIn(idIn []string) ApiEnvironmentsDatasetsList_0Request {
	r.idIn = &idIn
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsDatasetsList_0Request) Limit(limit int32) ApiEnvironmentsDatasetsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDatasetsList_0Request) Offset(offset int32) ApiEnvironmentsDatasetsList_0Request {
	r.offset = &offset
	return r
}

// Ordering  * &#x60;created_at&#x60; - Created At * &#x60;-created_at&#x60; - Created At (descending) * &#x60;updated_at&#x60; - Updated At * &#x60;-updated_at&#x60; - Updated At (descending)
func (r ApiEnvironmentsDatasetsList_0Request) OrderBy(orderBy []string) ApiEnvironmentsDatasetsList_0Request {
	r.orderBy = &orderBy
	return r
}

// Search in name, description, or metadata
func (r ApiEnvironmentsDatasetsList_0Request) Search(search string) ApiEnvironmentsDatasetsList_0Request {
	r.search = &search
	return r
}

func (r ApiEnvironmentsDatasetsList_0Request) Execute() (*PaginatedDatasetList, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsList_60Execute(r)
}

/*
EnvironmentsDatasetsList_0 Method for EnvironmentsDatasetsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsList_60(ctx context.Context, projectId string) ApiEnvironmentsDatasetsList_0Request {
	return ApiEnvironmentsDatasetsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDatasetList
func (a *EnvironmentsAPIService) EnvironmentsDatasetsList_60Execute(r ApiEnvironmentsDatasetsList_0Request) (*PaginatedDatasetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDatasetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsList_60")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.idIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__in", r.idIn, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "csv")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedDataset *PatchedDataset
}

func (r ApiEnvironmentsDatasetsPartialUpdateRequest) PatchedDataset(patchedDataset PatchedDataset) ApiEnvironmentsDatasetsPartialUpdateRequest {
	r.patchedDataset = &patchedDataset
	return r
}

func (r ApiEnvironmentsDatasetsPartialUpdateRequest) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsPartialUpdateExecute(r)
}

/*
EnvironmentsDatasetsPartialUpdate Method for EnvironmentsDatasetsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetsPartialUpdateRequest {
	return ApiEnvironmentsDatasetsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dataset
func (a *EnvironmentsAPIService) EnvironmentsDatasetsPartialUpdateExecute(r ApiEnvironmentsDatasetsPartialUpdateRequest) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDataset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedDataset *PatchedDataset
}

func (r ApiEnvironmentsDatasetsPartialUpdate_0Request) PatchedDataset(patchedDataset PatchedDataset) ApiEnvironmentsDatasetsPartialUpdate_0Request {
	r.patchedDataset = &patchedDataset
	return r
}

func (r ApiEnvironmentsDatasetsPartialUpdate_0Request) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsPartialUpdate_61Execute(r)
}

/*
EnvironmentsDatasetsPartialUpdate_0 Method for EnvironmentsDatasetsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsPartialUpdate_61(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetsPartialUpdate_0Request {
	return ApiEnvironmentsDatasetsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dataset
func (a *EnvironmentsAPIService) EnvironmentsDatasetsPartialUpdate_61Execute(r ApiEnvironmentsDatasetsPartialUpdate_0Request) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsPartialUpdate_61")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDataset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDatasetsRetrieveRequest) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsRetrieveExecute(r)
}

/*
EnvironmentsDatasetsRetrieve Method for EnvironmentsDatasetsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetsRetrieveRequest {
	return ApiEnvironmentsDatasetsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dataset
func (a *EnvironmentsAPIService) EnvironmentsDatasetsRetrieveExecute(r ApiEnvironmentsDatasetsRetrieveRequest) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDatasetsRetrieve_0Request) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsRetrieve_62Execute(r)
}

/*
EnvironmentsDatasetsRetrieve_0 Method for EnvironmentsDatasetsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsRetrieve_62(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetsRetrieve_0Request {
	return ApiEnvironmentsDatasetsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dataset
func (a *EnvironmentsAPIService) EnvironmentsDatasetsRetrieve_62Execute(r ApiEnvironmentsDatasetsRetrieve_0Request) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsRetrieve_62")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataset *Dataset
}

func (r ApiEnvironmentsDatasetsUpdateRequest) Dataset(dataset Dataset) ApiEnvironmentsDatasetsUpdateRequest {
	r.dataset = &dataset
	return r
}

func (r ApiEnvironmentsDatasetsUpdateRequest) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsUpdateExecute(r)
}

/*
EnvironmentsDatasetsUpdate Method for EnvironmentsDatasetsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetsUpdateRequest {
	return ApiEnvironmentsDatasetsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dataset
func (a *EnvironmentsAPIService) EnvironmentsDatasetsUpdateExecute(r ApiEnvironmentsDatasetsUpdateRequest) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataset == nil {
		return localVarReturnValue, nil, reportError("dataset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDatasetsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataset *Dataset
}

func (r ApiEnvironmentsDatasetsUpdate_0Request) Dataset(dataset Dataset) ApiEnvironmentsDatasetsUpdate_0Request {
	r.dataset = &dataset
	return r
}

func (r ApiEnvironmentsDatasetsUpdate_0Request) Execute() (*Dataset, *http.Response, error) {
	return r.ApiService.EnvironmentsDatasetsUpdate_63Execute(r)
}

/*
EnvironmentsDatasetsUpdate_0 Method for EnvironmentsDatasetsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this dataset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDatasetsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsDatasetsUpdate_63(ctx context.Context, id string, projectId string) ApiEnvironmentsDatasetsUpdate_0Request {
	return ApiEnvironmentsDatasetsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Dataset
func (a *EnvironmentsAPIService) EnvironmentsDatasetsUpdate_63Execute(r ApiEnvironmentsDatasetsUpdate_0Request) (*Dataset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Dataset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDatasetsUpdate_63")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/datasets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataset == nil {
		return localVarReturnValue, nil, reportError("dataset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDefaultEvaluationTagsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	team *Team
}

func (r ApiEnvironmentsDefaultEvaluationTagsCreateRequest) Team(team Team) ApiEnvironmentsDefaultEvaluationTagsCreateRequest {
	r.team = &team
	return r
}

func (r ApiEnvironmentsDefaultEvaluationTagsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDefaultEvaluationTagsCreateExecute(r)
}

/*
EnvironmentsDefaultEvaluationTagsCreate Method for EnvironmentsDefaultEvaluationTagsCreate

Manage default evaluation tags for a team

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDefaultEvaluationTagsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDefaultEvaluationTagsCreate(ctx context.Context, id int32, projectId string) ApiEnvironmentsDefaultEvaluationTagsCreateRequest {
	return ApiEnvironmentsDefaultEvaluationTagsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDefaultEvaluationTagsCreateExecute(r ApiEnvironmentsDefaultEvaluationTagsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDefaultEvaluationTagsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/default_evaluation_tags/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.team
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDefaultEvaluationTagsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsDefaultEvaluationTagsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDefaultEvaluationTagsDestroyExecute(r)
}

/*
EnvironmentsDefaultEvaluationTagsDestroy Method for EnvironmentsDefaultEvaluationTagsDestroy

Manage default evaluation tags for a team

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDefaultEvaluationTagsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDefaultEvaluationTagsDestroy(ctx context.Context, id int32, projectId string) ApiEnvironmentsDefaultEvaluationTagsDestroyRequest {
	return ApiEnvironmentsDefaultEvaluationTagsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDefaultEvaluationTagsDestroyExecute(r ApiEnvironmentsDefaultEvaluationTagsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDefaultEvaluationTagsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/default_evaluation_tags/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDefaultEvaluationTagsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsDefaultEvaluationTagsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDefaultEvaluationTagsRetrieveExecute(r)
}

/*
EnvironmentsDefaultEvaluationTagsRetrieve Method for EnvironmentsDefaultEvaluationTagsRetrieve

Manage default evaluation tags for a team

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDefaultEvaluationTagsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDefaultEvaluationTagsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsDefaultEvaluationTagsRetrieveRequest {
	return ApiEnvironmentsDefaultEvaluationTagsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDefaultEvaluationTagsRetrieveExecute(r ApiEnvironmentsDefaultEvaluationTagsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDefaultEvaluationTagsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/default_evaluation_tags/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDeleteSecretTokenBackupPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedTeam *PatchedTeam
}

func (r ApiEnvironmentsDeleteSecretTokenBackupPartialUpdateRequest) PatchedTeam(patchedTeam PatchedTeam) ApiEnvironmentsDeleteSecretTokenBackupPartialUpdateRequest {
	r.patchedTeam = &patchedTeam
	return r
}

func (r ApiEnvironmentsDeleteSecretTokenBackupPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDeleteSecretTokenBackupPartialUpdateExecute(r)
}

/*
EnvironmentsDeleteSecretTokenBackupPartialUpdate Method for EnvironmentsDeleteSecretTokenBackupPartialUpdate

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDeleteSecretTokenBackupPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDeleteSecretTokenBackupPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsDeleteSecretTokenBackupPartialUpdateRequest {
	return ApiEnvironmentsDeleteSecretTokenBackupPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDeleteSecretTokenBackupPartialUpdateExecute(r ApiEnvironmentsDeleteSecretTokenBackupPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDeleteSecretTokenBackupPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/delete_secret_token_backup/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTeam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDesktopRecordingsAppendSegmentsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	appendSegments *AppendSegments
}

func (r ApiEnvironmentsDesktopRecordingsAppendSegmentsCreateRequest) AppendSegments(appendSegments AppendSegments) ApiEnvironmentsDesktopRecordingsAppendSegmentsCreateRequest {
	r.appendSegments = &appendSegments
	return r
}

func (r ApiEnvironmentsDesktopRecordingsAppendSegmentsCreateRequest) Execute() (*DesktopRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsDesktopRecordingsAppendSegmentsCreateExecute(r)
}

/*
EnvironmentsDesktopRecordingsAppendSegmentsCreate Method for EnvironmentsDesktopRecordingsAppendSegmentsCreate

Append transcript segments (supports batched real-time streaming)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this desktop recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDesktopRecordingsAppendSegmentsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsAppendSegmentsCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsDesktopRecordingsAppendSegmentsCreateRequest {
	return ApiEnvironmentsDesktopRecordingsAppendSegmentsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DesktopRecording
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsAppendSegmentsCreateExecute(r ApiEnvironmentsDesktopRecordingsAppendSegmentsCreateRequest) (*DesktopRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DesktopRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDesktopRecordingsAppendSegmentsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/desktop_recordings/{id}/append_segments/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.appendSegments == nil {
		return localVarReturnValue, nil, reportError("appendSegments is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.appendSegments
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDesktopRecordingsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	createRecordingRequest *CreateRecordingRequest
}

func (r ApiEnvironmentsDesktopRecordingsCreateRequest) CreateRecordingRequest(createRecordingRequest CreateRecordingRequest) ApiEnvironmentsDesktopRecordingsCreateRequest {
	r.createRecordingRequest = &createRecordingRequest
	return r
}

func (r ApiEnvironmentsDesktopRecordingsCreateRequest) Execute() (*CreateRecordingResponse, *http.Response, error) {
	return r.ApiService.EnvironmentsDesktopRecordingsCreateExecute(r)
}

/*
EnvironmentsDesktopRecordingsCreate Method for EnvironmentsDesktopRecordingsCreate

Create a new recording and get Recall.ai upload token for the desktop SDK

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDesktopRecordingsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsCreate(ctx context.Context, projectId string) ApiEnvironmentsDesktopRecordingsCreateRequest {
	return ApiEnvironmentsDesktopRecordingsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return CreateRecordingResponse
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsCreateExecute(r ApiEnvironmentsDesktopRecordingsCreateRequest) (*CreateRecordingResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CreateRecordingResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDesktopRecordingsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/desktop_recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createRecordingRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDesktopRecordingsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDesktopRecordingsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDesktopRecordingsDestroyExecute(r)
}

/*
EnvironmentsDesktopRecordingsDestroy Method for EnvironmentsDesktopRecordingsDestroy

RESTful API for managing desktop meeting recordings.

Standard CRUD operations plus transcript management as a subresource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this desktop recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDesktopRecordingsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsDesktopRecordingsDestroyRequest {
	return ApiEnvironmentsDesktopRecordingsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsDestroyExecute(r ApiEnvironmentsDesktopRecordingsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDesktopRecordingsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/desktop_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsDesktopRecordingsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsDesktopRecordingsListRequest) Limit(limit int32) ApiEnvironmentsDesktopRecordingsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsDesktopRecordingsListRequest) Offset(offset int32) ApiEnvironmentsDesktopRecordingsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsDesktopRecordingsListRequest) Execute() (*PaginatedDesktopRecordingList, *http.Response, error) {
	return r.ApiService.EnvironmentsDesktopRecordingsListExecute(r)
}

/*
EnvironmentsDesktopRecordingsList Method for EnvironmentsDesktopRecordingsList

RESTful API for managing desktop meeting recordings.

Standard CRUD operations plus transcript management as a subresource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDesktopRecordingsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsList(ctx context.Context, projectId string) ApiEnvironmentsDesktopRecordingsListRequest {
	return ApiEnvironmentsDesktopRecordingsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDesktopRecordingList
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsListExecute(r ApiEnvironmentsDesktopRecordingsListRequest) (*PaginatedDesktopRecordingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDesktopRecordingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDesktopRecordingsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/desktop_recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDesktopRecordingsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedDesktopRecording *PatchedDesktopRecording
}

func (r ApiEnvironmentsDesktopRecordingsPartialUpdateRequest) PatchedDesktopRecording(patchedDesktopRecording PatchedDesktopRecording) ApiEnvironmentsDesktopRecordingsPartialUpdateRequest {
	r.patchedDesktopRecording = &patchedDesktopRecording
	return r
}

func (r ApiEnvironmentsDesktopRecordingsPartialUpdateRequest) Execute() (*DesktopRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsDesktopRecordingsPartialUpdateExecute(r)
}

/*
EnvironmentsDesktopRecordingsPartialUpdate Method for EnvironmentsDesktopRecordingsPartialUpdate

RESTful API for managing desktop meeting recordings.

Standard CRUD operations plus transcript management as a subresource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this desktop recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDesktopRecordingsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsDesktopRecordingsPartialUpdateRequest {
	return ApiEnvironmentsDesktopRecordingsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DesktopRecording
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsPartialUpdateExecute(r ApiEnvironmentsDesktopRecordingsPartialUpdateRequest) (*DesktopRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DesktopRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDesktopRecordingsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/desktop_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDesktopRecording
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDesktopRecordingsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsDesktopRecordingsRetrieveRequest) Execute() (*DesktopRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsDesktopRecordingsRetrieveExecute(r)
}

/*
EnvironmentsDesktopRecordingsRetrieve Method for EnvironmentsDesktopRecordingsRetrieve

RESTful API for managing desktop meeting recordings.

Standard CRUD operations plus transcript management as a subresource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this desktop recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDesktopRecordingsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsDesktopRecordingsRetrieveRequest {
	return ApiEnvironmentsDesktopRecordingsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DesktopRecording
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsRetrieveExecute(r ApiEnvironmentsDesktopRecordingsRetrieveRequest) (*DesktopRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DesktopRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDesktopRecordingsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/desktop_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDesktopRecordingsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	desktopRecording *DesktopRecording
}

func (r ApiEnvironmentsDesktopRecordingsUpdateRequest) DesktopRecording(desktopRecording DesktopRecording) ApiEnvironmentsDesktopRecordingsUpdateRequest {
	r.desktopRecording = &desktopRecording
	return r
}

func (r ApiEnvironmentsDesktopRecordingsUpdateRequest) Execute() (*DesktopRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsDesktopRecordingsUpdateExecute(r)
}

/*
EnvironmentsDesktopRecordingsUpdate Method for EnvironmentsDesktopRecordingsUpdate

RESTful API for managing desktop meeting recordings.

Standard CRUD operations plus transcript management as a subresource.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this desktop recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDesktopRecordingsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsDesktopRecordingsUpdateRequest {
	return ApiEnvironmentsDesktopRecordingsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DesktopRecording
func (a *EnvironmentsAPIService) EnvironmentsDesktopRecordingsUpdateExecute(r ApiEnvironmentsDesktopRecordingsUpdateRequest) (*DesktopRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DesktopRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDesktopRecordingsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/desktop_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.desktopRecording == nil {
		return localVarReturnValue, nil, reportError("desktopRecording is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.desktopRecording
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsDestroyExecute(r)
}

/*
EnvironmentsDestroy Method for EnvironmentsDestroy

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsDestroy(ctx context.Context, id int32, projectId string) ApiEnvironmentsDestroyRequest {
	return ApiEnvironmentsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsDestroyExecute(r ApiEnvironmentsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	endpointRequest *EndpointRequest
}

func (r ApiEnvironmentsEndpointsCreateRequest) EndpointRequest(endpointRequest EndpointRequest) ApiEnvironmentsEndpointsCreateRequest {
	r.endpointRequest = &endpointRequest
	return r
}

func (r ApiEnvironmentsEndpointsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsCreateExecute(r)
}

/*
EnvironmentsEndpointsCreate Method for EnvironmentsEndpointsCreate

Create a new endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsCreate(ctx context.Context, projectId string) ApiEnvironmentsEndpointsCreateRequest {
	return ApiEnvironmentsEndpointsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsCreateExecute(r ApiEnvironmentsEndpointsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsDestroyExecute(r)
}

/*
EnvironmentsEndpointsDestroy Method for EnvironmentsEndpointsDestroy

Delete an endpoint and clean up materialized query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsDestroy(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsDestroyRequest {
	return ApiEnvironmentsEndpointsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsDestroyExecute(r ApiEnvironmentsEndpointsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	endpointLastExecutionTimesRequest *EndpointLastExecutionTimesRequest
}

func (r ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest) EndpointLastExecutionTimesRequest(endpointLastExecutionTimesRequest EndpointLastExecutionTimesRequest) ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest {
	r.endpointLastExecutionTimesRequest = &endpointLastExecutionTimesRequest
	return r
}

func (r ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest) Execute() (*QueryStatusResponse, *http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsLastExecutionTimesCreateExecute(r)
}

/*
EnvironmentsEndpointsLastExecutionTimesCreate Method for EnvironmentsEndpointsLastExecutionTimesCreate

Get the last execution times in the past 6 months for multiple endpoints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsLastExecutionTimesCreate(ctx context.Context, projectId string) ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest {
	return ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryStatusResponse
func (a *EnvironmentsAPIService) EnvironmentsEndpointsLastExecutionTimesCreateExecute(r ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest) (*QueryStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsLastExecutionTimesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/last_execution_times/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointLastExecutionTimesRequest == nil {
		return localVarReturnValue, nil, reportError("endpointLastExecutionTimesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointLastExecutionTimesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsPartialUpdateExecute(r)
}

/*
EnvironmentsEndpointsPartialUpdate Method for EnvironmentsEndpointsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsPartialUpdate(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsPartialUpdateRequest {
	return ApiEnvironmentsEndpointsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsPartialUpdateExecute(r ApiEnvironmentsEndpointsPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsEndpointsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsRetrieveExecute(r)
}

/*
EnvironmentsEndpointsRetrieve Method for EnvironmentsEndpointsRetrieve

List all endpoints for the team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsRetrieve(ctx context.Context, projectId string) ApiEnvironmentsEndpointsRetrieveRequest {
	return ApiEnvironmentsEndpointsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsRetrieveExecute(r ApiEnvironmentsEndpointsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsRetrieve2Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsRetrieve2Execute(r)
}

/*
EnvironmentsEndpointsRetrieve2 Method for EnvironmentsEndpointsRetrieve2

Retrieve an endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsRetrieve2Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsRetrieve2(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsRetrieve2Request {
	return ApiEnvironmentsEndpointsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsRetrieve2Execute(r ApiEnvironmentsEndpointsRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsRunCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	name string
	projectId string
	endpointRunRequest *EndpointRunRequest
}

func (r ApiEnvironmentsEndpointsRunCreateRequest) EndpointRunRequest(endpointRunRequest EndpointRunRequest) ApiEnvironmentsEndpointsRunCreateRequest {
	r.endpointRunRequest = &endpointRunRequest
	return r
}

func (r ApiEnvironmentsEndpointsRunCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsRunCreateExecute(r)
}

/*
EnvironmentsEndpointsRunCreate Method for EnvironmentsEndpointsRunCreate

Execute endpoint with optional materialization. Supports version parameter, runs latest version if not set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsRunCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsRunCreate(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsRunCreateRequest {
	return ApiEnvironmentsEndpointsRunCreateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsRunCreateExecute(r ApiEnvironmentsEndpointsRunCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsRunCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsRunRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsRunRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsRunRetrieveExecute(r)
}

/*
EnvironmentsEndpointsRunRetrieve Method for EnvironmentsEndpointsRunRetrieve

Execute endpoint with optional materialization. Supports version parameter, runs latest version if not set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsRunRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsRunRetrieve(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsRunRetrieveRequest {
	return ApiEnvironmentsEndpointsRunRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsRunRetrieveExecute(r ApiEnvironmentsEndpointsRunRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsRunRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	name string
	projectId string
	endpointRequest *EndpointRequest
}

func (r ApiEnvironmentsEndpointsUpdateRequest) EndpointRequest(endpointRequest EndpointRequest) ApiEnvironmentsEndpointsUpdateRequest {
	r.endpointRequest = &endpointRequest
	return r
}

func (r ApiEnvironmentsEndpointsUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsUpdateExecute(r)
}

/*
EnvironmentsEndpointsUpdate Method for EnvironmentsEndpointsUpdate

Update an existing endpoint. Parameters are optional.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsUpdate(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsUpdateRequest {
	return ApiEnvironmentsEndpointsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsUpdateExecute(r ApiEnvironmentsEndpointsUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsVersionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsVersionsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsVersionsRetrieveExecute(r)
}

/*
EnvironmentsEndpointsVersionsRetrieve Method for EnvironmentsEndpointsVersionsRetrieve

List all versions for an endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsVersionsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsVersionsRetrieve(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsVersionsRetrieveRequest {
	return ApiEnvironmentsEndpointsVersionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsVersionsRetrieveExecute(r ApiEnvironmentsEndpointsVersionsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsVersionsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/versions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsVersionsRetrieve2Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	name string
	projectId string
	versionNumber string
}

func (r ApiEnvironmentsEndpointsVersionsRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsVersionsRetrieve2Execute(r)
}

/*
EnvironmentsEndpointsVersionsRetrieve2 Method for EnvironmentsEndpointsVersionsRetrieve2

Get details of a specific endpoint version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param versionNumber
 @return ApiEnvironmentsEndpointsVersionsRetrieve2Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEndpointsVersionsRetrieve2(ctx context.Context, name string, projectId string, versionNumber string) ApiEnvironmentsEndpointsVersionsRetrieve2Request {
	return ApiEnvironmentsEndpointsVersionsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEndpointsVersionsRetrieve2Execute(r ApiEnvironmentsEndpointsVersionsRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEndpointsVersionsRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/versions/{version_number}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version_number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingAssignmentRule *ErrorTrackingAssignmentRule
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesCreateRequest) ErrorTrackingAssignmentRule(errorTrackingAssignmentRule ErrorTrackingAssignmentRule) ApiEnvironmentsErrorTrackingAssignmentRulesCreateRequest {
	r.errorTrackingAssignmentRule = &errorTrackingAssignmentRule
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesCreateRequest) Execute() (*ErrorTrackingAssignmentRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesCreateExecute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesCreate Method for EnvironmentsErrorTrackingAssignmentRulesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesCreate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesCreateRequest {
	return ApiEnvironmentsErrorTrackingAssignmentRulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingAssignmentRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesCreateExecute(r ApiEnvironmentsErrorTrackingAssignmentRulesCreateRequest) (*ErrorTrackingAssignmentRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingAssignmentRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingAssignmentRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingAssignmentRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingAssignmentRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingAssignmentRule *ErrorTrackingAssignmentRule
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesCreate_0Request) ErrorTrackingAssignmentRule(errorTrackingAssignmentRule ErrorTrackingAssignmentRule) ApiEnvironmentsErrorTrackingAssignmentRulesCreate_0Request {
	r.errorTrackingAssignmentRule = &errorTrackingAssignmentRule
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesCreate_0Request) Execute() (*ErrorTrackingAssignmentRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesCreate_64Execute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesCreate_0 Method for EnvironmentsErrorTrackingAssignmentRulesCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesCreate_64(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesCreate_0Request {
	return ApiEnvironmentsErrorTrackingAssignmentRulesCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingAssignmentRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesCreate_64Execute(r ApiEnvironmentsErrorTrackingAssignmentRulesCreate_0Request) (*ErrorTrackingAssignmentRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingAssignmentRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesCreate_64")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingAssignmentRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingAssignmentRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingAssignmentRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesDestroyExecute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesDestroy Method for EnvironmentsErrorTrackingAssignmentRulesDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking assignment rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesDestroyRequest {
	return ApiEnvironmentsErrorTrackingAssignmentRulesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesDestroyExecute(r ApiEnvironmentsErrorTrackingAssignmentRulesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesDestroy_65Execute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesDestroy_0 Method for EnvironmentsErrorTrackingAssignmentRulesDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking assignment rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesDestroy_65(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesDestroy_0Request {
	return ApiEnvironmentsErrorTrackingAssignmentRulesDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesDestroy_65Execute(r ApiEnvironmentsErrorTrackingAssignmentRulesDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesDestroy_65")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingAssignmentRulesListRequest) Limit(limit int32) ApiEnvironmentsErrorTrackingAssignmentRulesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingAssignmentRulesListRequest) Offset(offset int32) ApiEnvironmentsErrorTrackingAssignmentRulesListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesListRequest) Execute() (*PaginatedErrorTrackingAssignmentRuleList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesListExecute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesList Method for EnvironmentsErrorTrackingAssignmentRulesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesList(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesListRequest {
	return ApiEnvironmentsErrorTrackingAssignmentRulesListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingAssignmentRuleList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesListExecute(r ApiEnvironmentsErrorTrackingAssignmentRulesListRequest) (*PaginatedErrorTrackingAssignmentRuleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingAssignmentRuleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request) Limit(limit int32) ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request) Offset(offset int32) ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request) Execute() (*PaginatedErrorTrackingAssignmentRuleList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesList_66Execute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesList_0 Method for EnvironmentsErrorTrackingAssignmentRulesList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesList_66(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request {
	return ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingAssignmentRuleList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesList_66Execute(r ApiEnvironmentsErrorTrackingAssignmentRulesList_0Request) (*PaginatedErrorTrackingAssignmentRuleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingAssignmentRuleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesList_66")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedErrorTrackingAssignmentRule *PatchedErrorTrackingAssignmentRule
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdateRequest) PatchedErrorTrackingAssignmentRule(patchedErrorTrackingAssignmentRule PatchedErrorTrackingAssignmentRule) ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdateRequest {
	r.patchedErrorTrackingAssignmentRule = &patchedErrorTrackingAssignmentRule
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdateRequest) Execute() (*ErrorTrackingAssignmentRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesPartialUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesPartialUpdate Method for EnvironmentsErrorTrackingAssignmentRulesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking assignment rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdateRequest {
	return ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingAssignmentRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesPartialUpdateExecute(r ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdateRequest) (*ErrorTrackingAssignmentRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingAssignmentRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingAssignmentRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedErrorTrackingAssignmentRule *PatchedErrorTrackingAssignmentRule
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0Request) PatchedErrorTrackingAssignmentRule(patchedErrorTrackingAssignmentRule PatchedErrorTrackingAssignmentRule) ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0Request {
	r.patchedErrorTrackingAssignmentRule = &patchedErrorTrackingAssignmentRule
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0Request) Execute() (*ErrorTrackingAssignmentRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesPartialUpdate_67Execute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0 Method for EnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking assignment rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesPartialUpdate_67(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0Request {
	return ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingAssignmentRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesPartialUpdate_67Execute(r ApiEnvironmentsErrorTrackingAssignmentRulesPartialUpdate_0Request) (*ErrorTrackingAssignmentRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingAssignmentRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesPartialUpdate_67")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingAssignmentRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	patchedErrorTrackingAssignmentRule *PatchedErrorTrackingAssignmentRule
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateRequest) PatchedErrorTrackingAssignmentRule(patchedErrorTrackingAssignmentRule PatchedErrorTrackingAssignmentRule) ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateRequest {
	r.patchedErrorTrackingAssignmentRule = &patchedErrorTrackingAssignmentRule
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate Method for EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateRequest {
	return ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateExecute(r ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/reorder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingAssignmentRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	patchedErrorTrackingAssignmentRule *PatchedErrorTrackingAssignmentRule
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0Request) PatchedErrorTrackingAssignmentRule(patchedErrorTrackingAssignmentRule PatchedErrorTrackingAssignmentRule) ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0Request {
	r.patchedErrorTrackingAssignmentRule = &patchedErrorTrackingAssignmentRule
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_68Execute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0 Method for EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_68(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0Request {
	return ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_68Execute(r ApiEnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesReorderPartialUpdate_68")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/reorder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingAssignmentRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesRetrieveRequest) Execute() (*ErrorTrackingAssignmentRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesRetrieveExecute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesRetrieve Method for EnvironmentsErrorTrackingAssignmentRulesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking assignment rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesRetrieveRequest {
	return ApiEnvironmentsErrorTrackingAssignmentRulesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingAssignmentRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesRetrieveExecute(r ApiEnvironmentsErrorTrackingAssignmentRulesRetrieveRequest) (*ErrorTrackingAssignmentRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingAssignmentRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesRetrieve_0Request) Execute() (*ErrorTrackingAssignmentRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesRetrieve_69Execute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesRetrieve_0 Method for EnvironmentsErrorTrackingAssignmentRulesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking assignment rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesRetrieve_69(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesRetrieve_0Request {
	return ApiEnvironmentsErrorTrackingAssignmentRulesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingAssignmentRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesRetrieve_69Execute(r ApiEnvironmentsErrorTrackingAssignmentRulesRetrieve_0Request) (*ErrorTrackingAssignmentRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingAssignmentRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesRetrieve_69")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingAssignmentRule *ErrorTrackingAssignmentRule
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesUpdateRequest) ErrorTrackingAssignmentRule(errorTrackingAssignmentRule ErrorTrackingAssignmentRule) ApiEnvironmentsErrorTrackingAssignmentRulesUpdateRequest {
	r.errorTrackingAssignmentRule = &errorTrackingAssignmentRule
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesUpdateRequest) Execute() (*ErrorTrackingAssignmentRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesUpdate Method for EnvironmentsErrorTrackingAssignmentRulesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking assignment rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesUpdateRequest {
	return ApiEnvironmentsErrorTrackingAssignmentRulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingAssignmentRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesUpdateExecute(r ApiEnvironmentsErrorTrackingAssignmentRulesUpdateRequest) (*ErrorTrackingAssignmentRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingAssignmentRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingAssignmentRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingAssignmentRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingAssignmentRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingAssignmentRulesUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingAssignmentRule *ErrorTrackingAssignmentRule
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesUpdate_0Request) ErrorTrackingAssignmentRule(errorTrackingAssignmentRule ErrorTrackingAssignmentRule) ApiEnvironmentsErrorTrackingAssignmentRulesUpdate_0Request {
	r.errorTrackingAssignmentRule = &errorTrackingAssignmentRule
	return r
}

func (r ApiEnvironmentsErrorTrackingAssignmentRulesUpdate_0Request) Execute() (*ErrorTrackingAssignmentRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingAssignmentRulesUpdate_70Execute(r)
}

/*
EnvironmentsErrorTrackingAssignmentRulesUpdate_0 Method for EnvironmentsErrorTrackingAssignmentRulesUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking assignment rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingAssignmentRulesUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesUpdate_70(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingAssignmentRulesUpdate_0Request {
	return ApiEnvironmentsErrorTrackingAssignmentRulesUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingAssignmentRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingAssignmentRulesUpdate_70Execute(r ApiEnvironmentsErrorTrackingAssignmentRulesUpdate_0Request) (*ErrorTrackingAssignmentRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingAssignmentRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingAssignmentRulesUpdate_70")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/assignment_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingAssignmentRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingAssignmentRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingAssignmentRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingFingerprintsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingFingerprintsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingFingerprintsDestroyExecute(r)
}

/*
EnvironmentsErrorTrackingFingerprintsDestroy Method for EnvironmentsErrorTrackingFingerprintsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking issue fingerprint v2.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingFingerprintsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingFingerprintsDestroyRequest {
	return ApiEnvironmentsErrorTrackingFingerprintsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsDestroyExecute(r ApiEnvironmentsErrorTrackingFingerprintsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingFingerprintsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/fingerprints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingFingerprintsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingFingerprintsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingFingerprintsDestroy_71Execute(r)
}

/*
EnvironmentsErrorTrackingFingerprintsDestroy_0 Method for EnvironmentsErrorTrackingFingerprintsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking issue fingerprint v2.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingFingerprintsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsDestroy_71(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingFingerprintsDestroy_0Request {
	return ApiEnvironmentsErrorTrackingFingerprintsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsDestroy_71Execute(r ApiEnvironmentsErrorTrackingFingerprintsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingFingerprintsDestroy_71")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/fingerprints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingFingerprintsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingFingerprintsListRequest) Limit(limit int32) ApiEnvironmentsErrorTrackingFingerprintsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingFingerprintsListRequest) Offset(offset int32) ApiEnvironmentsErrorTrackingFingerprintsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingFingerprintsListRequest) Execute() (*PaginatedErrorTrackingFingerprintList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingFingerprintsListExecute(r)
}

/*
EnvironmentsErrorTrackingFingerprintsList Method for EnvironmentsErrorTrackingFingerprintsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingFingerprintsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsList(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingFingerprintsListRequest {
	return ApiEnvironmentsErrorTrackingFingerprintsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingFingerprintList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsListExecute(r ApiEnvironmentsErrorTrackingFingerprintsListRequest) (*PaginatedErrorTrackingFingerprintList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingFingerprintList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingFingerprintsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/fingerprints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingFingerprintsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingFingerprintsList_0Request) Limit(limit int32) ApiEnvironmentsErrorTrackingFingerprintsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingFingerprintsList_0Request) Offset(offset int32) ApiEnvironmentsErrorTrackingFingerprintsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingFingerprintsList_0Request) Execute() (*PaginatedErrorTrackingFingerprintList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingFingerprintsList_72Execute(r)
}

/*
EnvironmentsErrorTrackingFingerprintsList_0 Method for EnvironmentsErrorTrackingFingerprintsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingFingerprintsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsList_72(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingFingerprintsList_0Request {
	return ApiEnvironmentsErrorTrackingFingerprintsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingFingerprintList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsList_72Execute(r ApiEnvironmentsErrorTrackingFingerprintsList_0Request) (*PaginatedErrorTrackingFingerprintList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingFingerprintList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingFingerprintsList_72")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/fingerprints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingFingerprintsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingFingerprintsRetrieveRequest) Execute() (*ErrorTrackingFingerprint, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingFingerprintsRetrieveExecute(r)
}

/*
EnvironmentsErrorTrackingFingerprintsRetrieve Method for EnvironmentsErrorTrackingFingerprintsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking issue fingerprint v2.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingFingerprintsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingFingerprintsRetrieveRequest {
	return ApiEnvironmentsErrorTrackingFingerprintsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingFingerprint
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsRetrieveExecute(r ApiEnvironmentsErrorTrackingFingerprintsRetrieveRequest) (*ErrorTrackingFingerprint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingFingerprint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingFingerprintsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/fingerprints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingFingerprintsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingFingerprintsRetrieve_0Request) Execute() (*ErrorTrackingFingerprint, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingFingerprintsRetrieve_73Execute(r)
}

/*
EnvironmentsErrorTrackingFingerprintsRetrieve_0 Method for EnvironmentsErrorTrackingFingerprintsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking issue fingerprint v2.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingFingerprintsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsRetrieve_73(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingFingerprintsRetrieve_0Request {
	return ApiEnvironmentsErrorTrackingFingerprintsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingFingerprint
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingFingerprintsRetrieve_73Execute(r ApiEnvironmentsErrorTrackingFingerprintsRetrieve_0Request) (*ErrorTrackingFingerprint, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingFingerprint
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingFingerprintsRetrieve_73")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/fingerprints/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieveExecute(r)
}

/*
EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve Method for EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieveRequest {
	return ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieveExecute(r ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/git-provider-file-links/resolve_github/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_74Execute(r)
}

/*
EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_0 Method for EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_74(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_0Request {
	return ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_74Execute(r ApiEnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGitProviderFileLinksResolveGithubRetrieve_74")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/git-provider-file-links/resolve_github/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingGroupingRule *ErrorTrackingGroupingRule
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesCreateRequest) ErrorTrackingGroupingRule(errorTrackingGroupingRule ErrorTrackingGroupingRule) ApiEnvironmentsErrorTrackingGroupingRulesCreateRequest {
	r.errorTrackingGroupingRule = &errorTrackingGroupingRule
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesCreateRequest) Execute() (*ErrorTrackingGroupingRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesCreateExecute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesCreate Method for EnvironmentsErrorTrackingGroupingRulesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesCreate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesCreateRequest {
	return ApiEnvironmentsErrorTrackingGroupingRulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingGroupingRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesCreateExecute(r ApiEnvironmentsErrorTrackingGroupingRulesCreateRequest) (*ErrorTrackingGroupingRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingGroupingRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingGroupingRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingGroupingRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingGroupingRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingGroupingRule *ErrorTrackingGroupingRule
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesCreate_0Request) ErrorTrackingGroupingRule(errorTrackingGroupingRule ErrorTrackingGroupingRule) ApiEnvironmentsErrorTrackingGroupingRulesCreate_0Request {
	r.errorTrackingGroupingRule = &errorTrackingGroupingRule
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesCreate_0Request) Execute() (*ErrorTrackingGroupingRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesCreate_75Execute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesCreate_0 Method for EnvironmentsErrorTrackingGroupingRulesCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesCreate_75(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesCreate_0Request {
	return ApiEnvironmentsErrorTrackingGroupingRulesCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingGroupingRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesCreate_75Execute(r ApiEnvironmentsErrorTrackingGroupingRulesCreate_0Request) (*ErrorTrackingGroupingRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingGroupingRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesCreate_75")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingGroupingRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingGroupingRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingGroupingRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesDestroyExecute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesDestroy Method for EnvironmentsErrorTrackingGroupingRulesDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking grouping rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesDestroyRequest {
	return ApiEnvironmentsErrorTrackingGroupingRulesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesDestroyExecute(r ApiEnvironmentsErrorTrackingGroupingRulesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesDestroy_76Execute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesDestroy_0 Method for EnvironmentsErrorTrackingGroupingRulesDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking grouping rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesDestroy_76(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesDestroy_0Request {
	return ApiEnvironmentsErrorTrackingGroupingRulesDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesDestroy_76Execute(r ApiEnvironmentsErrorTrackingGroupingRulesDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesDestroy_76")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingGroupingRulesListRequest) Limit(limit int32) ApiEnvironmentsErrorTrackingGroupingRulesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingGroupingRulesListRequest) Offset(offset int32) ApiEnvironmentsErrorTrackingGroupingRulesListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesListRequest) Execute() (*PaginatedErrorTrackingGroupingRuleList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesListExecute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesList Method for EnvironmentsErrorTrackingGroupingRulesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesList(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesListRequest {
	return ApiEnvironmentsErrorTrackingGroupingRulesListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingGroupingRuleList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesListExecute(r ApiEnvironmentsErrorTrackingGroupingRulesListRequest) (*PaginatedErrorTrackingGroupingRuleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingGroupingRuleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingGroupingRulesList_0Request) Limit(limit int32) ApiEnvironmentsErrorTrackingGroupingRulesList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingGroupingRulesList_0Request) Offset(offset int32) ApiEnvironmentsErrorTrackingGroupingRulesList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesList_0Request) Execute() (*PaginatedErrorTrackingGroupingRuleList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesList_77Execute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesList_0 Method for EnvironmentsErrorTrackingGroupingRulesList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesList_77(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesList_0Request {
	return ApiEnvironmentsErrorTrackingGroupingRulesList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingGroupingRuleList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesList_77Execute(r ApiEnvironmentsErrorTrackingGroupingRulesList_0Request) (*PaginatedErrorTrackingGroupingRuleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingGroupingRuleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesList_77")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedErrorTrackingGroupingRule *PatchedErrorTrackingGroupingRule
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdateRequest) PatchedErrorTrackingGroupingRule(patchedErrorTrackingGroupingRule PatchedErrorTrackingGroupingRule) ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdateRequest {
	r.patchedErrorTrackingGroupingRule = &patchedErrorTrackingGroupingRule
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdateRequest) Execute() (*ErrorTrackingGroupingRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesPartialUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesPartialUpdate Method for EnvironmentsErrorTrackingGroupingRulesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking grouping rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdateRequest {
	return ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingGroupingRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesPartialUpdateExecute(r ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdateRequest) (*ErrorTrackingGroupingRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingGroupingRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingGroupingRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedErrorTrackingGroupingRule *PatchedErrorTrackingGroupingRule
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdate_0Request) PatchedErrorTrackingGroupingRule(patchedErrorTrackingGroupingRule PatchedErrorTrackingGroupingRule) ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdate_0Request {
	r.patchedErrorTrackingGroupingRule = &patchedErrorTrackingGroupingRule
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdate_0Request) Execute() (*ErrorTrackingGroupingRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesPartialUpdate_78Execute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesPartialUpdate_0 Method for EnvironmentsErrorTrackingGroupingRulesPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking grouping rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesPartialUpdate_78(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdate_0Request {
	return ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingGroupingRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesPartialUpdate_78Execute(r ApiEnvironmentsErrorTrackingGroupingRulesPartialUpdate_0Request) (*ErrorTrackingGroupingRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingGroupingRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesPartialUpdate_78")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingGroupingRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	patchedErrorTrackingGroupingRule *PatchedErrorTrackingGroupingRule
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateRequest) PatchedErrorTrackingGroupingRule(patchedErrorTrackingGroupingRule PatchedErrorTrackingGroupingRule) ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateRequest {
	r.patchedErrorTrackingGroupingRule = &patchedErrorTrackingGroupingRule
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate Method for EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateRequest {
	return ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateExecute(r ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/reorder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingGroupingRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	patchedErrorTrackingGroupingRule *PatchedErrorTrackingGroupingRule
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0Request) PatchedErrorTrackingGroupingRule(patchedErrorTrackingGroupingRule PatchedErrorTrackingGroupingRule) ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0Request {
	r.patchedErrorTrackingGroupingRule = &patchedErrorTrackingGroupingRule
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_79Execute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0 Method for EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_79(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0Request {
	return ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_79Execute(r ApiEnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesReorderPartialUpdate_79")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/reorder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingGroupingRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesRetrieveRequest) Execute() (*ErrorTrackingGroupingRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesRetrieveExecute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesRetrieve Method for EnvironmentsErrorTrackingGroupingRulesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking grouping rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesRetrieveRequest {
	return ApiEnvironmentsErrorTrackingGroupingRulesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingGroupingRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesRetrieveExecute(r ApiEnvironmentsErrorTrackingGroupingRulesRetrieveRequest) (*ErrorTrackingGroupingRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingGroupingRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesRetrieve_0Request) Execute() (*ErrorTrackingGroupingRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesRetrieve_80Execute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesRetrieve_0 Method for EnvironmentsErrorTrackingGroupingRulesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking grouping rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesRetrieve_80(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesRetrieve_0Request {
	return ApiEnvironmentsErrorTrackingGroupingRulesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingGroupingRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesRetrieve_80Execute(r ApiEnvironmentsErrorTrackingGroupingRulesRetrieve_0Request) (*ErrorTrackingGroupingRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingGroupingRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesRetrieve_80")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingGroupingRule *ErrorTrackingGroupingRule
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesUpdateRequest) ErrorTrackingGroupingRule(errorTrackingGroupingRule ErrorTrackingGroupingRule) ApiEnvironmentsErrorTrackingGroupingRulesUpdateRequest {
	r.errorTrackingGroupingRule = &errorTrackingGroupingRule
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesUpdateRequest) Execute() (*ErrorTrackingGroupingRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesUpdate Method for EnvironmentsErrorTrackingGroupingRulesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking grouping rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesUpdateRequest {
	return ApiEnvironmentsErrorTrackingGroupingRulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingGroupingRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesUpdateExecute(r ApiEnvironmentsErrorTrackingGroupingRulesUpdateRequest) (*ErrorTrackingGroupingRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingGroupingRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingGroupingRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingGroupingRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingGroupingRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingGroupingRulesUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingGroupingRule *ErrorTrackingGroupingRule
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesUpdate_0Request) ErrorTrackingGroupingRule(errorTrackingGroupingRule ErrorTrackingGroupingRule) ApiEnvironmentsErrorTrackingGroupingRulesUpdate_0Request {
	r.errorTrackingGroupingRule = &errorTrackingGroupingRule
	return r
}

func (r ApiEnvironmentsErrorTrackingGroupingRulesUpdate_0Request) Execute() (*ErrorTrackingGroupingRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingGroupingRulesUpdate_81Execute(r)
}

/*
EnvironmentsErrorTrackingGroupingRulesUpdate_0 Method for EnvironmentsErrorTrackingGroupingRulesUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking grouping rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingGroupingRulesUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesUpdate_81(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingGroupingRulesUpdate_0Request {
	return ApiEnvironmentsErrorTrackingGroupingRulesUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingGroupingRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingGroupingRulesUpdate_81Execute(r ApiEnvironmentsErrorTrackingGroupingRulesUpdate_0Request) (*ErrorTrackingGroupingRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingGroupingRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingGroupingRulesUpdate_81")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/grouping_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingGroupingRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingGroupingRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingGroupingRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingRelease *ErrorTrackingRelease
}

func (r ApiEnvironmentsErrorTrackingReleasesCreateRequest) ErrorTrackingRelease(errorTrackingRelease ErrorTrackingRelease) ApiEnvironmentsErrorTrackingReleasesCreateRequest {
	r.errorTrackingRelease = &errorTrackingRelease
	return r
}

func (r ApiEnvironmentsErrorTrackingReleasesCreateRequest) Execute() (*ErrorTrackingRelease, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesCreateExecute(r)
}

/*
EnvironmentsErrorTrackingReleasesCreate Method for EnvironmentsErrorTrackingReleasesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesCreate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingReleasesCreateRequest {
	return ApiEnvironmentsErrorTrackingReleasesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingRelease
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesCreateExecute(r ApiEnvironmentsErrorTrackingReleasesCreateRequest) (*ErrorTrackingRelease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingRelease == nil {
		return localVarReturnValue, nil, reportError("errorTrackingRelease is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingRelease *ErrorTrackingRelease
}

func (r ApiEnvironmentsErrorTrackingReleasesCreate_0Request) ErrorTrackingRelease(errorTrackingRelease ErrorTrackingRelease) ApiEnvironmentsErrorTrackingReleasesCreate_0Request {
	r.errorTrackingRelease = &errorTrackingRelease
	return r
}

func (r ApiEnvironmentsErrorTrackingReleasesCreate_0Request) Execute() (*ErrorTrackingRelease, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesCreate_82Execute(r)
}

/*
EnvironmentsErrorTrackingReleasesCreate_0 Method for EnvironmentsErrorTrackingReleasesCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesCreate_82(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingReleasesCreate_0Request {
	return ApiEnvironmentsErrorTrackingReleasesCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingRelease
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesCreate_82Execute(r ApiEnvironmentsErrorTrackingReleasesCreate_0Request) (*ErrorTrackingRelease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesCreate_82")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingRelease == nil {
		return localVarReturnValue, nil, reportError("errorTrackingRelease is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingReleasesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesDestroyExecute(r)
}

/*
EnvironmentsErrorTrackingReleasesDestroy Method for EnvironmentsErrorTrackingReleasesDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking release.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingReleasesDestroyRequest {
	return ApiEnvironmentsErrorTrackingReleasesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesDestroyExecute(r ApiEnvironmentsErrorTrackingReleasesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingReleasesDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesDestroy_83Execute(r)
}

/*
EnvironmentsErrorTrackingReleasesDestroy_0 Method for EnvironmentsErrorTrackingReleasesDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking release.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesDestroy_83(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingReleasesDestroy_0Request {
	return ApiEnvironmentsErrorTrackingReleasesDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesDestroy_83Execute(r ApiEnvironmentsErrorTrackingReleasesDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesDestroy_83")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesHashRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	hashId string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingReleasesHashRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesHashRetrieveExecute(r)
}

/*
EnvironmentsErrorTrackingReleasesHashRetrieve Method for EnvironmentsErrorTrackingReleasesHashRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hashId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesHashRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesHashRetrieve(ctx context.Context, hashId string, projectId string) ApiEnvironmentsErrorTrackingReleasesHashRetrieveRequest {
	return ApiEnvironmentsErrorTrackingReleasesHashRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		hashId: hashId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesHashRetrieveExecute(r ApiEnvironmentsErrorTrackingReleasesHashRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesHashRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/hash/{hash_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"hash_id"+"}", url.PathEscape(parameterValueToString(r.hashId, "hashId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesHashRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	hashId string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingReleasesHashRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesHashRetrieve_84Execute(r)
}

/*
EnvironmentsErrorTrackingReleasesHashRetrieve_0 Method for EnvironmentsErrorTrackingReleasesHashRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param hashId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesHashRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesHashRetrieve_84(ctx context.Context, hashId string, projectId string) ApiEnvironmentsErrorTrackingReleasesHashRetrieve_0Request {
	return ApiEnvironmentsErrorTrackingReleasesHashRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		hashId: hashId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesHashRetrieve_84Execute(r ApiEnvironmentsErrorTrackingReleasesHashRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesHashRetrieve_84")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/hash/{hash_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"hash_id"+"}", url.PathEscape(parameterValueToString(r.hashId, "hashId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingReleasesListRequest) Limit(limit int32) ApiEnvironmentsErrorTrackingReleasesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingReleasesListRequest) Offset(offset int32) ApiEnvironmentsErrorTrackingReleasesListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingReleasesListRequest) Execute() (*PaginatedErrorTrackingReleaseList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesListExecute(r)
}

/*
EnvironmentsErrorTrackingReleasesList Method for EnvironmentsErrorTrackingReleasesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesList(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingReleasesListRequest {
	return ApiEnvironmentsErrorTrackingReleasesListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingReleaseList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesListExecute(r ApiEnvironmentsErrorTrackingReleasesListRequest) (*PaginatedErrorTrackingReleaseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingReleaseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingReleasesList_0Request) Limit(limit int32) ApiEnvironmentsErrorTrackingReleasesList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingReleasesList_0Request) Offset(offset int32) ApiEnvironmentsErrorTrackingReleasesList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingReleasesList_0Request) Execute() (*PaginatedErrorTrackingReleaseList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesList_85Execute(r)
}

/*
EnvironmentsErrorTrackingReleasesList_0 Method for EnvironmentsErrorTrackingReleasesList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesList_85(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingReleasesList_0Request {
	return ApiEnvironmentsErrorTrackingReleasesList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingReleaseList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesList_85Execute(r ApiEnvironmentsErrorTrackingReleasesList_0Request) (*PaginatedErrorTrackingReleaseList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingReleaseList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesList_85")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedErrorTrackingRelease *PatchedErrorTrackingRelease
}

func (r ApiEnvironmentsErrorTrackingReleasesPartialUpdateRequest) PatchedErrorTrackingRelease(patchedErrorTrackingRelease PatchedErrorTrackingRelease) ApiEnvironmentsErrorTrackingReleasesPartialUpdateRequest {
	r.patchedErrorTrackingRelease = &patchedErrorTrackingRelease
	return r
}

func (r ApiEnvironmentsErrorTrackingReleasesPartialUpdateRequest) Execute() (*ErrorTrackingRelease, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesPartialUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingReleasesPartialUpdate Method for EnvironmentsErrorTrackingReleasesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking release.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingReleasesPartialUpdateRequest {
	return ApiEnvironmentsErrorTrackingReleasesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingRelease
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesPartialUpdateExecute(r ApiEnvironmentsErrorTrackingReleasesPartialUpdateRequest) (*ErrorTrackingRelease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedErrorTrackingRelease *PatchedErrorTrackingRelease
}

func (r ApiEnvironmentsErrorTrackingReleasesPartialUpdate_0Request) PatchedErrorTrackingRelease(patchedErrorTrackingRelease PatchedErrorTrackingRelease) ApiEnvironmentsErrorTrackingReleasesPartialUpdate_0Request {
	r.patchedErrorTrackingRelease = &patchedErrorTrackingRelease
	return r
}

func (r ApiEnvironmentsErrorTrackingReleasesPartialUpdate_0Request) Execute() (*ErrorTrackingRelease, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesPartialUpdate_86Execute(r)
}

/*
EnvironmentsErrorTrackingReleasesPartialUpdate_0 Method for EnvironmentsErrorTrackingReleasesPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking release.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesPartialUpdate_86(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingReleasesPartialUpdate_0Request {
	return ApiEnvironmentsErrorTrackingReleasesPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingRelease
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesPartialUpdate_86Execute(r ApiEnvironmentsErrorTrackingReleasesPartialUpdate_0Request) (*ErrorTrackingRelease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesPartialUpdate_86")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingReleasesRetrieveRequest) Execute() (*ErrorTrackingRelease, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesRetrieveExecute(r)
}

/*
EnvironmentsErrorTrackingReleasesRetrieve Method for EnvironmentsErrorTrackingReleasesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking release.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingReleasesRetrieveRequest {
	return ApiEnvironmentsErrorTrackingReleasesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingRelease
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesRetrieveExecute(r ApiEnvironmentsErrorTrackingReleasesRetrieveRequest) (*ErrorTrackingRelease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingReleasesRetrieve_0Request) Execute() (*ErrorTrackingRelease, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesRetrieve_87Execute(r)
}

/*
EnvironmentsErrorTrackingReleasesRetrieve_0 Method for EnvironmentsErrorTrackingReleasesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking release.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesRetrieve_87(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingReleasesRetrieve_0Request {
	return ApiEnvironmentsErrorTrackingReleasesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingRelease
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesRetrieve_87Execute(r ApiEnvironmentsErrorTrackingReleasesRetrieve_0Request) (*ErrorTrackingRelease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesRetrieve_87")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingRelease *ErrorTrackingRelease
}

func (r ApiEnvironmentsErrorTrackingReleasesUpdateRequest) ErrorTrackingRelease(errorTrackingRelease ErrorTrackingRelease) ApiEnvironmentsErrorTrackingReleasesUpdateRequest {
	r.errorTrackingRelease = &errorTrackingRelease
	return r
}

func (r ApiEnvironmentsErrorTrackingReleasesUpdateRequest) Execute() (*ErrorTrackingRelease, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingReleasesUpdate Method for EnvironmentsErrorTrackingReleasesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking release.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingReleasesUpdateRequest {
	return ApiEnvironmentsErrorTrackingReleasesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingRelease
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesUpdateExecute(r ApiEnvironmentsErrorTrackingReleasesUpdateRequest) (*ErrorTrackingRelease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingRelease == nil {
		return localVarReturnValue, nil, reportError("errorTrackingRelease is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingReleasesUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingRelease *ErrorTrackingRelease
}

func (r ApiEnvironmentsErrorTrackingReleasesUpdate_0Request) ErrorTrackingRelease(errorTrackingRelease ErrorTrackingRelease) ApiEnvironmentsErrorTrackingReleasesUpdate_0Request {
	r.errorTrackingRelease = &errorTrackingRelease
	return r
}

func (r ApiEnvironmentsErrorTrackingReleasesUpdate_0Request) Execute() (*ErrorTrackingRelease, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingReleasesUpdate_88Execute(r)
}

/*
EnvironmentsErrorTrackingReleasesUpdate_0 Method for EnvironmentsErrorTrackingReleasesUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking release.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingReleasesUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesUpdate_88(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingReleasesUpdate_0Request {
	return ApiEnvironmentsErrorTrackingReleasesUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingRelease
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingReleasesUpdate_88Execute(r ApiEnvironmentsErrorTrackingReleasesUpdate_0Request) (*ErrorTrackingRelease, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingRelease
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingReleasesUpdate_88")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/releases/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingRelease == nil {
		return localVarReturnValue, nil, reportError("errorTrackingRelease is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingRelease
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingSuppressionRule *ErrorTrackingSuppressionRule
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesCreateRequest) ErrorTrackingSuppressionRule(errorTrackingSuppressionRule ErrorTrackingSuppressionRule) ApiEnvironmentsErrorTrackingSuppressionRulesCreateRequest {
	r.errorTrackingSuppressionRule = &errorTrackingSuppressionRule
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesCreateRequest) Execute() (*ErrorTrackingSuppressionRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesCreateExecute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesCreate Method for EnvironmentsErrorTrackingSuppressionRulesCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesCreate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesCreateRequest {
	return ApiEnvironmentsErrorTrackingSuppressionRulesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSuppressionRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesCreateExecute(r ApiEnvironmentsErrorTrackingSuppressionRulesCreateRequest) (*ErrorTrackingSuppressionRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSuppressionRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSuppressionRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingSuppressionRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSuppressionRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingSuppressionRule *ErrorTrackingSuppressionRule
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesCreate_0Request) ErrorTrackingSuppressionRule(errorTrackingSuppressionRule ErrorTrackingSuppressionRule) ApiEnvironmentsErrorTrackingSuppressionRulesCreate_0Request {
	r.errorTrackingSuppressionRule = &errorTrackingSuppressionRule
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesCreate_0Request) Execute() (*ErrorTrackingSuppressionRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesCreate_89Execute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesCreate_0 Method for EnvironmentsErrorTrackingSuppressionRulesCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesCreate_89(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesCreate_0Request {
	return ApiEnvironmentsErrorTrackingSuppressionRulesCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSuppressionRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesCreate_89Execute(r ApiEnvironmentsErrorTrackingSuppressionRulesCreate_0Request) (*ErrorTrackingSuppressionRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSuppressionRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesCreate_89")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSuppressionRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingSuppressionRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSuppressionRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesDestroyExecute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesDestroy Method for EnvironmentsErrorTrackingSuppressionRulesDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking suppression rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesDestroyRequest {
	return ApiEnvironmentsErrorTrackingSuppressionRulesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesDestroyExecute(r ApiEnvironmentsErrorTrackingSuppressionRulesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesDestroy_90Execute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesDestroy_0 Method for EnvironmentsErrorTrackingSuppressionRulesDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking suppression rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesDestroy_90(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesDestroy_0Request {
	return ApiEnvironmentsErrorTrackingSuppressionRulesDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesDestroy_90Execute(r ApiEnvironmentsErrorTrackingSuppressionRulesDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesDestroy_90")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingSuppressionRulesListRequest) Limit(limit int32) ApiEnvironmentsErrorTrackingSuppressionRulesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingSuppressionRulesListRequest) Offset(offset int32) ApiEnvironmentsErrorTrackingSuppressionRulesListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesListRequest) Execute() (*PaginatedErrorTrackingSuppressionRuleList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesListExecute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesList Method for EnvironmentsErrorTrackingSuppressionRulesList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesList(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesListRequest {
	return ApiEnvironmentsErrorTrackingSuppressionRulesListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingSuppressionRuleList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesListExecute(r ApiEnvironmentsErrorTrackingSuppressionRulesListRequest) (*PaginatedErrorTrackingSuppressionRuleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingSuppressionRuleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request) Limit(limit int32) ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request) Offset(offset int32) ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request) Execute() (*PaginatedErrorTrackingSuppressionRuleList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesList_91Execute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesList_0 Method for EnvironmentsErrorTrackingSuppressionRulesList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesList_91(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request {
	return ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingSuppressionRuleList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesList_91Execute(r ApiEnvironmentsErrorTrackingSuppressionRulesList_0Request) (*PaginatedErrorTrackingSuppressionRuleList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingSuppressionRuleList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesList_91")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedErrorTrackingSuppressionRule *PatchedErrorTrackingSuppressionRule
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdateRequest) PatchedErrorTrackingSuppressionRule(patchedErrorTrackingSuppressionRule PatchedErrorTrackingSuppressionRule) ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdateRequest {
	r.patchedErrorTrackingSuppressionRule = &patchedErrorTrackingSuppressionRule
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdateRequest) Execute() (*ErrorTrackingSuppressionRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesPartialUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesPartialUpdate Method for EnvironmentsErrorTrackingSuppressionRulesPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking suppression rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdateRequest {
	return ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSuppressionRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesPartialUpdateExecute(r ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdateRequest) (*ErrorTrackingSuppressionRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSuppressionRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingSuppressionRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedErrorTrackingSuppressionRule *PatchedErrorTrackingSuppressionRule
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0Request) PatchedErrorTrackingSuppressionRule(patchedErrorTrackingSuppressionRule PatchedErrorTrackingSuppressionRule) ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0Request {
	r.patchedErrorTrackingSuppressionRule = &patchedErrorTrackingSuppressionRule
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0Request) Execute() (*ErrorTrackingSuppressionRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesPartialUpdate_92Execute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0 Method for EnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking suppression rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesPartialUpdate_92(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0Request {
	return ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSuppressionRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesPartialUpdate_92Execute(r ApiEnvironmentsErrorTrackingSuppressionRulesPartialUpdate_0Request) (*ErrorTrackingSuppressionRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSuppressionRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesPartialUpdate_92")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingSuppressionRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	patchedErrorTrackingSuppressionRule *PatchedErrorTrackingSuppressionRule
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateRequest) PatchedErrorTrackingSuppressionRule(patchedErrorTrackingSuppressionRule PatchedErrorTrackingSuppressionRule) ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateRequest {
	r.patchedErrorTrackingSuppressionRule = &patchedErrorTrackingSuppressionRule
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate Method for EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateRequest {
	return ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateExecute(r ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/reorder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingSuppressionRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	patchedErrorTrackingSuppressionRule *PatchedErrorTrackingSuppressionRule
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0Request) PatchedErrorTrackingSuppressionRule(patchedErrorTrackingSuppressionRule PatchedErrorTrackingSuppressionRule) ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0Request {
	r.patchedErrorTrackingSuppressionRule = &patchedErrorTrackingSuppressionRule
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_93Execute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0 Method for EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_93(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0Request {
	return ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_93Execute(r ApiEnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesReorderPartialUpdate_93")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/reorder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedErrorTrackingSuppressionRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesRetrieveRequest) Execute() (*ErrorTrackingSuppressionRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesRetrieveExecute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesRetrieve Method for EnvironmentsErrorTrackingSuppressionRulesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking suppression rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesRetrieveRequest {
	return ApiEnvironmentsErrorTrackingSuppressionRulesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSuppressionRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesRetrieveExecute(r ApiEnvironmentsErrorTrackingSuppressionRulesRetrieveRequest) (*ErrorTrackingSuppressionRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSuppressionRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesRetrieve_0Request) Execute() (*ErrorTrackingSuppressionRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesRetrieve_94Execute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesRetrieve_0 Method for EnvironmentsErrorTrackingSuppressionRulesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking suppression rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesRetrieve_94(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesRetrieve_0Request {
	return ApiEnvironmentsErrorTrackingSuppressionRulesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSuppressionRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesRetrieve_94Execute(r ApiEnvironmentsErrorTrackingSuppressionRulesRetrieve_0Request) (*ErrorTrackingSuppressionRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSuppressionRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesRetrieve_94")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingSuppressionRule *ErrorTrackingSuppressionRule
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesUpdateRequest) ErrorTrackingSuppressionRule(errorTrackingSuppressionRule ErrorTrackingSuppressionRule) ApiEnvironmentsErrorTrackingSuppressionRulesUpdateRequest {
	r.errorTrackingSuppressionRule = &errorTrackingSuppressionRule
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesUpdateRequest) Execute() (*ErrorTrackingSuppressionRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesUpdate Method for EnvironmentsErrorTrackingSuppressionRulesUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking suppression rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesUpdateRequest {
	return ApiEnvironmentsErrorTrackingSuppressionRulesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSuppressionRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesUpdateExecute(r ApiEnvironmentsErrorTrackingSuppressionRulesUpdateRequest) (*ErrorTrackingSuppressionRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSuppressionRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSuppressionRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingSuppressionRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSuppressionRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSuppressionRulesUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingSuppressionRule *ErrorTrackingSuppressionRule
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesUpdate_0Request) ErrorTrackingSuppressionRule(errorTrackingSuppressionRule ErrorTrackingSuppressionRule) ApiEnvironmentsErrorTrackingSuppressionRulesUpdate_0Request {
	r.errorTrackingSuppressionRule = &errorTrackingSuppressionRule
	return r
}

func (r ApiEnvironmentsErrorTrackingSuppressionRulesUpdate_0Request) Execute() (*ErrorTrackingSuppressionRule, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSuppressionRulesUpdate_95Execute(r)
}

/*
EnvironmentsErrorTrackingSuppressionRulesUpdate_0 Method for EnvironmentsErrorTrackingSuppressionRulesUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking suppression rule.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSuppressionRulesUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesUpdate_95(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSuppressionRulesUpdate_0Request {
	return ApiEnvironmentsErrorTrackingSuppressionRulesUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSuppressionRule
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSuppressionRulesUpdate_95Execute(r ApiEnvironmentsErrorTrackingSuppressionRulesUpdate_0Request) (*ErrorTrackingSuppressionRule, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSuppressionRule
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSuppressionRulesUpdate_95")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/suppression_rules/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSuppressionRule == nil {
		return localVarReturnValue, nil, reportError("errorTrackingSuppressionRule is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSuppressionRule
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingSymbolSet *ErrorTrackingSymbolSet
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateRequest) ErrorTrackingSymbolSet(errorTrackingSymbolSet ErrorTrackingSymbolSet) ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateRequest {
	r.errorTrackingSymbolSet = &errorTrackingSymbolSet
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate Method for EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateExecute(r ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/bulk_finish_upload/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSymbolSet == nil {
		return nil, reportError("errorTrackingSymbolSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSymbolSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingSymbolSet *ErrorTrackingSymbolSet
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0Request) ErrorTrackingSymbolSet(errorTrackingSymbolSet ErrorTrackingSymbolSet) ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0Request {
	r.errorTrackingSymbolSet = &errorTrackingSymbolSet
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_96Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0 Method for EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_96(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_96Execute(r ApiEnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsBulkFinishUploadCreate_96")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/bulk_finish_upload/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSymbolSet == nil {
		return nil, reportError("errorTrackingSymbolSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSymbolSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingSymbolSet *ErrorTrackingSymbolSet
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateRequest) ErrorTrackingSymbolSet(errorTrackingSymbolSet ErrorTrackingSymbolSet) ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateRequest {
	r.errorTrackingSymbolSet = &errorTrackingSymbolSet
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate Method for EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateExecute(r ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/bulk_start_upload/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSymbolSet == nil {
		return nil, reportError("errorTrackingSymbolSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSymbolSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	errorTrackingSymbolSet *ErrorTrackingSymbolSet
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0Request) ErrorTrackingSymbolSet(errorTrackingSymbolSet ErrorTrackingSymbolSet) ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0Request {
	r.errorTrackingSymbolSet = &errorTrackingSymbolSet
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_97Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0 Method for EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_97(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_97Execute(r ApiEnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsBulkStartUploadCreate_97")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/bulk_start_upload/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSymbolSet == nil {
		return nil, reportError("errorTrackingSymbolSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSymbolSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	id *string
	ref *string
	teamId *int32
	createdAt *time.Time
	storagePtr *string
	failureReason *string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest) Id(id string) ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest {
	r.id = &id
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest) Ref(ref string) ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest {
	r.ref = &ref
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest) TeamId(teamId int32) ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest {
	r.teamId = &teamId
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest) StoragePtr(storagePtr string) ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest {
	r.storagePtr = &storagePtr
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest) FailureReason(failureReason string) ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest {
	r.failureReason = &failureReason
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest) Execute() (*ErrorTrackingSymbolSet, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsCreateExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsCreate Method for EnvironmentsErrorTrackingSymbolSetsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsCreate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSymbolSet
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsCreateExecute(r ApiEnvironmentsErrorTrackingSymbolSetsCreateRequest) (*ErrorTrackingSymbolSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSymbolSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.ref == nil {
		return localVarReturnValue, nil, reportError("ref is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}
	if r.createdAt == nil {
		return localVarReturnValue, nil, reportError("createdAt is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ref", r.ref, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "team_id", r.teamId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.storagePtr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "storage_ptr", r.storagePtr, "", "")
	}
	if r.failureReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "failure_reason", r.failureReason, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	id *string
	ref *string
	teamId *int32
	createdAt *time.Time
	storagePtr *string
	failureReason *string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request) Id(id string) ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request {
	r.id = &id
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request) Ref(ref string) ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request {
	r.ref = &ref
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request) TeamId(teamId int32) ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request {
	r.teamId = &teamId
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request) StoragePtr(storagePtr string) ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request {
	r.storagePtr = &storagePtr
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request) FailureReason(failureReason string) ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request {
	r.failureReason = &failureReason
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request) Execute() (*ErrorTrackingSymbolSet, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsCreate_98Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsCreate_0 Method for EnvironmentsErrorTrackingSymbolSetsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsCreate_98(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSymbolSet
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsCreate_98Execute(r ApiEnvironmentsErrorTrackingSymbolSetsCreate_0Request) (*ErrorTrackingSymbolSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSymbolSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsCreate_98")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.ref == nil {
		return localVarReturnValue, nil, reportError("ref is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}
	if r.createdAt == nil {
		return localVarReturnValue, nil, reportError("createdAt is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ref", r.ref, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "team_id", r.teamId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.storagePtr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "storage_ptr", r.storagePtr, "", "")
	}
	if r.failureReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "failure_reason", r.failureReason, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsDestroyExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsDestroy Method for EnvironmentsErrorTrackingSymbolSetsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsDestroyRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsDestroyExecute(r ApiEnvironmentsErrorTrackingSymbolSetsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsDestroy_99Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsDestroy_0 Method for EnvironmentsErrorTrackingSymbolSetsDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsDestroy_99(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsDestroy_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsDestroy_99Execute(r ApiEnvironmentsErrorTrackingSymbolSetsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsDestroy_99")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingSymbolSet *ErrorTrackingSymbolSet
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateRequest) ErrorTrackingSymbolSet(errorTrackingSymbolSet ErrorTrackingSymbolSet) ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateRequest {
	r.errorTrackingSymbolSet = &errorTrackingSymbolSet
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate Method for EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateExecute(r ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/finish_upload/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSymbolSet == nil {
		return nil, reportError("errorTrackingSymbolSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSymbolSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	errorTrackingSymbolSet *ErrorTrackingSymbolSet
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0Request) ErrorTrackingSymbolSet(errorTrackingSymbolSet ErrorTrackingSymbolSet) ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0Request {
	r.errorTrackingSymbolSet = &errorTrackingSymbolSet
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_100Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0 Method for EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_100(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_100Execute(r ApiEnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsFinishUploadUpdate_100")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/finish_upload/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.errorTrackingSymbolSet == nil {
		return nil, reportError("errorTrackingSymbolSet is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.errorTrackingSymbolSet
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingSymbolSetsListRequest) Limit(limit int32) ApiEnvironmentsErrorTrackingSymbolSetsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingSymbolSetsListRequest) Offset(offset int32) ApiEnvironmentsErrorTrackingSymbolSetsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsListRequest) Execute() (*PaginatedErrorTrackingSymbolSetList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsListExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsList Method for EnvironmentsErrorTrackingSymbolSetsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsList(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsListRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingSymbolSetList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsListExecute(r ApiEnvironmentsErrorTrackingSymbolSetsListRequest) (*PaginatedErrorTrackingSymbolSetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingSymbolSetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsErrorTrackingSymbolSetsList_0Request) Limit(limit int32) ApiEnvironmentsErrorTrackingSymbolSetsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsErrorTrackingSymbolSetsList_0Request) Offset(offset int32) ApiEnvironmentsErrorTrackingSymbolSetsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsList_0Request) Execute() (*PaginatedErrorTrackingSymbolSetList, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsList_101Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsList_0 Method for EnvironmentsErrorTrackingSymbolSetsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsList_101(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsList_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedErrorTrackingSymbolSetList
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsList_101Execute(r ApiEnvironmentsErrorTrackingSymbolSetsList_0Request) (*PaginatedErrorTrackingSymbolSetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedErrorTrackingSymbolSetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsList_101")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	id2 *string
	ref *string
	teamId *int32
	createdAt *time.Time
	storagePtr *string
	failureReason *string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest) Id2(id2 string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest {
	r.id2 = &id2
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest) Ref(ref string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest {
	r.ref = &ref
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest) TeamId(teamId int32) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest {
	r.teamId = &teamId
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest) StoragePtr(storagePtr string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest {
	r.storagePtr = &storagePtr
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest) FailureReason(failureReason string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest {
	r.failureReason = &failureReason
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest) Execute() (*ErrorTrackingSymbolSet, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsPartialUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsPartialUpdate Method for EnvironmentsErrorTrackingSymbolSetsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSymbolSet
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsPartialUpdateExecute(r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdateRequest) (*ErrorTrackingSymbolSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSymbolSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ref", r.ref, "", "")
	}
	if r.teamId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "team_id", r.teamId, "", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	}
	if r.storagePtr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "storage_ptr", r.storagePtr, "", "")
	}
	if r.failureReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "failure_reason", r.failureReason, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	id2 *string
	ref *string
	teamId *int32
	createdAt *time.Time
	storagePtr *string
	failureReason *string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request) Id2(id2 string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request {
	r.id2 = &id2
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request) Ref(ref string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request {
	r.ref = &ref
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request) TeamId(teamId int32) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request {
	r.teamId = &teamId
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request) StoragePtr(storagePtr string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request {
	r.storagePtr = &storagePtr
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request) FailureReason(failureReason string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request {
	r.failureReason = &failureReason
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request) Execute() (*ErrorTrackingSymbolSet, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsPartialUpdate_102Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsPartialUpdate_0 Method for EnvironmentsErrorTrackingSymbolSetsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsPartialUpdate_102(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSymbolSet
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsPartialUpdate_102Execute(r ApiEnvironmentsErrorTrackingSymbolSetsPartialUpdate_0Request) (*ErrorTrackingSymbolSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSymbolSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsPartialUpdate_102")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	}
	if r.ref != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "ref", r.ref, "", "")
	}
	if r.teamId != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "team_id", r.teamId, "", "")
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	}
	if r.storagePtr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "storage_ptr", r.storagePtr, "", "")
	}
	if r.failureReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "failure_reason", r.failureReason, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsRetrieveRequest) Execute() (*ErrorTrackingSymbolSet, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsRetrieveExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsRetrieve Method for EnvironmentsErrorTrackingSymbolSetsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsRetrieveRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSymbolSet
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsRetrieveExecute(r ApiEnvironmentsErrorTrackingSymbolSetsRetrieveRequest) (*ErrorTrackingSymbolSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSymbolSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsRetrieve_0Request) Execute() (*ErrorTrackingSymbolSet, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsRetrieve_103Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsRetrieve_0 Method for EnvironmentsErrorTrackingSymbolSetsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsRetrieve_103(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsRetrieve_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSymbolSet
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsRetrieve_103Execute(r ApiEnvironmentsErrorTrackingSymbolSetsRetrieve_0Request) (*ErrorTrackingSymbolSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSymbolSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsRetrieve_103")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	id *string
	ref *string
	teamId *int32
	createdAt *time.Time
	storagePtr *string
	failureReason *string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest) Id(id string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest {
	r.id = &id
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest) Ref(ref string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest {
	r.ref = &ref
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest) TeamId(teamId int32) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest {
	r.teamId = &teamId
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest) StoragePtr(storagePtr string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest {
	r.storagePtr = &storagePtr
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest) FailureReason(failureReason string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest {
	r.failureReason = &failureReason
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsStartUploadCreateExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsStartUploadCreate Method for EnvironmentsErrorTrackingSymbolSetsStartUploadCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsStartUploadCreate(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsStartUploadCreateExecute(r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsStartUploadCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/start_upload/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}
	if r.ref == nil {
		return nil, reportError("ref is required and must be specified")
	}
	if r.teamId == nil {
		return nil, reportError("teamId is required and must be specified")
	}
	if r.createdAt == nil {
		return nil, reportError("createdAt is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ref", r.ref, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "team_id", r.teamId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.storagePtr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "storage_ptr", r.storagePtr, "", "")
	}
	if r.failureReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "failure_reason", r.failureReason, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	id *string
	ref *string
	teamId *int32
	createdAt *time.Time
	storagePtr *string
	failureReason *string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request) Id(id string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request {
	r.id = &id
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request) Ref(ref string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request {
	r.ref = &ref
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request) TeamId(teamId int32) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request {
	r.teamId = &teamId
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request) StoragePtr(storagePtr string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request {
	r.storagePtr = &storagePtr
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request) FailureReason(failureReason string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request {
	r.failureReason = &failureReason
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsStartUploadCreate_104Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0 Method for EnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsStartUploadCreate_104(ctx context.Context, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsStartUploadCreate_104Execute(r ApiEnvironmentsErrorTrackingSymbolSetsStartUploadCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsStartUploadCreate_104")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/start_upload/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}
	if r.ref == nil {
		return nil, reportError("ref is required and must be specified")
	}
	if r.teamId == nil {
		return nil, reportError("teamId is required and must be specified")
	}
	if r.createdAt == nil {
		return nil, reportError("createdAt is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ref", r.ref, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "team_id", r.teamId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.storagePtr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "storage_ptr", r.storagePtr, "", "")
	}
	if r.failureReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "failure_reason", r.failureReason, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	id2 *string
	ref *string
	teamId *int32
	createdAt *time.Time
	storagePtr *string
	failureReason *string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest) Id2(id2 string) ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest {
	r.id2 = &id2
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest) Ref(ref string) ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest {
	r.ref = &ref
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest) TeamId(teamId int32) ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest {
	r.teamId = &teamId
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest) StoragePtr(storagePtr string) ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest {
	r.storagePtr = &storagePtr
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest) FailureReason(failureReason string) ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest {
	r.failureReason = &failureReason
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest) Execute() (*ErrorTrackingSymbolSet, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsUpdateExecute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsUpdate Method for EnvironmentsErrorTrackingSymbolSetsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest {
	return ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSymbolSet
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsUpdateExecute(r ApiEnvironmentsErrorTrackingSymbolSetsUpdateRequest) (*ErrorTrackingSymbolSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSymbolSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id2 == nil {
		return localVarReturnValue, nil, reportError("id2 is required and must be specified")
	}
	if r.ref == nil {
		return localVarReturnValue, nil, reportError("ref is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}
	if r.createdAt == nil {
		return localVarReturnValue, nil, reportError("createdAt is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ref", r.ref, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "team_id", r.teamId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.storagePtr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "storage_ptr", r.storagePtr, "", "")
	}
	if r.failureReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "failure_reason", r.failureReason, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	id2 *string
	ref *string
	teamId *int32
	createdAt *time.Time
	storagePtr *string
	failureReason *string
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request) Id2(id2 string) ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request {
	r.id2 = &id2
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request) Ref(ref string) ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request {
	r.ref = &ref
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request) TeamId(teamId int32) ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request {
	r.teamId = &teamId
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request) StoragePtr(storagePtr string) ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request {
	r.storagePtr = &storagePtr
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request) FailureReason(failureReason string) ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request {
	r.failureReason = &failureReason
	return r
}

func (r ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request) Execute() (*ErrorTrackingSymbolSet, *http.Response, error) {
	return r.ApiService.EnvironmentsErrorTrackingSymbolSetsUpdate_105Execute(r)
}

/*
EnvironmentsErrorTrackingSymbolSetsUpdate_0 Method for EnvironmentsErrorTrackingSymbolSetsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this error tracking symbol set.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsUpdate_105(ctx context.Context, id string, projectId string) ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request {
	return ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ErrorTrackingSymbolSet
func (a *EnvironmentsAPIService) EnvironmentsErrorTrackingSymbolSetsUpdate_105Execute(r ApiEnvironmentsErrorTrackingSymbolSetsUpdate_0Request) (*ErrorTrackingSymbolSet, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ErrorTrackingSymbolSet
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsErrorTrackingSymbolSetsUpdate_105")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/error_tracking/symbol_sets/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id2 == nil {
		return localVarReturnValue, nil, reportError("id2 is required and must be specified")
	}
	if r.ref == nil {
		return localVarReturnValue, nil, reportError("ref is required and must be specified")
	}
	if r.teamId == nil {
		return localVarReturnValue, nil, reportError("teamId is required and must be specified")
	}
	if r.createdAt == nil {
		return localVarReturnValue, nil, reportError("createdAt is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "ref", r.ref, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "team_id", r.teamId, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.storagePtr != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "storage_ptr", r.storagePtr, "", "")
	}
	if r.failureReason != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "failure_reason", r.failureReason, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationRunsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsEvaluationRunsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationRunsCreateExecute(r)
}

/*
EnvironmentsEvaluationRunsCreate Method for EnvironmentsEvaluationRunsCreate

Create a new evaluation run.

This endpoint validates the request and enqueues a Temporal workflow
to asynchronously execute the evaluation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationRunsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationRunsCreate(ctx context.Context, projectId string) ApiEnvironmentsEvaluationRunsCreateRequest {
	return ApiEnvironmentsEvaluationRunsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEvaluationRunsCreateExecute(r ApiEnvironmentsEvaluationRunsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationRunsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluation_runs/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationRunsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsEvaluationRunsCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationRunsCreate_106Execute(r)
}

/*
EnvironmentsEvaluationRunsCreate_0 Method for EnvironmentsEvaluationRunsCreate_0

Create a new evaluation run.

This endpoint validates the request and enqueues a Temporal workflow
to asynchronously execute the evaluation.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationRunsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationRunsCreate_106(ctx context.Context, projectId string) ApiEnvironmentsEvaluationRunsCreate_0Request {
	return ApiEnvironmentsEvaluationRunsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEvaluationRunsCreate_106Execute(r ApiEnvironmentsEvaluationRunsCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationRunsCreate_106")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluation_runs/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	evaluation *Evaluation
}

func (r ApiEnvironmentsEvaluationsCreateRequest) Evaluation(evaluation Evaluation) ApiEnvironmentsEvaluationsCreateRequest {
	r.evaluation = &evaluation
	return r
}

func (r ApiEnvironmentsEvaluationsCreateRequest) Execute() (*Evaluation, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsCreateExecute(r)
}

/*
EnvironmentsEvaluationsCreate Method for EnvironmentsEvaluationsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsCreate(ctx context.Context, projectId string) ApiEnvironmentsEvaluationsCreateRequest {
	return ApiEnvironmentsEvaluationsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Evaluation
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsCreateExecute(r ApiEnvironmentsEvaluationsCreateRequest) (*Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.evaluation == nil {
		return localVarReturnValue, nil, reportError("evaluation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.evaluation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	evaluation *Evaluation
}

func (r ApiEnvironmentsEvaluationsCreate_0Request) Evaluation(evaluation Evaluation) ApiEnvironmentsEvaluationsCreate_0Request {
	r.evaluation = &evaluation
	return r
}

func (r ApiEnvironmentsEvaluationsCreate_0Request) Execute() (*Evaluation, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsCreate_107Execute(r)
}

/*
EnvironmentsEvaluationsCreate_0 Method for EnvironmentsEvaluationsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsCreate_107(ctx context.Context, projectId string) ApiEnvironmentsEvaluationsCreate_0Request {
	return ApiEnvironmentsEvaluationsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Evaluation
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsCreate_107Execute(r ApiEnvironmentsEvaluationsCreate_0Request) (*Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsCreate_107")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.evaluation == nil {
		return localVarReturnValue, nil, reportError("evaluation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.evaluation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsEvaluationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsDestroyExecute(r)
}

/*
EnvironmentsEvaluationsDestroy Method for EnvironmentsEvaluationsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this evaluation.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsEvaluationsDestroyRequest {
	return ApiEnvironmentsEvaluationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsDestroyExecute(r ApiEnvironmentsEvaluationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsEvaluationsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsDestroy_108Execute(r)
}

/*
EnvironmentsEvaluationsDestroy_0 Method for EnvironmentsEvaluationsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this evaluation.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsDestroy_108(ctx context.Context, id string, projectId string) ApiEnvironmentsEvaluationsDestroy_0Request {
	return ApiEnvironmentsEvaluationsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsDestroy_108Execute(r ApiEnvironmentsEvaluationsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsDestroy_108")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	enabled *bool
	idIn *[]string
	limit *int32
	offset *int32
	orderBy *[]string
	search *string
}

// Filter by enabled status
func (r ApiEnvironmentsEvaluationsListRequest) Enabled(enabled bool) ApiEnvironmentsEvaluationsListRequest {
	r.enabled = &enabled
	return r
}

// Multiple values may be separated by commas.
func (r ApiEnvironmentsEvaluationsListRequest) IdIn(idIn []string) ApiEnvironmentsEvaluationsListRequest {
	r.idIn = &idIn
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsEvaluationsListRequest) Limit(limit int32) ApiEnvironmentsEvaluationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsEvaluationsListRequest) Offset(offset int32) ApiEnvironmentsEvaluationsListRequest {
	r.offset = &offset
	return r
}

// Ordering  * &#x60;created_at&#x60; - Created At * &#x60;-created_at&#x60; - Created At (descending) * &#x60;updated_at&#x60; - Updated At * &#x60;-updated_at&#x60; - Updated At (descending) * &#x60;name&#x60; - Name * &#x60;-name&#x60; - Name (descending)
func (r ApiEnvironmentsEvaluationsListRequest) OrderBy(orderBy []string) ApiEnvironmentsEvaluationsListRequest {
	r.orderBy = &orderBy
	return r
}

// Search in name or description
func (r ApiEnvironmentsEvaluationsListRequest) Search(search string) ApiEnvironmentsEvaluationsListRequest {
	r.search = &search
	return r
}

func (r ApiEnvironmentsEvaluationsListRequest) Execute() (*PaginatedEvaluationList, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsListExecute(r)
}

/*
EnvironmentsEvaluationsList Method for EnvironmentsEvaluationsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsList(ctx context.Context, projectId string) ApiEnvironmentsEvaluationsListRequest {
	return ApiEnvironmentsEvaluationsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedEvaluationList
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsListExecute(r ApiEnvironmentsEvaluationsListRequest) (*PaginatedEvaluationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedEvaluationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "form", "")
	}
	if r.idIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__in", r.idIn, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "csv")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	enabled *bool
	idIn *[]string
	limit *int32
	offset *int32
	orderBy *[]string
	search *string
}

// Filter by enabled status
func (r ApiEnvironmentsEvaluationsList_0Request) Enabled(enabled bool) ApiEnvironmentsEvaluationsList_0Request {
	r.enabled = &enabled
	return r
}

// Multiple values may be separated by commas.
func (r ApiEnvironmentsEvaluationsList_0Request) IdIn(idIn []string) ApiEnvironmentsEvaluationsList_0Request {
	r.idIn = &idIn
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsEvaluationsList_0Request) Limit(limit int32) ApiEnvironmentsEvaluationsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsEvaluationsList_0Request) Offset(offset int32) ApiEnvironmentsEvaluationsList_0Request {
	r.offset = &offset
	return r
}

// Ordering  * &#x60;created_at&#x60; - Created At * &#x60;-created_at&#x60; - Created At (descending) * &#x60;updated_at&#x60; - Updated At * &#x60;-updated_at&#x60; - Updated At (descending) * &#x60;name&#x60; - Name * &#x60;-name&#x60; - Name (descending)
func (r ApiEnvironmentsEvaluationsList_0Request) OrderBy(orderBy []string) ApiEnvironmentsEvaluationsList_0Request {
	r.orderBy = &orderBy
	return r
}

// Search in name or description
func (r ApiEnvironmentsEvaluationsList_0Request) Search(search string) ApiEnvironmentsEvaluationsList_0Request {
	r.search = &search
	return r
}

func (r ApiEnvironmentsEvaluationsList_0Request) Execute() (*PaginatedEvaluationList, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsList_109Execute(r)
}

/*
EnvironmentsEvaluationsList_0 Method for EnvironmentsEvaluationsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsList_109(ctx context.Context, projectId string) ApiEnvironmentsEvaluationsList_0Request {
	return ApiEnvironmentsEvaluationsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedEvaluationList
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsList_109Execute(r ApiEnvironmentsEvaluationsList_0Request) (*PaginatedEvaluationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedEvaluationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsList_109")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "form", "")
	}
	if r.idIn != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id__in", r.idIn, "form", "csv")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.orderBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "order_by", r.orderBy, "form", "csv")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedEvaluation *PatchedEvaluation
}

func (r ApiEnvironmentsEvaluationsPartialUpdateRequest) PatchedEvaluation(patchedEvaluation PatchedEvaluation) ApiEnvironmentsEvaluationsPartialUpdateRequest {
	r.patchedEvaluation = &patchedEvaluation
	return r
}

func (r ApiEnvironmentsEvaluationsPartialUpdateRequest) Execute() (*Evaluation, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsPartialUpdateExecute(r)
}

/*
EnvironmentsEvaluationsPartialUpdate Method for EnvironmentsEvaluationsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this evaluation.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsEvaluationsPartialUpdateRequest {
	return ApiEnvironmentsEvaluationsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Evaluation
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsPartialUpdateExecute(r ApiEnvironmentsEvaluationsPartialUpdateRequest) (*Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedEvaluation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedEvaluation *PatchedEvaluation
}

func (r ApiEnvironmentsEvaluationsPartialUpdate_0Request) PatchedEvaluation(patchedEvaluation PatchedEvaluation) ApiEnvironmentsEvaluationsPartialUpdate_0Request {
	r.patchedEvaluation = &patchedEvaluation
	return r
}

func (r ApiEnvironmentsEvaluationsPartialUpdate_0Request) Execute() (*Evaluation, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsPartialUpdate_110Execute(r)
}

/*
EnvironmentsEvaluationsPartialUpdate_0 Method for EnvironmentsEvaluationsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this evaluation.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsPartialUpdate_110(ctx context.Context, id string, projectId string) ApiEnvironmentsEvaluationsPartialUpdate_0Request {
	return ApiEnvironmentsEvaluationsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Evaluation
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsPartialUpdate_110Execute(r ApiEnvironmentsEvaluationsPartialUpdate_0Request) (*Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsPartialUpdate_110")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedEvaluation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsEvaluationsRetrieveRequest) Execute() (*Evaluation, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsRetrieveExecute(r)
}

/*
EnvironmentsEvaluationsRetrieve Method for EnvironmentsEvaluationsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this evaluation.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsEvaluationsRetrieveRequest {
	return ApiEnvironmentsEvaluationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Evaluation
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsRetrieveExecute(r ApiEnvironmentsEvaluationsRetrieveRequest) (*Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsEvaluationsRetrieve_0Request) Execute() (*Evaluation, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsRetrieve_111Execute(r)
}

/*
EnvironmentsEvaluationsRetrieve_0 Method for EnvironmentsEvaluationsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this evaluation.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsRetrieve_111(ctx context.Context, id string, projectId string) ApiEnvironmentsEvaluationsRetrieve_0Request {
	return ApiEnvironmentsEvaluationsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Evaluation
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsRetrieve_111Execute(r ApiEnvironmentsEvaluationsRetrieve_0Request) (*Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsRetrieve_111")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	evaluation *Evaluation
}

func (r ApiEnvironmentsEvaluationsUpdateRequest) Evaluation(evaluation Evaluation) ApiEnvironmentsEvaluationsUpdateRequest {
	r.evaluation = &evaluation
	return r
}

func (r ApiEnvironmentsEvaluationsUpdateRequest) Execute() (*Evaluation, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsUpdateExecute(r)
}

/*
EnvironmentsEvaluationsUpdate Method for EnvironmentsEvaluationsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this evaluation.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsEvaluationsUpdateRequest {
	return ApiEnvironmentsEvaluationsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Evaluation
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsUpdateExecute(r ApiEnvironmentsEvaluationsUpdateRequest) (*Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.evaluation == nil {
		return localVarReturnValue, nil, reportError("evaluation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.evaluation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEvaluationsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	evaluation *Evaluation
}

func (r ApiEnvironmentsEvaluationsUpdate_0Request) Evaluation(evaluation Evaluation) ApiEnvironmentsEvaluationsUpdate_0Request {
	r.evaluation = &evaluation
	return r
}

func (r ApiEnvironmentsEvaluationsUpdate_0Request) Execute() (*Evaluation, *http.Response, error) {
	return r.ApiService.EnvironmentsEvaluationsUpdate_112Execute(r)
}

/*
EnvironmentsEvaluationsUpdate_0 Method for EnvironmentsEvaluationsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this evaluation.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEvaluationsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsUpdate_112(ctx context.Context, id string, projectId string) ApiEnvironmentsEvaluationsUpdate_0Request {
	return ApiEnvironmentsEvaluationsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Evaluation
func (a *EnvironmentsAPIService) EnvironmentsEvaluationsUpdate_112Execute(r ApiEnvironmentsEvaluationsUpdate_0Request) (*Evaluation, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Evaluation
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEvaluationsUpdate_112")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/evaluations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.evaluation == nil {
		return localVarReturnValue, nil, reportError("evaluation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.evaluation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEventIngestionRestrictionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsEventIngestionRestrictionsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEventIngestionRestrictionsRetrieveExecute(r)
}

/*
EnvironmentsEventIngestionRestrictionsRetrieve Method for EnvironmentsEventIngestionRestrictionsRetrieve

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEventIngestionRestrictionsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEventIngestionRestrictionsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsEventIngestionRestrictionsRetrieveRequest {
	return ApiEnvironmentsEventIngestionRestrictionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEventIngestionRestrictionsRetrieveExecute(r ApiEnvironmentsEventIngestionRestrictionsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEventIngestionRestrictionsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/event_ingestion_restrictions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEventsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	after *time.Time
	before *time.Time
	distinctId *int32
	event *string
	format *string
	limit *int32
	offset *int32
	personId *int32
	properties *[]Property
	select_ *[]string
	where *[]string
}

// Only return events with a timestamp after this time.
func (r ApiEnvironmentsEventsListRequest) After(after time.Time) ApiEnvironmentsEventsListRequest {
	r.after = &after
	return r
}

// Only return events with a timestamp before this time.
func (r ApiEnvironmentsEventsListRequest) Before(before time.Time) ApiEnvironmentsEventsListRequest {
	r.before = &before
	return r
}

// Filter list by distinct id.
func (r ApiEnvironmentsEventsListRequest) DistinctId(distinctId int32) ApiEnvironmentsEventsListRequest {
	r.distinctId = &distinctId
	return r
}

// Filter list by event. For example &#x60;user sign up&#x60; or &#x60;$pageview&#x60;.
func (r ApiEnvironmentsEventsListRequest) Event(event string) ApiEnvironmentsEventsListRequest {
	r.event = &event
	return r
}

func (r ApiEnvironmentsEventsListRequest) Format(format string) ApiEnvironmentsEventsListRequest {
	r.format = &format
	return r
}

// The maximum number of results to return
func (r ApiEnvironmentsEventsListRequest) Limit(limit int32) ApiEnvironmentsEventsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsEventsListRequest) Offset(offset int32) ApiEnvironmentsEventsListRequest {
	r.offset = &offset
	return r
}

// Filter list by person id.
func (r ApiEnvironmentsEventsListRequest) PersonId(personId int32) ApiEnvironmentsEventsListRequest {
	r.personId = &personId
	return r
}

// Filter events by event property, person property, cohort, groups and more.
func (r ApiEnvironmentsEventsListRequest) Properties(properties []Property) ApiEnvironmentsEventsListRequest {
	r.properties = &properties
	return r
}

// (Experimental) JSON-serialized array of HogQL expressions to return
func (r ApiEnvironmentsEventsListRequest) Select_(select_ []string) ApiEnvironmentsEventsListRequest {
	r.select_ = &select_
	return r
}

// (Experimental) JSON-serialized array of HogQL expressions that must pass
func (r ApiEnvironmentsEventsListRequest) Where(where []string) ApiEnvironmentsEventsListRequest {
	r.where = &where
	return r
}

func (r ApiEnvironmentsEventsListRequest) Execute() (*PaginatedClickhouseEventList, *http.Response, error) {
	return r.ApiService.EnvironmentsEventsListExecute(r)
}

/*
EnvironmentsEventsList Method for EnvironmentsEventsList


        This endpoint allows you to list and filter events.
        It is effectively deprecated and is kept only for backwards compatibility.
        If you ever ask about it you will be advised to not use it...
        If you want to ad-hoc list or aggregate events, use the Query endpoint instead.
        If you want to export all events or many pages of events you should use our CDP/Batch Exports products instead.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEventsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEventsList(ctx context.Context, projectId string) ApiEnvironmentsEventsListRequest {
	return ApiEnvironmentsEventsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedClickhouseEventList
func (a *EnvironmentsAPIService) EnvironmentsEventsListExecute(r ApiEnvironmentsEventsListRequest) (*PaginatedClickhouseEventList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedClickhouseEventList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEventsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/events/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.distinctId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct_id", r.distinctId, "form", "")
	}
	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.personId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "person_id", r.personId, "form", "")
	}
	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.where != nil {
		t := *r.where
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "where", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "where", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEventsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	after *time.Time
	before *time.Time
	distinctId *int32
	event *string
	format *string
	limit *int32
	offset *int32
	personId *int32
	properties *[]Property
	select_ *[]string
	where *[]string
}

// Only return events with a timestamp after this time.
func (r ApiEnvironmentsEventsList_0Request) After(after time.Time) ApiEnvironmentsEventsList_0Request {
	r.after = &after
	return r
}

// Only return events with a timestamp before this time.
func (r ApiEnvironmentsEventsList_0Request) Before(before time.Time) ApiEnvironmentsEventsList_0Request {
	r.before = &before
	return r
}

// Filter list by distinct id.
func (r ApiEnvironmentsEventsList_0Request) DistinctId(distinctId int32) ApiEnvironmentsEventsList_0Request {
	r.distinctId = &distinctId
	return r
}

// Filter list by event. For example &#x60;user sign up&#x60; or &#x60;$pageview&#x60;.
func (r ApiEnvironmentsEventsList_0Request) Event(event string) ApiEnvironmentsEventsList_0Request {
	r.event = &event
	return r
}

func (r ApiEnvironmentsEventsList_0Request) Format(format string) ApiEnvironmentsEventsList_0Request {
	r.format = &format
	return r
}

// The maximum number of results to return
func (r ApiEnvironmentsEventsList_0Request) Limit(limit int32) ApiEnvironmentsEventsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsEventsList_0Request) Offset(offset int32) ApiEnvironmentsEventsList_0Request {
	r.offset = &offset
	return r
}

// Filter list by person id.
func (r ApiEnvironmentsEventsList_0Request) PersonId(personId int32) ApiEnvironmentsEventsList_0Request {
	r.personId = &personId
	return r
}

// Filter events by event property, person property, cohort, groups and more.
func (r ApiEnvironmentsEventsList_0Request) Properties(properties []Property) ApiEnvironmentsEventsList_0Request {
	r.properties = &properties
	return r
}

// (Experimental) JSON-serialized array of HogQL expressions to return
func (r ApiEnvironmentsEventsList_0Request) Select_(select_ []string) ApiEnvironmentsEventsList_0Request {
	r.select_ = &select_
	return r
}

// (Experimental) JSON-serialized array of HogQL expressions that must pass
func (r ApiEnvironmentsEventsList_0Request) Where(where []string) ApiEnvironmentsEventsList_0Request {
	r.where = &where
	return r
}

func (r ApiEnvironmentsEventsList_0Request) Execute() (*PaginatedClickhouseEventList, *http.Response, error) {
	return r.ApiService.EnvironmentsEventsList_113Execute(r)
}

/*
EnvironmentsEventsList_0 Method for EnvironmentsEventsList_0


        This endpoint allows you to list and filter events.
        It is effectively deprecated and is kept only for backwards compatibility.
        If you ever ask about it you will be advised to not use it...
        If you want to ad-hoc list or aggregate events, use the Query endpoint instead.
        If you want to export all events or many pages of events you should use our CDP/Batch Exports products instead.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEventsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEventsList_113(ctx context.Context, projectId string) ApiEnvironmentsEventsList_0Request {
	return ApiEnvironmentsEventsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedClickhouseEventList
func (a *EnvironmentsAPIService) EnvironmentsEventsList_113Execute(r ApiEnvironmentsEventsList_0Request) (*PaginatedClickhouseEventList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedClickhouseEventList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEventsList_113")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/events/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.after != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "after", r.after, "form", "")
	}
	if r.before != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "before", r.before, "form", "")
	}
	if r.distinctId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct_id", r.distinctId, "form", "")
	}
	if r.event != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "event", r.event, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.personId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "person_id", r.personId, "form", "")
	}
	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.select_ != nil {
		t := *r.select_
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "select", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "select", t, "form", "multi")
		}
	}
	if r.where != nil {
		t := *r.where
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "where", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "where", t, "form", "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEventsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	format *string
}

func (r ApiEnvironmentsEventsRetrieveRequest) Format(format string) ApiEnvironmentsEventsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsEventsRetrieveRequest) Execute() (*ClickhouseEvent, *http.Response, error) {
	return r.ApiService.EnvironmentsEventsRetrieveExecute(r)
}

/*
EnvironmentsEventsRetrieve Method for EnvironmentsEventsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEventsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEventsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsEventsRetrieveRequest {
	return ApiEnvironmentsEventsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ClickhouseEvent
func (a *EnvironmentsAPIService) EnvironmentsEventsRetrieveExecute(r ApiEnvironmentsEventsRetrieveRequest) (*ClickhouseEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClickhouseEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEventsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/events/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEventsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	format *string
}

func (r ApiEnvironmentsEventsRetrieve_0Request) Format(format string) ApiEnvironmentsEventsRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsEventsRetrieve_0Request) Execute() (*ClickhouseEvent, *http.Response, error) {
	return r.ApiService.EnvironmentsEventsRetrieve_114Execute(r)
}

/*
EnvironmentsEventsRetrieve_0 Method for EnvironmentsEventsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEventsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEventsRetrieve_114(ctx context.Context, id string, projectId string) ApiEnvironmentsEventsRetrieve_0Request {
	return ApiEnvironmentsEventsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ClickhouseEvent
func (a *EnvironmentsAPIService) EnvironmentsEventsRetrieve_114Execute(r ApiEnvironmentsEventsRetrieve_0Request) (*ClickhouseEvent, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ClickhouseEvent
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEventsRetrieve_114")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/events/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEventsValuesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsEventsValuesRetrieveRequest) Format(format string) ApiEnvironmentsEventsValuesRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsEventsValuesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEventsValuesRetrieveExecute(r)
}

/*
EnvironmentsEventsValuesRetrieve Method for EnvironmentsEventsValuesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEventsValuesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsEventsValuesRetrieve(ctx context.Context, projectId string) ApiEnvironmentsEventsValuesRetrieveRequest {
	return ApiEnvironmentsEventsValuesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEventsValuesRetrieveExecute(r ApiEnvironmentsEventsValuesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEventsValuesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/events/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEventsValuesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsEventsValuesRetrieve_0Request) Format(format string) ApiEnvironmentsEventsValuesRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsEventsValuesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEventsValuesRetrieve_115Execute(r)
}

/*
EnvironmentsEventsValuesRetrieve_0 Method for EnvironmentsEventsValuesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEventsValuesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsEventsValuesRetrieve_115(ctx context.Context, projectId string) ApiEnvironmentsEventsValuesRetrieve_0Request {
	return ApiEnvironmentsEventsValuesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsEventsValuesRetrieve_115Execute(r ApiEnvironmentsEventsValuesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsEventsValuesRetrieve_115")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/events/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsExportsContentRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsExportsContentRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsExportsContentRetrieveExecute(r)
}

/*
EnvironmentsExportsContentRetrieve Method for EnvironmentsExportsContentRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this exported asset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsExportsContentRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsExportsContentRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsExportsContentRetrieveRequest {
	return ApiEnvironmentsExportsContentRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsExportsContentRetrieveExecute(r ApiEnvironmentsExportsContentRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsExportsContentRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/exports/{id}/content/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsExportsContentRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsExportsContentRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsExportsContentRetrieve_116Execute(r)
}

/*
EnvironmentsExportsContentRetrieve_0 Method for EnvironmentsExportsContentRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this exported asset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsExportsContentRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsExportsContentRetrieve_116(ctx context.Context, id int32, projectId string) ApiEnvironmentsExportsContentRetrieve_0Request {
	return ApiEnvironmentsExportsContentRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsExportsContentRetrieve_116Execute(r ApiEnvironmentsExportsContentRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsExportsContentRetrieve_116")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/exports/{id}/content/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsExportsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	exportedAsset *ExportedAsset
}

func (r ApiEnvironmentsExportsCreateRequest) ExportedAsset(exportedAsset ExportedAsset) ApiEnvironmentsExportsCreateRequest {
	r.exportedAsset = &exportedAsset
	return r
}

func (r ApiEnvironmentsExportsCreateRequest) Execute() (*ExportedAsset, *http.Response, error) {
	return r.ApiService.EnvironmentsExportsCreateExecute(r)
}

/*
EnvironmentsExportsCreate Method for EnvironmentsExportsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsExportsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsExportsCreate(ctx context.Context, projectId string) ApiEnvironmentsExportsCreateRequest {
	return ApiEnvironmentsExportsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ExportedAsset
func (a *EnvironmentsAPIService) EnvironmentsExportsCreateExecute(r ApiEnvironmentsExportsCreateRequest) (*ExportedAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportedAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsExportsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exportedAsset == nil {
		return localVarReturnValue, nil, reportError("exportedAsset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportedAsset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsExportsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	exportedAsset *ExportedAsset
}

func (r ApiEnvironmentsExportsCreate_0Request) ExportedAsset(exportedAsset ExportedAsset) ApiEnvironmentsExportsCreate_0Request {
	r.exportedAsset = &exportedAsset
	return r
}

func (r ApiEnvironmentsExportsCreate_0Request) Execute() (*ExportedAsset, *http.Response, error) {
	return r.ApiService.EnvironmentsExportsCreate_117Execute(r)
}

/*
EnvironmentsExportsCreate_0 Method for EnvironmentsExportsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsExportsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsExportsCreate_117(ctx context.Context, projectId string) ApiEnvironmentsExportsCreate_0Request {
	return ApiEnvironmentsExportsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ExportedAsset
func (a *EnvironmentsAPIService) EnvironmentsExportsCreate_117Execute(r ApiEnvironmentsExportsCreate_0Request) (*ExportedAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportedAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsExportsCreate_117")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.exportedAsset == nil {
		return localVarReturnValue, nil, reportError("exportedAsset is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.exportedAsset
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsExportsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsExportsListRequest) Limit(limit int32) ApiEnvironmentsExportsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsExportsListRequest) Offset(offset int32) ApiEnvironmentsExportsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsExportsListRequest) Execute() (*PaginatedExportedAssetList, *http.Response, error) {
	return r.ApiService.EnvironmentsExportsListExecute(r)
}

/*
EnvironmentsExportsList Method for EnvironmentsExportsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsExportsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsExportsList(ctx context.Context, projectId string) ApiEnvironmentsExportsListRequest {
	return ApiEnvironmentsExportsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedExportedAssetList
func (a *EnvironmentsAPIService) EnvironmentsExportsListExecute(r ApiEnvironmentsExportsListRequest) (*PaginatedExportedAssetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedExportedAssetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsExportsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsExportsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsExportsList_0Request) Limit(limit int32) ApiEnvironmentsExportsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsExportsList_0Request) Offset(offset int32) ApiEnvironmentsExportsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsExportsList_0Request) Execute() (*PaginatedExportedAssetList, *http.Response, error) {
	return r.ApiService.EnvironmentsExportsList_118Execute(r)
}

/*
EnvironmentsExportsList_0 Method for EnvironmentsExportsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsExportsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsExportsList_118(ctx context.Context, projectId string) ApiEnvironmentsExportsList_0Request {
	return ApiEnvironmentsExportsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedExportedAssetList
func (a *EnvironmentsAPIService) EnvironmentsExportsList_118Execute(r ApiEnvironmentsExportsList_0Request) (*PaginatedExportedAssetList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedExportedAssetList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsExportsList_118")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsExportsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsExportsRetrieveRequest) Execute() (*ExportedAsset, *http.Response, error) {
	return r.ApiService.EnvironmentsExportsRetrieveExecute(r)
}

/*
EnvironmentsExportsRetrieve Method for EnvironmentsExportsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this exported asset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsExportsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsExportsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsExportsRetrieveRequest {
	return ApiEnvironmentsExportsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ExportedAsset
func (a *EnvironmentsAPIService) EnvironmentsExportsRetrieveExecute(r ApiEnvironmentsExportsRetrieveRequest) (*ExportedAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportedAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsExportsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsExportsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsExportsRetrieve_0Request) Execute() (*ExportedAsset, *http.Response, error) {
	return r.ApiService.EnvironmentsExportsRetrieve_119Execute(r)
}

/*
EnvironmentsExportsRetrieve_0 Method for EnvironmentsExportsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this exported asset.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsExportsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsExportsRetrieve_119(ctx context.Context, id int32, projectId string) ApiEnvironmentsExportsRetrieve_0Request {
	return ApiEnvironmentsExportsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return ExportedAsset
func (a *EnvironmentsAPIService) EnvironmentsExportsRetrieve_119Execute(r ApiEnvironmentsExportsRetrieve_0Request) (*ExportedAsset, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ExportedAsset
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsExportsRetrieve_119")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemCountByPathCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemCountByPathCreateRequest) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemCountByPathCreateRequest {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemCountByPathCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemCountByPathCreateExecute(r)
}

/*
EnvironmentsFileSystemCountByPathCreate Method for EnvironmentsFileSystemCountByPathCreate

Get count of all files in a folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemCountByPathCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCountByPathCreate(ctx context.Context, projectId string) ApiEnvironmentsFileSystemCountByPathCreateRequest {
	return ApiEnvironmentsFileSystemCountByPathCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCountByPathCreateExecute(r ApiEnvironmentsFileSystemCountByPathCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemCountByPathCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/count_by_path/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemCountByPathCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemCountByPathCreate_0Request) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemCountByPathCreate_0Request {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemCountByPathCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemCountByPathCreate_120Execute(r)
}

/*
EnvironmentsFileSystemCountByPathCreate_0 Method for EnvironmentsFileSystemCountByPathCreate_0

Get count of all files in a folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemCountByPathCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCountByPathCreate_120(ctx context.Context, projectId string) ApiEnvironmentsFileSystemCountByPathCreate_0Request {
	return ApiEnvironmentsFileSystemCountByPathCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCountByPathCreate_120Execute(r ApiEnvironmentsFileSystemCountByPathCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemCountByPathCreate_120")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/count_by_path/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemCountCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemCountCreateRequest) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemCountCreateRequest {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemCountCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemCountCreateExecute(r)
}

/*
EnvironmentsFileSystemCountCreate Method for EnvironmentsFileSystemCountCreate

Get count of all files in a folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemCountCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCountCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemCountCreateRequest {
	return ApiEnvironmentsFileSystemCountCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCountCreateExecute(r ApiEnvironmentsFileSystemCountCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemCountCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/count/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemCountCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemCountCreate_0Request) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemCountCreate_0Request {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemCountCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemCountCreate_121Execute(r)
}

/*
EnvironmentsFileSystemCountCreate_0 Method for EnvironmentsFileSystemCountCreate_0

Get count of all files in a folder.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemCountCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCountCreate_121(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemCountCreate_0Request {
	return ApiEnvironmentsFileSystemCountCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCountCreate_121Execute(r ApiEnvironmentsFileSystemCountCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemCountCreate_121")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/count/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemCreateRequest) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemCreateRequest {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemCreateRequest) Execute() (*FileSystem, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemCreateExecute(r)
}

/*
EnvironmentsFileSystemCreate Method for EnvironmentsFileSystemCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCreate(ctx context.Context, projectId string) ApiEnvironmentsFileSystemCreateRequest {
	return ApiEnvironmentsFileSystemCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystem
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCreateExecute(r ApiEnvironmentsFileSystemCreateRequest) (*FileSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return localVarReturnValue, nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemCreate_0Request) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemCreate_0Request {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemCreate_0Request) Execute() (*FileSystem, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemCreate_122Execute(r)
}

/*
EnvironmentsFileSystemCreate_0 Method for EnvironmentsFileSystemCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCreate_122(ctx context.Context, projectId string) ApiEnvironmentsFileSystemCreate_0Request {
	return ApiEnvironmentsFileSystemCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystem
func (a *EnvironmentsAPIService) EnvironmentsFileSystemCreate_122Execute(r ApiEnvironmentsFileSystemCreate_0Request) (*FileSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemCreate_122")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return localVarReturnValue, nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsFileSystemDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemDestroyExecute(r)
}

/*
EnvironmentsFileSystemDestroy Method for EnvironmentsFileSystemDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemDestroyRequest {
	return ApiEnvironmentsFileSystemDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemDestroyExecute(r ApiEnvironmentsFileSystemDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsFileSystemDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemDestroy_123Execute(r)
}

/*
EnvironmentsFileSystemDestroy_0 Method for EnvironmentsFileSystemDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemDestroy_123(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemDestroy_0Request {
	return ApiEnvironmentsFileSystemDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemDestroy_123Execute(r ApiEnvironmentsFileSystemDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemDestroy_123")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemLinkCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemLinkCreateRequest) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemLinkCreateRequest {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemLinkCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemLinkCreateExecute(r)
}

/*
EnvironmentsFileSystemLinkCreate Method for EnvironmentsFileSystemLinkCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemLinkCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLinkCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemLinkCreateRequest {
	return ApiEnvironmentsFileSystemLinkCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLinkCreateExecute(r ApiEnvironmentsFileSystemLinkCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemLinkCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/link/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemLinkCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemLinkCreate_0Request) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemLinkCreate_0Request {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemLinkCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemLinkCreate_124Execute(r)
}

/*
EnvironmentsFileSystemLinkCreate_0 Method for EnvironmentsFileSystemLinkCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemLinkCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLinkCreate_124(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemLinkCreate_0Request {
	return ApiEnvironmentsFileSystemLinkCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLinkCreate_124Execute(r ApiEnvironmentsFileSystemLinkCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemLinkCreate_124")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/link/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
	search *string
}

// Number of results to return per page.
func (r ApiEnvironmentsFileSystemListRequest) Limit(limit int32) ApiEnvironmentsFileSystemListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsFileSystemListRequest) Offset(offset int32) ApiEnvironmentsFileSystemListRequest {
	r.offset = &offset
	return r
}

// A search term.
func (r ApiEnvironmentsFileSystemListRequest) Search(search string) ApiEnvironmentsFileSystemListRequest {
	r.search = &search
	return r
}

func (r ApiEnvironmentsFileSystemListRequest) Execute() (*PaginatedFileSystemList, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemListExecute(r)
}

/*
EnvironmentsFileSystemList Method for EnvironmentsFileSystemList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemList(ctx context.Context, projectId string) ApiEnvironmentsFileSystemListRequest {
	return ApiEnvironmentsFileSystemListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedFileSystemList
func (a *EnvironmentsAPIService) EnvironmentsFileSystemListExecute(r ApiEnvironmentsFileSystemListRequest) (*PaginatedFileSystemList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFileSystemList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
	search *string
}

// Number of results to return per page.
func (r ApiEnvironmentsFileSystemList_0Request) Limit(limit int32) ApiEnvironmentsFileSystemList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsFileSystemList_0Request) Offset(offset int32) ApiEnvironmentsFileSystemList_0Request {
	r.offset = &offset
	return r
}

// A search term.
func (r ApiEnvironmentsFileSystemList_0Request) Search(search string) ApiEnvironmentsFileSystemList_0Request {
	r.search = &search
	return r
}

func (r ApiEnvironmentsFileSystemList_0Request) Execute() (*PaginatedFileSystemList, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemList_125Execute(r)
}

/*
EnvironmentsFileSystemList_0 Method for EnvironmentsFileSystemList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemList_125(ctx context.Context, projectId string) ApiEnvironmentsFileSystemList_0Request {
	return ApiEnvironmentsFileSystemList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedFileSystemList
func (a *EnvironmentsAPIService) EnvironmentsFileSystemList_125Execute(r ApiEnvironmentsFileSystemList_0Request) (*PaginatedFileSystemList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFileSystemList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemList_125")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemLogViewCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemLogViewCreateRequest) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemLogViewCreateRequest {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemLogViewCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemLogViewCreateExecute(r)
}

/*
EnvironmentsFileSystemLogViewCreate Method for EnvironmentsFileSystemLogViewCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemLogViewCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLogViewCreate(ctx context.Context, projectId string) ApiEnvironmentsFileSystemLogViewCreateRequest {
	return ApiEnvironmentsFileSystemLogViewCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLogViewCreateExecute(r ApiEnvironmentsFileSystemLogViewCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemLogViewCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/log_view/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemLogViewCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemLogViewCreate_0Request) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemLogViewCreate_0Request {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemLogViewCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemLogViewCreate_126Execute(r)
}

/*
EnvironmentsFileSystemLogViewCreate_0 Method for EnvironmentsFileSystemLogViewCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemLogViewCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLogViewCreate_126(ctx context.Context, projectId string) ApiEnvironmentsFileSystemLogViewCreate_0Request {
	return ApiEnvironmentsFileSystemLogViewCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLogViewCreate_126Execute(r ApiEnvironmentsFileSystemLogViewCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemLogViewCreate_126")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/log_view/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemLogViewRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsFileSystemLogViewRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemLogViewRetrieveExecute(r)
}

/*
EnvironmentsFileSystemLogViewRetrieve Method for EnvironmentsFileSystemLogViewRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemLogViewRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLogViewRetrieve(ctx context.Context, projectId string) ApiEnvironmentsFileSystemLogViewRetrieveRequest {
	return ApiEnvironmentsFileSystemLogViewRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLogViewRetrieveExecute(r ApiEnvironmentsFileSystemLogViewRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemLogViewRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/log_view/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemLogViewRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsFileSystemLogViewRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemLogViewRetrieve_127Execute(r)
}

/*
EnvironmentsFileSystemLogViewRetrieve_0 Method for EnvironmentsFileSystemLogViewRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemLogViewRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLogViewRetrieve_127(ctx context.Context, projectId string) ApiEnvironmentsFileSystemLogViewRetrieve_0Request {
	return ApiEnvironmentsFileSystemLogViewRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemLogViewRetrieve_127Execute(r ApiEnvironmentsFileSystemLogViewRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemLogViewRetrieve_127")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/log_view/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemMoveCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemMoveCreateRequest) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemMoveCreateRequest {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemMoveCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemMoveCreateExecute(r)
}

/*
EnvironmentsFileSystemMoveCreate Method for EnvironmentsFileSystemMoveCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemMoveCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemMoveCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemMoveCreateRequest {
	return ApiEnvironmentsFileSystemMoveCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemMoveCreateExecute(r ApiEnvironmentsFileSystemMoveCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemMoveCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/move/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemMoveCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemMoveCreate_0Request) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemMoveCreate_0Request {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemMoveCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemMoveCreate_128Execute(r)
}

/*
EnvironmentsFileSystemMoveCreate_0 Method for EnvironmentsFileSystemMoveCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemMoveCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemMoveCreate_128(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemMoveCreate_0Request {
	return ApiEnvironmentsFileSystemMoveCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemMoveCreate_128Execute(r ApiEnvironmentsFileSystemMoveCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemMoveCreate_128")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/move/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedFileSystem *PatchedFileSystem
}

func (r ApiEnvironmentsFileSystemPartialUpdateRequest) PatchedFileSystem(patchedFileSystem PatchedFileSystem) ApiEnvironmentsFileSystemPartialUpdateRequest {
	r.patchedFileSystem = &patchedFileSystem
	return r
}

func (r ApiEnvironmentsFileSystemPartialUpdateRequest) Execute() (*FileSystem, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemPartialUpdateExecute(r)
}

/*
EnvironmentsFileSystemPartialUpdate Method for EnvironmentsFileSystemPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemPartialUpdateRequest {
	return ApiEnvironmentsFileSystemPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystem
func (a *EnvironmentsAPIService) EnvironmentsFileSystemPartialUpdateExecute(r ApiEnvironmentsFileSystemPartialUpdateRequest) (*FileSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedFileSystem *PatchedFileSystem
}

func (r ApiEnvironmentsFileSystemPartialUpdate_0Request) PatchedFileSystem(patchedFileSystem PatchedFileSystem) ApiEnvironmentsFileSystemPartialUpdate_0Request {
	r.patchedFileSystem = &patchedFileSystem
	return r
}

func (r ApiEnvironmentsFileSystemPartialUpdate_0Request) Execute() (*FileSystem, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemPartialUpdate_129Execute(r)
}

/*
EnvironmentsFileSystemPartialUpdate_0 Method for EnvironmentsFileSystemPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemPartialUpdate_129(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemPartialUpdate_0Request {
	return ApiEnvironmentsFileSystemPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystem
func (a *EnvironmentsAPIService) EnvironmentsFileSystemPartialUpdate_129Execute(r ApiEnvironmentsFileSystemPartialUpdate_0Request) (*FileSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemPartialUpdate_129")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsFileSystemRetrieveRequest) Execute() (*FileSystem, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemRetrieveExecute(r)
}

/*
EnvironmentsFileSystemRetrieve Method for EnvironmentsFileSystemRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemRetrieveRequest {
	return ApiEnvironmentsFileSystemRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystem
func (a *EnvironmentsAPIService) EnvironmentsFileSystemRetrieveExecute(r ApiEnvironmentsFileSystemRetrieveRequest) (*FileSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsFileSystemRetrieve_0Request) Execute() (*FileSystem, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemRetrieve_130Execute(r)
}

/*
EnvironmentsFileSystemRetrieve_0 Method for EnvironmentsFileSystemRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemRetrieve_130(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemRetrieve_0Request {
	return ApiEnvironmentsFileSystemRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystem
func (a *EnvironmentsAPIService) EnvironmentsFileSystemRetrieve_130Execute(r ApiEnvironmentsFileSystemRetrieve_0Request) (*FileSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemRetrieve_130")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	fileSystemShortcut *FileSystemShortcut
}

func (r ApiEnvironmentsFileSystemShortcutCreateRequest) FileSystemShortcut(fileSystemShortcut FileSystemShortcut) ApiEnvironmentsFileSystemShortcutCreateRequest {
	r.fileSystemShortcut = &fileSystemShortcut
	return r
}

func (r ApiEnvironmentsFileSystemShortcutCreateRequest) Execute() (*FileSystemShortcut, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutCreateExecute(r)
}

/*
EnvironmentsFileSystemShortcutCreate Method for EnvironmentsFileSystemShortcutCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutCreate(ctx context.Context, projectId string) ApiEnvironmentsFileSystemShortcutCreateRequest {
	return ApiEnvironmentsFileSystemShortcutCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystemShortcut
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutCreateExecute(r ApiEnvironmentsFileSystemShortcutCreateRequest) (*FileSystemShortcut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystemShortcut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystemShortcut == nil {
		return localVarReturnValue, nil, reportError("fileSystemShortcut is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystemShortcut
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	fileSystemShortcut *FileSystemShortcut
}

func (r ApiEnvironmentsFileSystemShortcutCreate_0Request) FileSystemShortcut(fileSystemShortcut FileSystemShortcut) ApiEnvironmentsFileSystemShortcutCreate_0Request {
	r.fileSystemShortcut = &fileSystemShortcut
	return r
}

func (r ApiEnvironmentsFileSystemShortcutCreate_0Request) Execute() (*FileSystemShortcut, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutCreate_131Execute(r)
}

/*
EnvironmentsFileSystemShortcutCreate_0 Method for EnvironmentsFileSystemShortcutCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutCreate_131(ctx context.Context, projectId string) ApiEnvironmentsFileSystemShortcutCreate_0Request {
	return ApiEnvironmentsFileSystemShortcutCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystemShortcut
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutCreate_131Execute(r ApiEnvironmentsFileSystemShortcutCreate_0Request) (*FileSystemShortcut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystemShortcut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutCreate_131")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystemShortcut == nil {
		return localVarReturnValue, nil, reportError("fileSystemShortcut is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystemShortcut
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsFileSystemShortcutDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutDestroyExecute(r)
}

/*
EnvironmentsFileSystemShortcutDestroy Method for EnvironmentsFileSystemShortcutDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system shortcut.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemShortcutDestroyRequest {
	return ApiEnvironmentsFileSystemShortcutDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutDestroyExecute(r ApiEnvironmentsFileSystemShortcutDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsFileSystemShortcutDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutDestroy_132Execute(r)
}

/*
EnvironmentsFileSystemShortcutDestroy_0 Method for EnvironmentsFileSystemShortcutDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system shortcut.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutDestroy_132(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemShortcutDestroy_0Request {
	return ApiEnvironmentsFileSystemShortcutDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutDestroy_132Execute(r ApiEnvironmentsFileSystemShortcutDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutDestroy_132")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsFileSystemShortcutListRequest) Limit(limit int32) ApiEnvironmentsFileSystemShortcutListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsFileSystemShortcutListRequest) Offset(offset int32) ApiEnvironmentsFileSystemShortcutListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsFileSystemShortcutListRequest) Execute() (*PaginatedFileSystemShortcutList, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutListExecute(r)
}

/*
EnvironmentsFileSystemShortcutList Method for EnvironmentsFileSystemShortcutList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutList(ctx context.Context, projectId string) ApiEnvironmentsFileSystemShortcutListRequest {
	return ApiEnvironmentsFileSystemShortcutListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedFileSystemShortcutList
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutListExecute(r ApiEnvironmentsFileSystemShortcutListRequest) (*PaginatedFileSystemShortcutList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFileSystemShortcutList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsFileSystemShortcutList_0Request) Limit(limit int32) ApiEnvironmentsFileSystemShortcutList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsFileSystemShortcutList_0Request) Offset(offset int32) ApiEnvironmentsFileSystemShortcutList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsFileSystemShortcutList_0Request) Execute() (*PaginatedFileSystemShortcutList, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutList_133Execute(r)
}

/*
EnvironmentsFileSystemShortcutList_0 Method for EnvironmentsFileSystemShortcutList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutList_133(ctx context.Context, projectId string) ApiEnvironmentsFileSystemShortcutList_0Request {
	return ApiEnvironmentsFileSystemShortcutList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedFileSystemShortcutList
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutList_133Execute(r ApiEnvironmentsFileSystemShortcutList_0Request) (*PaginatedFileSystemShortcutList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedFileSystemShortcutList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutList_133")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedFileSystemShortcut *PatchedFileSystemShortcut
}

func (r ApiEnvironmentsFileSystemShortcutPartialUpdateRequest) PatchedFileSystemShortcut(patchedFileSystemShortcut PatchedFileSystemShortcut) ApiEnvironmentsFileSystemShortcutPartialUpdateRequest {
	r.patchedFileSystemShortcut = &patchedFileSystemShortcut
	return r
}

func (r ApiEnvironmentsFileSystemShortcutPartialUpdateRequest) Execute() (*FileSystemShortcut, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutPartialUpdateExecute(r)
}

/*
EnvironmentsFileSystemShortcutPartialUpdate Method for EnvironmentsFileSystemShortcutPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system shortcut.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemShortcutPartialUpdateRequest {
	return ApiEnvironmentsFileSystemShortcutPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystemShortcut
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutPartialUpdateExecute(r ApiEnvironmentsFileSystemShortcutPartialUpdateRequest) (*FileSystemShortcut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystemShortcut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFileSystemShortcut
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedFileSystemShortcut *PatchedFileSystemShortcut
}

func (r ApiEnvironmentsFileSystemShortcutPartialUpdate_0Request) PatchedFileSystemShortcut(patchedFileSystemShortcut PatchedFileSystemShortcut) ApiEnvironmentsFileSystemShortcutPartialUpdate_0Request {
	r.patchedFileSystemShortcut = &patchedFileSystemShortcut
	return r
}

func (r ApiEnvironmentsFileSystemShortcutPartialUpdate_0Request) Execute() (*FileSystemShortcut, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutPartialUpdate_134Execute(r)
}

/*
EnvironmentsFileSystemShortcutPartialUpdate_0 Method for EnvironmentsFileSystemShortcutPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system shortcut.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutPartialUpdate_134(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemShortcutPartialUpdate_0Request {
	return ApiEnvironmentsFileSystemShortcutPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystemShortcut
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutPartialUpdate_134Execute(r ApiEnvironmentsFileSystemShortcutPartialUpdate_0Request) (*FileSystemShortcut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystemShortcut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutPartialUpdate_134")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedFileSystemShortcut
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsFileSystemShortcutRetrieveRequest) Execute() (*FileSystemShortcut, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutRetrieveExecute(r)
}

/*
EnvironmentsFileSystemShortcutRetrieve Method for EnvironmentsFileSystemShortcutRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system shortcut.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemShortcutRetrieveRequest {
	return ApiEnvironmentsFileSystemShortcutRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystemShortcut
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutRetrieveExecute(r ApiEnvironmentsFileSystemShortcutRetrieveRequest) (*FileSystemShortcut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystemShortcut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsFileSystemShortcutRetrieve_0Request) Execute() (*FileSystemShortcut, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutRetrieve_135Execute(r)
}

/*
EnvironmentsFileSystemShortcutRetrieve_0 Method for EnvironmentsFileSystemShortcutRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system shortcut.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutRetrieve_135(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemShortcutRetrieve_0Request {
	return ApiEnvironmentsFileSystemShortcutRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystemShortcut
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutRetrieve_135Execute(r ApiEnvironmentsFileSystemShortcutRetrieve_0Request) (*FileSystemShortcut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystemShortcut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutRetrieve_135")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystemShortcut *FileSystemShortcut
}

func (r ApiEnvironmentsFileSystemShortcutUpdateRequest) FileSystemShortcut(fileSystemShortcut FileSystemShortcut) ApiEnvironmentsFileSystemShortcutUpdateRequest {
	r.fileSystemShortcut = &fileSystemShortcut
	return r
}

func (r ApiEnvironmentsFileSystemShortcutUpdateRequest) Execute() (*FileSystemShortcut, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutUpdateExecute(r)
}

/*
EnvironmentsFileSystemShortcutUpdate Method for EnvironmentsFileSystemShortcutUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system shortcut.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemShortcutUpdateRequest {
	return ApiEnvironmentsFileSystemShortcutUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystemShortcut
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutUpdateExecute(r ApiEnvironmentsFileSystemShortcutUpdateRequest) (*FileSystemShortcut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystemShortcut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystemShortcut == nil {
		return localVarReturnValue, nil, reportError("fileSystemShortcut is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystemShortcut
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemShortcutUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystemShortcut *FileSystemShortcut
}

func (r ApiEnvironmentsFileSystemShortcutUpdate_0Request) FileSystemShortcut(fileSystemShortcut FileSystemShortcut) ApiEnvironmentsFileSystemShortcutUpdate_0Request {
	r.fileSystemShortcut = &fileSystemShortcut
	return r
}

func (r ApiEnvironmentsFileSystemShortcutUpdate_0Request) Execute() (*FileSystemShortcut, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemShortcutUpdate_136Execute(r)
}

/*
EnvironmentsFileSystemShortcutUpdate_0 Method for EnvironmentsFileSystemShortcutUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system shortcut.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemShortcutUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutUpdate_136(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemShortcutUpdate_0Request {
	return ApiEnvironmentsFileSystemShortcutUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystemShortcut
func (a *EnvironmentsAPIService) EnvironmentsFileSystemShortcutUpdate_136Execute(r ApiEnvironmentsFileSystemShortcutUpdate_0Request) (*FileSystemShortcut, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystemShortcut
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemShortcutUpdate_136")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system_shortcut/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystemShortcut == nil {
		return localVarReturnValue, nil, reportError("fileSystemShortcut is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystemShortcut
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemUnfiledRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsFileSystemUnfiledRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemUnfiledRetrieveExecute(r)
}

/*
EnvironmentsFileSystemUnfiledRetrieve Method for EnvironmentsFileSystemUnfiledRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemUnfiledRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemUnfiledRetrieve(ctx context.Context, projectId string) ApiEnvironmentsFileSystemUnfiledRetrieveRequest {
	return ApiEnvironmentsFileSystemUnfiledRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemUnfiledRetrieveExecute(r ApiEnvironmentsFileSystemUnfiledRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemUnfiledRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/unfiled/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemUnfiledRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsFileSystemUnfiledRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemUnfiledRetrieve_137Execute(r)
}

/*
EnvironmentsFileSystemUnfiledRetrieve_0 Method for EnvironmentsFileSystemUnfiledRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemUnfiledRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemUnfiledRetrieve_137(ctx context.Context, projectId string) ApiEnvironmentsFileSystemUnfiledRetrieve_0Request {
	return ApiEnvironmentsFileSystemUnfiledRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsFileSystemUnfiledRetrieve_137Execute(r ApiEnvironmentsFileSystemUnfiledRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemUnfiledRetrieve_137")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/unfiled/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemUpdateRequest) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemUpdateRequest {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemUpdateRequest) Execute() (*FileSystem, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemUpdateExecute(r)
}

/*
EnvironmentsFileSystemUpdate Method for EnvironmentsFileSystemUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemUpdateRequest {
	return ApiEnvironmentsFileSystemUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystem
func (a *EnvironmentsAPIService) EnvironmentsFileSystemUpdateExecute(r ApiEnvironmentsFileSystemUpdateRequest) (*FileSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return localVarReturnValue, nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsFileSystemUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	fileSystem *FileSystem
}

func (r ApiEnvironmentsFileSystemUpdate_0Request) FileSystem(fileSystem FileSystem) ApiEnvironmentsFileSystemUpdate_0Request {
	r.fileSystem = &fileSystem
	return r
}

func (r ApiEnvironmentsFileSystemUpdate_0Request) Execute() (*FileSystem, *http.Response, error) {
	return r.ApiService.EnvironmentsFileSystemUpdate_138Execute(r)
}

/*
EnvironmentsFileSystemUpdate_0 Method for EnvironmentsFileSystemUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this file system.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsFileSystemUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsFileSystemUpdate_138(ctx context.Context, id string, projectId string) ApiEnvironmentsFileSystemUpdate_0Request {
	return ApiEnvironmentsFileSystemUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return FileSystem
func (a *EnvironmentsAPIService) EnvironmentsFileSystemUpdate_138Execute(r ApiEnvironmentsFileSystemUpdate_0Request) (*FileSystem, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *FileSystem
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsFileSystemUpdate_138")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/file_system/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.fileSystem == nil {
		return localVarReturnValue, nil, reportError("fileSystem is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.fileSystem
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsActivityRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupTypeIndex *int32
	id *string
	projectId string
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsActivityRetrieveRequest) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsActivityRetrieveRequest {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

// Specify the id of the user to find groups for
func (r ApiEnvironmentsGroupsActivityRetrieveRequest) Id(id string) ApiEnvironmentsGroupsActivityRetrieveRequest {
	r.id = &id
	return r
}

func (r ApiEnvironmentsGroupsActivityRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsActivityRetrieveExecute(r)
}

/*
EnvironmentsGroupsActivityRetrieve Method for EnvironmentsGroupsActivityRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsActivityRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsActivityRetrieve(ctx context.Context, projectId string) ApiEnvironmentsGroupsActivityRetrieveRequest {
	return ApiEnvironmentsGroupsActivityRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsActivityRetrieveExecute(r ApiEnvironmentsGroupsActivityRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsActivityRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsActivityRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupTypeIndex *int32
	id *string
	projectId string
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsActivityRetrieve_0Request) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsActivityRetrieve_0Request {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

// Specify the id of the user to find groups for
func (r ApiEnvironmentsGroupsActivityRetrieve_0Request) Id(id string) ApiEnvironmentsGroupsActivityRetrieve_0Request {
	r.id = &id
	return r
}

func (r ApiEnvironmentsGroupsActivityRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsActivityRetrieve_139Execute(r)
}

/*
EnvironmentsGroupsActivityRetrieve_0 Method for EnvironmentsGroupsActivityRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsActivityRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsActivityRetrieve_139(ctx context.Context, projectId string) ApiEnvironmentsGroupsActivityRetrieve_0Request {
	return ApiEnvironmentsGroupsActivityRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsActivityRetrieve_139Execute(r ApiEnvironmentsGroupsActivityRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsActivityRetrieve_139")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	createGroup *CreateGroup
}

func (r ApiEnvironmentsGroupsCreateRequest) CreateGroup(createGroup CreateGroup) ApiEnvironmentsGroupsCreateRequest {
	r.createGroup = &createGroup
	return r
}

func (r ApiEnvironmentsGroupsCreateRequest) Execute() (*Group, *http.Response, error) {
	return r.ApiService.EnvironmentsGroupsCreateExecute(r)
}

/*
EnvironmentsGroupsCreate Method for EnvironmentsGroupsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsCreate(ctx context.Context, projectId string) ApiEnvironmentsGroupsCreateRequest {
	return ApiEnvironmentsGroupsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Group
func (a *EnvironmentsAPIService) EnvironmentsGroupsCreateExecute(r ApiEnvironmentsGroupsCreateRequest) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createGroup == nil {
		return localVarReturnValue, nil, reportError("createGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	createGroup *CreateGroup
}

func (r ApiEnvironmentsGroupsCreate_0Request) CreateGroup(createGroup CreateGroup) ApiEnvironmentsGroupsCreate_0Request {
	r.createGroup = &createGroup
	return r
}

func (r ApiEnvironmentsGroupsCreate_0Request) Execute() (*Group, *http.Response, error) {
	return r.ApiService.EnvironmentsGroupsCreate_140Execute(r)
}

/*
EnvironmentsGroupsCreate_0 Method for EnvironmentsGroupsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsCreate_140(ctx context.Context, projectId string) ApiEnvironmentsGroupsCreate_0Request {
	return ApiEnvironmentsGroupsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Group
func (a *EnvironmentsAPIService) EnvironmentsGroupsCreate_140Execute(r ApiEnvironmentsGroupsCreate_0Request) (*Group, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Group
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsCreate_140")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.createGroup == nil {
		return localVarReturnValue, nil, reportError("createGroup is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.createGroup
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsDeletePropertyCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupKey *string
	groupTypeIndex *int32
	projectId string
	group *Group
}

// Specify the key of the group to find
func (r ApiEnvironmentsGroupsDeletePropertyCreateRequest) GroupKey(groupKey string) ApiEnvironmentsGroupsDeletePropertyCreateRequest {
	r.groupKey = &groupKey
	return r
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsDeletePropertyCreateRequest) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsDeletePropertyCreateRequest {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

func (r ApiEnvironmentsGroupsDeletePropertyCreateRequest) Group(group Group) ApiEnvironmentsGroupsDeletePropertyCreateRequest {
	r.group = &group
	return r
}

func (r ApiEnvironmentsGroupsDeletePropertyCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsDeletePropertyCreateExecute(r)
}

/*
EnvironmentsGroupsDeletePropertyCreate Method for EnvironmentsGroupsDeletePropertyCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsDeletePropertyCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsDeletePropertyCreate(ctx context.Context, projectId string) ApiEnvironmentsGroupsDeletePropertyCreateRequest {
	return ApiEnvironmentsGroupsDeletePropertyCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsDeletePropertyCreateExecute(r ApiEnvironmentsGroupsDeletePropertyCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsDeletePropertyCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/delete_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupKey == nil {
		return nil, reportError("groupKey is required and must be specified")
	}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.group == nil {
		return nil, reportError("group is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_key", r.groupKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.group
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsDeletePropertyCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupKey *string
	groupTypeIndex *int32
	projectId string
	group *Group
}

// Specify the key of the group to find
func (r ApiEnvironmentsGroupsDeletePropertyCreate_0Request) GroupKey(groupKey string) ApiEnvironmentsGroupsDeletePropertyCreate_0Request {
	r.groupKey = &groupKey
	return r
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsDeletePropertyCreate_0Request) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsDeletePropertyCreate_0Request {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

func (r ApiEnvironmentsGroupsDeletePropertyCreate_0Request) Group(group Group) ApiEnvironmentsGroupsDeletePropertyCreate_0Request {
	r.group = &group
	return r
}

func (r ApiEnvironmentsGroupsDeletePropertyCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsDeletePropertyCreate_141Execute(r)
}

/*
EnvironmentsGroupsDeletePropertyCreate_0 Method for EnvironmentsGroupsDeletePropertyCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsDeletePropertyCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsDeletePropertyCreate_141(ctx context.Context, projectId string) ApiEnvironmentsGroupsDeletePropertyCreate_0Request {
	return ApiEnvironmentsGroupsDeletePropertyCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsDeletePropertyCreate_141Execute(r ApiEnvironmentsGroupsDeletePropertyCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsDeletePropertyCreate_141")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/delete_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupKey == nil {
		return nil, reportError("groupKey is required and must be specified")
	}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.group == nil {
		return nil, reportError("group is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_key", r.groupKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.group
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsFindRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupKey *string
	groupTypeIndex *int32
	projectId string
}

// Specify the key of the group to find
func (r ApiEnvironmentsGroupsFindRetrieveRequest) GroupKey(groupKey string) ApiEnvironmentsGroupsFindRetrieveRequest {
	r.groupKey = &groupKey
	return r
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsFindRetrieveRequest) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsFindRetrieveRequest {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

func (r ApiEnvironmentsGroupsFindRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsFindRetrieveExecute(r)
}

/*
EnvironmentsGroupsFindRetrieve Method for EnvironmentsGroupsFindRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsFindRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsFindRetrieve(ctx context.Context, projectId string) ApiEnvironmentsGroupsFindRetrieveRequest {
	return ApiEnvironmentsGroupsFindRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsFindRetrieveExecute(r ApiEnvironmentsGroupsFindRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsFindRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/find/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupKey == nil {
		return nil, reportError("groupKey is required and must be specified")
	}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_key", r.groupKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsFindRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupKey *string
	groupTypeIndex *int32
	projectId string
}

// Specify the key of the group to find
func (r ApiEnvironmentsGroupsFindRetrieve_0Request) GroupKey(groupKey string) ApiEnvironmentsGroupsFindRetrieve_0Request {
	r.groupKey = &groupKey
	return r
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsFindRetrieve_0Request) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsFindRetrieve_0Request {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

func (r ApiEnvironmentsGroupsFindRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsFindRetrieve_142Execute(r)
}

/*
EnvironmentsGroupsFindRetrieve_0 Method for EnvironmentsGroupsFindRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsFindRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsFindRetrieve_142(ctx context.Context, projectId string) ApiEnvironmentsGroupsFindRetrieve_0Request {
	return ApiEnvironmentsGroupsFindRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsFindRetrieve_142Execute(r ApiEnvironmentsGroupsFindRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsFindRetrieve_142")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/find/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupKey == nil {
		return nil, reportError("groupKey is required and must be specified")
	}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_key", r.groupKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupTypeIndex *int32
	projectId string
	search *string
	cursor *string
}

// Specify the group type to list
func (r ApiEnvironmentsGroupsListRequest) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsListRequest {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

// Search the group name
func (r ApiEnvironmentsGroupsListRequest) Search(search string) ApiEnvironmentsGroupsListRequest {
	r.search = &search
	return r
}

// The pagination cursor value.
func (r ApiEnvironmentsGroupsListRequest) Cursor(cursor string) ApiEnvironmentsGroupsListRequest {
	r.cursor = &cursor
	return r
}

func (r ApiEnvironmentsGroupsListRequest) Execute() (*PaginatedGroupList, *http.Response, error) {
	return r.ApiService.EnvironmentsGroupsListExecute(r)
}

/*
EnvironmentsGroupsList Method for EnvironmentsGroupsList

List all groups of a specific group type. You must pass ?group_type_index= in the URL. To get a list of valid group types, call /api/:project_id/groups_types/

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsList(ctx context.Context, projectId string) ApiEnvironmentsGroupsListRequest {
	return ApiEnvironmentsGroupsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedGroupList
func (a *EnvironmentsAPIService) EnvironmentsGroupsListExecute(r ApiEnvironmentsGroupsListRequest) (*PaginatedGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupTypeIndex == nil {
		return localVarReturnValue, nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.search == nil {
		return localVarReturnValue, nil, reportError("search is required and must be specified")
	}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupTypeIndex *int32
	projectId string
	search *string
	cursor *string
}

// Specify the group type to list
func (r ApiEnvironmentsGroupsList_0Request) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsList_0Request {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

// Search the group name
func (r ApiEnvironmentsGroupsList_0Request) Search(search string) ApiEnvironmentsGroupsList_0Request {
	r.search = &search
	return r
}

// The pagination cursor value.
func (r ApiEnvironmentsGroupsList_0Request) Cursor(cursor string) ApiEnvironmentsGroupsList_0Request {
	r.cursor = &cursor
	return r
}

func (r ApiEnvironmentsGroupsList_0Request) Execute() (*PaginatedGroupList, *http.Response, error) {
	return r.ApiService.EnvironmentsGroupsList_143Execute(r)
}

/*
EnvironmentsGroupsList_0 Method for EnvironmentsGroupsList_0

List all groups of a specific group type. You must pass ?group_type_index= in the URL. To get a list of valid group types, call /api/:project_id/groups_types/

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsList_143(ctx context.Context, projectId string) ApiEnvironmentsGroupsList_0Request {
	return ApiEnvironmentsGroupsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedGroupList
func (a *EnvironmentsAPIService) EnvironmentsGroupsList_143Execute(r ApiEnvironmentsGroupsList_0Request) (*PaginatedGroupList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedGroupList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsList_143")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupTypeIndex == nil {
		return localVarReturnValue, nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.search == nil {
		return localVarReturnValue, nil, reportError("search is required and must be specified")
	}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsPropertyDefinitionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsGroupsPropertyDefinitionsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsPropertyDefinitionsRetrieveExecute(r)
}

/*
EnvironmentsGroupsPropertyDefinitionsRetrieve Method for EnvironmentsGroupsPropertyDefinitionsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsPropertyDefinitionsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsPropertyDefinitionsRetrieve(ctx context.Context, projectId string) ApiEnvironmentsGroupsPropertyDefinitionsRetrieveRequest {
	return ApiEnvironmentsGroupsPropertyDefinitionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsPropertyDefinitionsRetrieveExecute(r ApiEnvironmentsGroupsPropertyDefinitionsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsPropertyDefinitionsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/property_definitions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsPropertyDefinitionsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsGroupsPropertyDefinitionsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsPropertyDefinitionsRetrieve_144Execute(r)
}

/*
EnvironmentsGroupsPropertyDefinitionsRetrieve_0 Method for EnvironmentsGroupsPropertyDefinitionsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsPropertyDefinitionsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsPropertyDefinitionsRetrieve_144(ctx context.Context, projectId string) ApiEnvironmentsGroupsPropertyDefinitionsRetrieve_0Request {
	return ApiEnvironmentsGroupsPropertyDefinitionsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsPropertyDefinitionsRetrieve_144Execute(r ApiEnvironmentsGroupsPropertyDefinitionsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsPropertyDefinitionsRetrieve_144")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/property_definitions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsPropertyValuesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsGroupsPropertyValuesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsPropertyValuesRetrieveExecute(r)
}

/*
EnvironmentsGroupsPropertyValuesRetrieve Method for EnvironmentsGroupsPropertyValuesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsPropertyValuesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsPropertyValuesRetrieve(ctx context.Context, projectId string) ApiEnvironmentsGroupsPropertyValuesRetrieveRequest {
	return ApiEnvironmentsGroupsPropertyValuesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsPropertyValuesRetrieveExecute(r ApiEnvironmentsGroupsPropertyValuesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsPropertyValuesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/property_values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsPropertyValuesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsGroupsPropertyValuesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsPropertyValuesRetrieve_145Execute(r)
}

/*
EnvironmentsGroupsPropertyValuesRetrieve_0 Method for EnvironmentsGroupsPropertyValuesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsPropertyValuesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsPropertyValuesRetrieve_145(ctx context.Context, projectId string) ApiEnvironmentsGroupsPropertyValuesRetrieve_0Request {
	return ApiEnvironmentsGroupsPropertyValuesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsPropertyValuesRetrieve_145Execute(r ApiEnvironmentsGroupsPropertyValuesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsPropertyValuesRetrieve_145")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/property_values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsRelatedRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupTypeIndex *int32
	id *string
	projectId string
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsRelatedRetrieveRequest) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsRelatedRetrieveRequest {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

// Specify the id of the user to find groups for
func (r ApiEnvironmentsGroupsRelatedRetrieveRequest) Id(id string) ApiEnvironmentsGroupsRelatedRetrieveRequest {
	r.id = &id
	return r
}

func (r ApiEnvironmentsGroupsRelatedRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsRelatedRetrieveExecute(r)
}

/*
EnvironmentsGroupsRelatedRetrieve Method for EnvironmentsGroupsRelatedRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsRelatedRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsRelatedRetrieve(ctx context.Context, projectId string) ApiEnvironmentsGroupsRelatedRetrieveRequest {
	return ApiEnvironmentsGroupsRelatedRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsRelatedRetrieveExecute(r ApiEnvironmentsGroupsRelatedRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsRelatedRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/related/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsRelatedRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupTypeIndex *int32
	id *string
	projectId string
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsRelatedRetrieve_0Request) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsRelatedRetrieve_0Request {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

// Specify the id of the user to find groups for
func (r ApiEnvironmentsGroupsRelatedRetrieve_0Request) Id(id string) ApiEnvironmentsGroupsRelatedRetrieve_0Request {
	r.id = &id
	return r
}

func (r ApiEnvironmentsGroupsRelatedRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsRelatedRetrieve_146Execute(r)
}

/*
EnvironmentsGroupsRelatedRetrieve_0 Method for EnvironmentsGroupsRelatedRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsRelatedRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsRelatedRetrieve_146(ctx context.Context, projectId string) ApiEnvironmentsGroupsRelatedRetrieve_0Request {
	return ApiEnvironmentsGroupsRelatedRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsRelatedRetrieve_146Execute(r ApiEnvironmentsGroupsRelatedRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsRelatedRetrieve_146")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/related/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsUpdatePropertyCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupKey *string
	groupTypeIndex *int32
	projectId string
	group *Group
}

// Specify the key of the group to find
func (r ApiEnvironmentsGroupsUpdatePropertyCreateRequest) GroupKey(groupKey string) ApiEnvironmentsGroupsUpdatePropertyCreateRequest {
	r.groupKey = &groupKey
	return r
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsUpdatePropertyCreateRequest) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsUpdatePropertyCreateRequest {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

func (r ApiEnvironmentsGroupsUpdatePropertyCreateRequest) Group(group Group) ApiEnvironmentsGroupsUpdatePropertyCreateRequest {
	r.group = &group
	return r
}

func (r ApiEnvironmentsGroupsUpdatePropertyCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsUpdatePropertyCreateExecute(r)
}

/*
EnvironmentsGroupsUpdatePropertyCreate Method for EnvironmentsGroupsUpdatePropertyCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsUpdatePropertyCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsUpdatePropertyCreate(ctx context.Context, projectId string) ApiEnvironmentsGroupsUpdatePropertyCreateRequest {
	return ApiEnvironmentsGroupsUpdatePropertyCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsUpdatePropertyCreateExecute(r ApiEnvironmentsGroupsUpdatePropertyCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsUpdatePropertyCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/update_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupKey == nil {
		return nil, reportError("groupKey is required and must be specified")
	}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.group == nil {
		return nil, reportError("group is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_key", r.groupKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.group
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsGroupsUpdatePropertyCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	groupKey *string
	groupTypeIndex *int32
	projectId string
	group *Group
}

// Specify the key of the group to find
func (r ApiEnvironmentsGroupsUpdatePropertyCreate_0Request) GroupKey(groupKey string) ApiEnvironmentsGroupsUpdatePropertyCreate_0Request {
	r.groupKey = &groupKey
	return r
}

// Specify the group type to find
func (r ApiEnvironmentsGroupsUpdatePropertyCreate_0Request) GroupTypeIndex(groupTypeIndex int32) ApiEnvironmentsGroupsUpdatePropertyCreate_0Request {
	r.groupTypeIndex = &groupTypeIndex
	return r
}

func (r ApiEnvironmentsGroupsUpdatePropertyCreate_0Request) Group(group Group) ApiEnvironmentsGroupsUpdatePropertyCreate_0Request {
	r.group = &group
	return r
}

func (r ApiEnvironmentsGroupsUpdatePropertyCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsGroupsUpdatePropertyCreate_147Execute(r)
}

/*
EnvironmentsGroupsUpdatePropertyCreate_0 Method for EnvironmentsGroupsUpdatePropertyCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsGroupsUpdatePropertyCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsGroupsUpdatePropertyCreate_147(ctx context.Context, projectId string) ApiEnvironmentsGroupsUpdatePropertyCreate_0Request {
	return ApiEnvironmentsGroupsUpdatePropertyCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsGroupsUpdatePropertyCreate_147Execute(r ApiEnvironmentsGroupsUpdatePropertyCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsGroupsUpdatePropertyCreate_147")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/groups/update_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.groupKey == nil {
		return nil, reportError("groupKey is required and must be specified")
	}
	if r.groupTypeIndex == nil {
		return nil, reportError("groupTypeIndex is required and must be specified")
	}
	if r.group == nil {
		return nil, reportError("group is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "group_key", r.groupKey, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "group_type_index", r.groupTypeIndex, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.group
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsBroadcastCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	hogFunction *HogFunction
}

func (r ApiEnvironmentsHogFunctionsBroadcastCreateRequest) HogFunction(hogFunction HogFunction) ApiEnvironmentsHogFunctionsBroadcastCreateRequest {
	r.hogFunction = &hogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsBroadcastCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsBroadcastCreateExecute(r)
}

/*
EnvironmentsHogFunctionsBroadcastCreate Method for EnvironmentsHogFunctionsBroadcastCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsBroadcastCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsBroadcastCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsBroadcastCreateRequest {
	return ApiEnvironmentsHogFunctionsBroadcastCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsBroadcastCreateExecute(r ApiEnvironmentsHogFunctionsBroadcastCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsBroadcastCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/broadcast/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsBroadcastCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	hogFunction *HogFunction
}

func (r ApiEnvironmentsHogFunctionsBroadcastCreate_0Request) HogFunction(hogFunction HogFunction) ApiEnvironmentsHogFunctionsBroadcastCreate_0Request {
	r.hogFunction = &hogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsBroadcastCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsBroadcastCreate_148Execute(r)
}

/*
EnvironmentsHogFunctionsBroadcastCreate_0 Method for EnvironmentsHogFunctionsBroadcastCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsBroadcastCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsBroadcastCreate_148(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsBroadcastCreate_0Request {
	return ApiEnvironmentsHogFunctionsBroadcastCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsBroadcastCreate_148Execute(r ApiEnvironmentsHogFunctionsBroadcastCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsBroadcastCreate_148")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/broadcast/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	hogFunction *HogFunction
}

func (r ApiEnvironmentsHogFunctionsCreateRequest) HogFunction(hogFunction HogFunction) ApiEnvironmentsHogFunctionsCreateRequest {
	r.hogFunction = &hogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsCreateRequest) Execute() (*HogFunction, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsCreateExecute(r)
}

/*
EnvironmentsHogFunctionsCreate Method for EnvironmentsHogFunctionsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsCreate(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsCreateRequest {
	return ApiEnvironmentsHogFunctionsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return HogFunction
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsCreateExecute(r ApiEnvironmentsHogFunctionsCreateRequest) (*HogFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HogFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	hogFunction *HogFunction
}

func (r ApiEnvironmentsHogFunctionsCreate_0Request) HogFunction(hogFunction HogFunction) ApiEnvironmentsHogFunctionsCreate_0Request {
	r.hogFunction = &hogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsCreate_0Request) Execute() (*HogFunction, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsCreate_149Execute(r)
}

/*
EnvironmentsHogFunctionsCreate_0 Method for EnvironmentsHogFunctionsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsCreate_149(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsCreate_0Request {
	return ApiEnvironmentsHogFunctionsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return HogFunction
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsCreate_149Execute(r ApiEnvironmentsHogFunctionsCreate_0Request) (*HogFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HogFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsCreate_149")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsDestroyExecute(r)
}

/*
EnvironmentsHogFunctionsDestroy Method for EnvironmentsHogFunctionsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsDestroyRequest {
	return ApiEnvironmentsHogFunctionsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsDestroyExecute(r ApiEnvironmentsHogFunctionsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsDestroy_150Execute(r)
}

/*
EnvironmentsHogFunctionsDestroy_0 Method for EnvironmentsHogFunctionsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsDestroy_150(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsDestroy_0Request {
	return ApiEnvironmentsHogFunctionsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsDestroy_150Execute(r ApiEnvironmentsHogFunctionsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsDestroy_150")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsIconRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsHogFunctionsIconRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsIconRetrieveExecute(r)
}

/*
EnvironmentsHogFunctionsIconRetrieve Method for EnvironmentsHogFunctionsIconRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsIconRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsIconRetrieve(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsIconRetrieveRequest {
	return ApiEnvironmentsHogFunctionsIconRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsIconRetrieveExecute(r ApiEnvironmentsHogFunctionsIconRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsIconRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/icon/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsIconRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsHogFunctionsIconRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsIconRetrieve_151Execute(r)
}

/*
EnvironmentsHogFunctionsIconRetrieve_0 Method for EnvironmentsHogFunctionsIconRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsIconRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsIconRetrieve_151(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsIconRetrieve_0Request {
	return ApiEnvironmentsHogFunctionsIconRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsIconRetrieve_151Execute(r ApiEnvironmentsHogFunctionsIconRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsIconRetrieve_151")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/icon/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsIconsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsHogFunctionsIconsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsIconsRetrieveExecute(r)
}

/*
EnvironmentsHogFunctionsIconsRetrieve Method for EnvironmentsHogFunctionsIconsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsIconsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsIconsRetrieve(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsIconsRetrieveRequest {
	return ApiEnvironmentsHogFunctionsIconsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsIconsRetrieveExecute(r ApiEnvironmentsHogFunctionsIconsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsIconsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/icons/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsIconsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsHogFunctionsIconsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsIconsRetrieve_152Execute(r)
}

/*
EnvironmentsHogFunctionsIconsRetrieve_0 Method for EnvironmentsHogFunctionsIconsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsIconsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsIconsRetrieve_152(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsIconsRetrieve_0Request {
	return ApiEnvironmentsHogFunctionsIconsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsIconsRetrieve_152Execute(r ApiEnvironmentsHogFunctionsIconsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsIconsRetrieve_152")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/icons/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsInvocationsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	hogFunction *HogFunction
}

func (r ApiEnvironmentsHogFunctionsInvocationsCreateRequest) HogFunction(hogFunction HogFunction) ApiEnvironmentsHogFunctionsInvocationsCreateRequest {
	r.hogFunction = &hogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsInvocationsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsInvocationsCreateExecute(r)
}

/*
EnvironmentsHogFunctionsInvocationsCreate Method for EnvironmentsHogFunctionsInvocationsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsInvocationsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsInvocationsCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsInvocationsCreateRequest {
	return ApiEnvironmentsHogFunctionsInvocationsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsInvocationsCreateExecute(r ApiEnvironmentsHogFunctionsInvocationsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsInvocationsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/invocations/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsInvocationsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	hogFunction *HogFunction
}

func (r ApiEnvironmentsHogFunctionsInvocationsCreate_0Request) HogFunction(hogFunction HogFunction) ApiEnvironmentsHogFunctionsInvocationsCreate_0Request {
	r.hogFunction = &hogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsInvocationsCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsInvocationsCreate_153Execute(r)
}

/*
EnvironmentsHogFunctionsInvocationsCreate_0 Method for EnvironmentsHogFunctionsInvocationsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsInvocationsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsInvocationsCreate_153(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsInvocationsCreate_0Request {
	return ApiEnvironmentsHogFunctionsInvocationsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsInvocationsCreate_153Execute(r ApiEnvironmentsHogFunctionsInvocationsCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsInvocationsCreate_153")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/invocations/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	createdAt *time.Time
	createdBy *int32
	enabled *bool
	id *string
	limit *int32
	offset *int32
	search *string
	type_ *[]string
	updatedAt *time.Time
}

func (r ApiEnvironmentsHogFunctionsListRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsHogFunctionsListRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsHogFunctionsListRequest) CreatedBy(createdBy int32) ApiEnvironmentsHogFunctionsListRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsHogFunctionsListRequest) Enabled(enabled bool) ApiEnvironmentsHogFunctionsListRequest {
	r.enabled = &enabled
	return r
}

func (r ApiEnvironmentsHogFunctionsListRequest) Id(id string) ApiEnvironmentsHogFunctionsListRequest {
	r.id = &id
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsHogFunctionsListRequest) Limit(limit int32) ApiEnvironmentsHogFunctionsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsHogFunctionsListRequest) Offset(offset int32) ApiEnvironmentsHogFunctionsListRequest {
	r.offset = &offset
	return r
}

// A search term.
func (r ApiEnvironmentsHogFunctionsListRequest) Search(search string) ApiEnvironmentsHogFunctionsListRequest {
	r.search = &search
	return r
}

// Multiple values may be separated by commas.
func (r ApiEnvironmentsHogFunctionsListRequest) Type_(type_ []string) ApiEnvironmentsHogFunctionsListRequest {
	r.type_ = &type_
	return r
}

func (r ApiEnvironmentsHogFunctionsListRequest) UpdatedAt(updatedAt time.Time) ApiEnvironmentsHogFunctionsListRequest {
	r.updatedAt = &updatedAt
	return r
}

func (r ApiEnvironmentsHogFunctionsListRequest) Execute() (*PaginatedHogFunctionMinimalList, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsListExecute(r)
}

/*
EnvironmentsHogFunctionsList Method for EnvironmentsHogFunctionsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsList(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsListRequest {
	return ApiEnvironmentsHogFunctionsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedHogFunctionMinimalList
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsListExecute(r ApiEnvironmentsHogFunctionsListRequest) (*PaginatedHogFunctionMinimalList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedHogFunctionMinimalList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "csv")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	createdAt *time.Time
	createdBy *int32
	enabled *bool
	id *string
	limit *int32
	offset *int32
	search *string
	type_ *[]string
	updatedAt *time.Time
}

func (r ApiEnvironmentsHogFunctionsList_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsHogFunctionsList_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsHogFunctionsList_0Request) CreatedBy(createdBy int32) ApiEnvironmentsHogFunctionsList_0Request {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsHogFunctionsList_0Request) Enabled(enabled bool) ApiEnvironmentsHogFunctionsList_0Request {
	r.enabled = &enabled
	return r
}

func (r ApiEnvironmentsHogFunctionsList_0Request) Id(id string) ApiEnvironmentsHogFunctionsList_0Request {
	r.id = &id
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsHogFunctionsList_0Request) Limit(limit int32) ApiEnvironmentsHogFunctionsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsHogFunctionsList_0Request) Offset(offset int32) ApiEnvironmentsHogFunctionsList_0Request {
	r.offset = &offset
	return r
}

// A search term.
func (r ApiEnvironmentsHogFunctionsList_0Request) Search(search string) ApiEnvironmentsHogFunctionsList_0Request {
	r.search = &search
	return r
}

// Multiple values may be separated by commas.
func (r ApiEnvironmentsHogFunctionsList_0Request) Type_(type_ []string) ApiEnvironmentsHogFunctionsList_0Request {
	r.type_ = &type_
	return r
}

func (r ApiEnvironmentsHogFunctionsList_0Request) UpdatedAt(updatedAt time.Time) ApiEnvironmentsHogFunctionsList_0Request {
	r.updatedAt = &updatedAt
	return r
}

func (r ApiEnvironmentsHogFunctionsList_0Request) Execute() (*PaginatedHogFunctionMinimalList, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsList_154Execute(r)
}

/*
EnvironmentsHogFunctionsList_0 Method for EnvironmentsHogFunctionsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsList_154(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsList_0Request {
	return ApiEnvironmentsHogFunctionsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedHogFunctionMinimalList
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsList_154Execute(r ApiEnvironmentsHogFunctionsList_0Request) (*PaginatedHogFunctionMinimalList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedHogFunctionMinimalList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsList_154")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_at", r.createdAt, "form", "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.enabled != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "enabled", r.enabled, "form", "")
	}
	if r.id != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "id", r.id, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	if r.type_ != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "form", "csv")
	}
	if r.updatedAt != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "updated_at", r.updatedAt, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsLogsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsLogsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsLogsRetrieveExecute(r)
}

/*
EnvironmentsHogFunctionsLogsRetrieve Method for EnvironmentsHogFunctionsLogsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsLogsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsLogsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsLogsRetrieveRequest {
	return ApiEnvironmentsHogFunctionsLogsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsLogsRetrieveExecute(r ApiEnvironmentsHogFunctionsLogsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsLogsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsLogsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsLogsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsLogsRetrieve_155Execute(r)
}

/*
EnvironmentsHogFunctionsLogsRetrieve_0 Method for EnvironmentsHogFunctionsLogsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsLogsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsLogsRetrieve_155(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsLogsRetrieve_0Request {
	return ApiEnvironmentsHogFunctionsLogsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsLogsRetrieve_155Execute(r ApiEnvironmentsHogFunctionsLogsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsLogsRetrieve_155")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsMetricsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsMetricsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsMetricsRetrieveExecute(r)
}

/*
EnvironmentsHogFunctionsMetricsRetrieve Method for EnvironmentsHogFunctionsMetricsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsMetricsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsMetricsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsMetricsRetrieveRequest {
	return ApiEnvironmentsHogFunctionsMetricsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsMetricsRetrieveExecute(r ApiEnvironmentsHogFunctionsMetricsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsMetricsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/metrics/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsMetricsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsMetricsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsMetricsRetrieve_156Execute(r)
}

/*
EnvironmentsHogFunctionsMetricsRetrieve_0 Method for EnvironmentsHogFunctionsMetricsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsMetricsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsMetricsRetrieve_156(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsMetricsRetrieve_0Request {
	return ApiEnvironmentsHogFunctionsMetricsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsMetricsRetrieve_156Execute(r ApiEnvironmentsHogFunctionsMetricsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsMetricsRetrieve_156")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/metrics/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsMetricsTotalsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsMetricsTotalsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsMetricsTotalsRetrieveExecute(r)
}

/*
EnvironmentsHogFunctionsMetricsTotalsRetrieve Method for EnvironmentsHogFunctionsMetricsTotalsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsMetricsTotalsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsMetricsTotalsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsMetricsTotalsRetrieveRequest {
	return ApiEnvironmentsHogFunctionsMetricsTotalsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsMetricsTotalsRetrieveExecute(r ApiEnvironmentsHogFunctionsMetricsTotalsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsMetricsTotalsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/metrics/totals/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsMetricsTotalsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsMetricsTotalsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsMetricsTotalsRetrieve_157Execute(r)
}

/*
EnvironmentsHogFunctionsMetricsTotalsRetrieve_0 Method for EnvironmentsHogFunctionsMetricsTotalsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsMetricsTotalsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsMetricsTotalsRetrieve_157(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsMetricsTotalsRetrieve_0Request {
	return ApiEnvironmentsHogFunctionsMetricsTotalsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsMetricsTotalsRetrieve_157Execute(r ApiEnvironmentsHogFunctionsMetricsTotalsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsMetricsTotalsRetrieve_157")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/metrics/totals/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedHogFunction *PatchedHogFunction
}

func (r ApiEnvironmentsHogFunctionsPartialUpdateRequest) PatchedHogFunction(patchedHogFunction PatchedHogFunction) ApiEnvironmentsHogFunctionsPartialUpdateRequest {
	r.patchedHogFunction = &patchedHogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsPartialUpdateRequest) Execute() (*HogFunction, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsPartialUpdateExecute(r)
}

/*
EnvironmentsHogFunctionsPartialUpdate Method for EnvironmentsHogFunctionsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsPartialUpdateRequest {
	return ApiEnvironmentsHogFunctionsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return HogFunction
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsPartialUpdateExecute(r ApiEnvironmentsHogFunctionsPartialUpdateRequest) (*HogFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HogFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedHogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedHogFunction *PatchedHogFunction
}

func (r ApiEnvironmentsHogFunctionsPartialUpdate_0Request) PatchedHogFunction(patchedHogFunction PatchedHogFunction) ApiEnvironmentsHogFunctionsPartialUpdate_0Request {
	r.patchedHogFunction = &patchedHogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsPartialUpdate_0Request) Execute() (*HogFunction, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsPartialUpdate_158Execute(r)
}

/*
EnvironmentsHogFunctionsPartialUpdate_0 Method for EnvironmentsHogFunctionsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsPartialUpdate_158(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsPartialUpdate_0Request {
	return ApiEnvironmentsHogFunctionsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return HogFunction
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsPartialUpdate_158Execute(r ApiEnvironmentsHogFunctionsPartialUpdate_0Request) (*HogFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HogFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsPartialUpdate_158")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedHogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsRearrangePartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	patchedHogFunction *PatchedHogFunction
}

func (r ApiEnvironmentsHogFunctionsRearrangePartialUpdateRequest) PatchedHogFunction(patchedHogFunction PatchedHogFunction) ApiEnvironmentsHogFunctionsRearrangePartialUpdateRequest {
	r.patchedHogFunction = &patchedHogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsRearrangePartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsRearrangePartialUpdateExecute(r)
}

/*
EnvironmentsHogFunctionsRearrangePartialUpdate Method for EnvironmentsHogFunctionsRearrangePartialUpdate

Update the execution order of multiple HogFunctions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsRearrangePartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsRearrangePartialUpdate(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsRearrangePartialUpdateRequest {
	return ApiEnvironmentsHogFunctionsRearrangePartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsRearrangePartialUpdateExecute(r ApiEnvironmentsHogFunctionsRearrangePartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsRearrangePartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/rearrange/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedHogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsRearrangePartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	patchedHogFunction *PatchedHogFunction
}

func (r ApiEnvironmentsHogFunctionsRearrangePartialUpdate_0Request) PatchedHogFunction(patchedHogFunction PatchedHogFunction) ApiEnvironmentsHogFunctionsRearrangePartialUpdate_0Request {
	r.patchedHogFunction = &patchedHogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsRearrangePartialUpdate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsRearrangePartialUpdate_159Execute(r)
}

/*
EnvironmentsHogFunctionsRearrangePartialUpdate_0 Method for EnvironmentsHogFunctionsRearrangePartialUpdate_0

Update the execution order of multiple HogFunctions.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsRearrangePartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsRearrangePartialUpdate_159(ctx context.Context, projectId string) ApiEnvironmentsHogFunctionsRearrangePartialUpdate_0Request {
	return ApiEnvironmentsHogFunctionsRearrangePartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsRearrangePartialUpdate_159Execute(r ApiEnvironmentsHogFunctionsRearrangePartialUpdate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsRearrangePartialUpdate_159")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/rearrange/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedHogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsRetrieveRequest) Execute() (*HogFunction, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsRetrieveExecute(r)
}

/*
EnvironmentsHogFunctionsRetrieve Method for EnvironmentsHogFunctionsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsRetrieveRequest {
	return ApiEnvironmentsHogFunctionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return HogFunction
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsRetrieveExecute(r ApiEnvironmentsHogFunctionsRetrieveRequest) (*HogFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HogFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsHogFunctionsRetrieve_0Request) Execute() (*HogFunction, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsRetrieve_160Execute(r)
}

/*
EnvironmentsHogFunctionsRetrieve_0 Method for EnvironmentsHogFunctionsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsRetrieve_160(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsRetrieve_0Request {
	return ApiEnvironmentsHogFunctionsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return HogFunction
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsRetrieve_160Execute(r ApiEnvironmentsHogFunctionsRetrieve_0Request) (*HogFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HogFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsRetrieve_160")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	hogFunction *HogFunction
}

func (r ApiEnvironmentsHogFunctionsUpdateRequest) HogFunction(hogFunction HogFunction) ApiEnvironmentsHogFunctionsUpdateRequest {
	r.hogFunction = &hogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsUpdateRequest) Execute() (*HogFunction, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsUpdateExecute(r)
}

/*
EnvironmentsHogFunctionsUpdate Method for EnvironmentsHogFunctionsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsUpdateRequest {
	return ApiEnvironmentsHogFunctionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return HogFunction
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsUpdateExecute(r ApiEnvironmentsHogFunctionsUpdateRequest) (*HogFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HogFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsHogFunctionsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	hogFunction *HogFunction
}

func (r ApiEnvironmentsHogFunctionsUpdate_0Request) HogFunction(hogFunction HogFunction) ApiEnvironmentsHogFunctionsUpdate_0Request {
	r.hogFunction = &hogFunction
	return r
}

func (r ApiEnvironmentsHogFunctionsUpdate_0Request) Execute() (*HogFunction, *http.Response, error) {
	return r.ApiService.EnvironmentsHogFunctionsUpdate_161Execute(r)
}

/*
EnvironmentsHogFunctionsUpdate_0 Method for EnvironmentsHogFunctionsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this hog function.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsHogFunctionsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsUpdate_161(ctx context.Context, id string, projectId string) ApiEnvironmentsHogFunctionsUpdate_0Request {
	return ApiEnvironmentsHogFunctionsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return HogFunction
func (a *EnvironmentsAPIService) EnvironmentsHogFunctionsUpdate_161Execute(r ApiEnvironmentsHogFunctionsUpdate_0Request) (*HogFunction, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *HogFunction
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsHogFunctionsUpdate_161")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/hog_functions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.hogFunction
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsActivityRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsInsightsActivityRetrieveRequest) Format(format string) ApiEnvironmentsInsightsActivityRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsActivityRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsActivityRetrieveExecute(r)
}

/*
EnvironmentsInsightsActivityRetrieve Method for EnvironmentsInsightsActivityRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsActivityRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsActivityRetrieve(ctx context.Context, projectId string) ApiEnvironmentsInsightsActivityRetrieveRequest {
	return ApiEnvironmentsInsightsActivityRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsActivityRetrieveExecute(r ApiEnvironmentsInsightsActivityRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsActivityRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsActivityRetrieve2Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsInsightsActivityRetrieve2Request) Format(format string) ApiEnvironmentsInsightsActivityRetrieve2Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsActivityRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsActivityRetrieve2Execute(r)
}

/*
EnvironmentsInsightsActivityRetrieve2 Method for EnvironmentsInsightsActivityRetrieve2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsActivityRetrieve2Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsActivityRetrieve2(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsActivityRetrieve2Request {
	return ApiEnvironmentsInsightsActivityRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsActivityRetrieve2Execute(r ApiEnvironmentsInsightsActivityRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsActivityRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsActivityRetrieve2_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsInsightsActivityRetrieve2_0Request) Format(format string) ApiEnvironmentsInsightsActivityRetrieve2_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsActivityRetrieve2_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsActivityRetrieve2_162Execute(r)
}

/*
EnvironmentsInsightsActivityRetrieve2_0 Method for EnvironmentsInsightsActivityRetrieve2_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsActivityRetrieve2_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsActivityRetrieve2_162(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsActivityRetrieve2_0Request {
	return ApiEnvironmentsInsightsActivityRetrieve2_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsActivityRetrieve2_162Execute(r ApiEnvironmentsInsightsActivityRetrieve2_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsActivityRetrieve2_162")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsActivityRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsInsightsActivityRetrieve_0Request) Format(format string) ApiEnvironmentsInsightsActivityRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsActivityRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsActivityRetrieve_163Execute(r)
}

/*
EnvironmentsInsightsActivityRetrieve_0 Method for EnvironmentsInsightsActivityRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsActivityRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsActivityRetrieve_163(ctx context.Context, projectId string) ApiEnvironmentsInsightsActivityRetrieve_0Request {
	return ApiEnvironmentsInsightsActivityRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsActivityRetrieve_163Execute(r ApiEnvironmentsInsightsActivityRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsActivityRetrieve_163")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsCancelCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiEnvironmentsInsightsCancelCreateRequest) Format(format string) ApiEnvironmentsInsightsCancelCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsCancelCreateRequest) Insight(insight Insight) ApiEnvironmentsInsightsCancelCreateRequest {
	r.insight = &insight
	return r
}

func (r ApiEnvironmentsInsightsCancelCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsCancelCreateExecute(r)
}

/*
EnvironmentsInsightsCancelCreate Method for EnvironmentsInsightsCancelCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsCancelCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsCancelCreate(ctx context.Context, projectId string) ApiEnvironmentsInsightsCancelCreateRequest {
	return ApiEnvironmentsInsightsCancelCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsCancelCreateExecute(r ApiEnvironmentsInsightsCancelCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsCancelCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsCancelCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiEnvironmentsInsightsCancelCreate_0Request) Format(format string) ApiEnvironmentsInsightsCancelCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsCancelCreate_0Request) Insight(insight Insight) ApiEnvironmentsInsightsCancelCreate_0Request {
	r.insight = &insight
	return r
}

func (r ApiEnvironmentsInsightsCancelCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsCancelCreate_164Execute(r)
}

/*
EnvironmentsInsightsCancelCreate_0 Method for EnvironmentsInsightsCancelCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsCancelCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsCancelCreate_164(ctx context.Context, projectId string) ApiEnvironmentsInsightsCancelCreate_0Request {
	return ApiEnvironmentsInsightsCancelCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsCancelCreate_164Execute(r ApiEnvironmentsInsightsCancelCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsCancelCreate_164")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiEnvironmentsInsightsCreateRequest) Format(format string) ApiEnvironmentsInsightsCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsCreateRequest) Insight(insight Insight) ApiEnvironmentsInsightsCreateRequest {
	r.insight = &insight
	return r
}

func (r ApiEnvironmentsInsightsCreateRequest) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsCreateExecute(r)
}

/*
EnvironmentsInsightsCreate Method for EnvironmentsInsightsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsCreate(ctx context.Context, projectId string) ApiEnvironmentsInsightsCreateRequest {
	return ApiEnvironmentsInsightsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *EnvironmentsAPIService) EnvironmentsInsightsCreateExecute(r ApiEnvironmentsInsightsCreateRequest) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiEnvironmentsInsightsCreate_0Request) Format(format string) ApiEnvironmentsInsightsCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsCreate_0Request) Insight(insight Insight) ApiEnvironmentsInsightsCreate_0Request {
	r.insight = &insight
	return r
}

func (r ApiEnvironmentsInsightsCreate_0Request) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsCreate_165Execute(r)
}

/*
EnvironmentsInsightsCreate_0 Method for EnvironmentsInsightsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsCreate_165(ctx context.Context, projectId string) ApiEnvironmentsInsightsCreate_0Request {
	return ApiEnvironmentsInsightsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *EnvironmentsAPIService) EnvironmentsInsightsCreate_165Execute(r ApiEnvironmentsInsightsCreate_0Request) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsCreate_165")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsInsightsDestroyRequest) Format(format string) ApiEnvironmentsInsightsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsDestroyExecute(r)
}

/*
EnvironmentsInsightsDestroy Method for EnvironmentsInsightsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsDestroy(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsDestroyRequest {
	return ApiEnvironmentsInsightsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsDestroyExecute(r ApiEnvironmentsInsightsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsInsightsDestroy_0Request) Format(format string) ApiEnvironmentsInsightsDestroy_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsDestroy_166Execute(r)
}

/*
EnvironmentsInsightsDestroy_0 Method for EnvironmentsInsightsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsDestroy_166(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsDestroy_0Request {
	return ApiEnvironmentsInsightsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsDestroy_166Execute(r ApiEnvironmentsInsightsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsDestroy_166")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	basic *bool
	createdBy *int32
	format *string
	limit *int32
	offset *int32
	refresh *string
	shortId *string
}

// Return basic insight metadata only (no results, faster).
func (r ApiEnvironmentsInsightsListRequest) Basic(basic bool) ApiEnvironmentsInsightsListRequest {
	r.basic = &basic
	return r
}

func (r ApiEnvironmentsInsightsListRequest) CreatedBy(createdBy int32) ApiEnvironmentsInsightsListRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsInsightsListRequest) Format(format string) ApiEnvironmentsInsightsListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsInsightsListRequest) Limit(limit int32) ApiEnvironmentsInsightsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsInsightsListRequest) Offset(offset int32) ApiEnvironmentsInsightsListRequest {
	r.offset = &offset
	return r
}

//  Whether to refresh the retrieved insights, how aggresively, and if sync or async: - &#x60;&#39;force_cache&#39;&#x60; - return cached data or a cache miss; always completes immediately as it never calculates - &#x60;&#39;blocking&#39;&#x60; - calculate synchronously (returning only when the query is done), UNLESS there are very fresh results in the cache - &#x60;&#39;async&#39;&#x60; - kick off background calculation (returning immediately with a query status), UNLESS there are very fresh results in the cache - &#x60;&#39;lazy_async&#39;&#x60; - kick off background calculation, UNLESS there are somewhat fresh results in the cache - &#x60;&#39;force_blocking&#39;&#x60; - calculate synchronously, even if fresh results are already cached - &#x60;&#39;force_async&#39;&#x60; - kick off background calculation, even if fresh results are already cached Background calculation can be tracked using the &#x60;query_status&#x60; response field.
func (r ApiEnvironmentsInsightsListRequest) Refresh(refresh string) ApiEnvironmentsInsightsListRequest {
	r.refresh = &refresh
	return r
}

func (r ApiEnvironmentsInsightsListRequest) ShortId(shortId string) ApiEnvironmentsInsightsListRequest {
	r.shortId = &shortId
	return r
}

func (r ApiEnvironmentsInsightsListRequest) Execute() (*PaginatedInsightList, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsListExecute(r)
}

/*
EnvironmentsInsightsList Method for EnvironmentsInsightsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsList(ctx context.Context, projectId string) ApiEnvironmentsInsightsListRequest {
	return ApiEnvironmentsInsightsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedInsightList
func (a *EnvironmentsAPIService) EnvironmentsInsightsListExecute(r ApiEnvironmentsInsightsListRequest) (*PaginatedInsightList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInsightList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.basic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "basic", r.basic, "form", "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "form", "")
	} else {
        var defaultValue string = "force_cache"
        parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", defaultValue, "form", "")
        r.refresh = &defaultValue
	}
	if r.shortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "short_id", r.shortId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	basic *bool
	createdBy *int32
	format *string
	limit *int32
	offset *int32
	refresh *string
	shortId *string
}

// Return basic insight metadata only (no results, faster).
func (r ApiEnvironmentsInsightsList_0Request) Basic(basic bool) ApiEnvironmentsInsightsList_0Request {
	r.basic = &basic
	return r
}

func (r ApiEnvironmentsInsightsList_0Request) CreatedBy(createdBy int32) ApiEnvironmentsInsightsList_0Request {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsInsightsList_0Request) Format(format string) ApiEnvironmentsInsightsList_0Request {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsInsightsList_0Request) Limit(limit int32) ApiEnvironmentsInsightsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsInsightsList_0Request) Offset(offset int32) ApiEnvironmentsInsightsList_0Request {
	r.offset = &offset
	return r
}

//  Whether to refresh the retrieved insights, how aggresively, and if sync or async: - &#x60;&#39;force_cache&#39;&#x60; - return cached data or a cache miss; always completes immediately as it never calculates - &#x60;&#39;blocking&#39;&#x60; - calculate synchronously (returning only when the query is done), UNLESS there are very fresh results in the cache - &#x60;&#39;async&#39;&#x60; - kick off background calculation (returning immediately with a query status), UNLESS there are very fresh results in the cache - &#x60;&#39;lazy_async&#39;&#x60; - kick off background calculation, UNLESS there are somewhat fresh results in the cache - &#x60;&#39;force_blocking&#39;&#x60; - calculate synchronously, even if fresh results are already cached - &#x60;&#39;force_async&#39;&#x60; - kick off background calculation, even if fresh results are already cached Background calculation can be tracked using the &#x60;query_status&#x60; response field.
func (r ApiEnvironmentsInsightsList_0Request) Refresh(refresh string) ApiEnvironmentsInsightsList_0Request {
	r.refresh = &refresh
	return r
}

func (r ApiEnvironmentsInsightsList_0Request) ShortId(shortId string) ApiEnvironmentsInsightsList_0Request {
	r.shortId = &shortId
	return r
}

func (r ApiEnvironmentsInsightsList_0Request) Execute() (*PaginatedInsightList, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsList_167Execute(r)
}

/*
EnvironmentsInsightsList_0 Method for EnvironmentsInsightsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsList_167(ctx context.Context, projectId string) ApiEnvironmentsInsightsList_0Request {
	return ApiEnvironmentsInsightsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedInsightList
func (a *EnvironmentsAPIService) EnvironmentsInsightsList_167Execute(r ApiEnvironmentsInsightsList_0Request) (*PaginatedInsightList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInsightList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsList_167")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.basic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "basic", r.basic, "form", "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "form", "")
	} else {
        var defaultValue string = "force_cache"
        parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", defaultValue, "form", "")
        r.refresh = &defaultValue
	}
	if r.shortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "short_id", r.shortId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsMyLastViewedRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsInsightsMyLastViewedRetrieveRequest) Format(format string) ApiEnvironmentsInsightsMyLastViewedRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsMyLastViewedRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsMyLastViewedRetrieveExecute(r)
}

/*
EnvironmentsInsightsMyLastViewedRetrieve Method for EnvironmentsInsightsMyLastViewedRetrieve

Returns basic details about the last 5 insights viewed by this user. Most recently viewed first.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsMyLastViewedRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsMyLastViewedRetrieve(ctx context.Context, projectId string) ApiEnvironmentsInsightsMyLastViewedRetrieveRequest {
	return ApiEnvironmentsInsightsMyLastViewedRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsMyLastViewedRetrieveExecute(r ApiEnvironmentsInsightsMyLastViewedRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsMyLastViewedRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/my_last_viewed/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsMyLastViewedRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsInsightsMyLastViewedRetrieve_0Request) Format(format string) ApiEnvironmentsInsightsMyLastViewedRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsMyLastViewedRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsMyLastViewedRetrieve_168Execute(r)
}

/*
EnvironmentsInsightsMyLastViewedRetrieve_0 Method for EnvironmentsInsightsMyLastViewedRetrieve_0

Returns basic details about the last 5 insights viewed by this user. Most recently viewed first.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsMyLastViewedRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsMyLastViewedRetrieve_168(ctx context.Context, projectId string) ApiEnvironmentsInsightsMyLastViewedRetrieve_0Request {
	return ApiEnvironmentsInsightsMyLastViewedRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsMyLastViewedRetrieve_168Execute(r ApiEnvironmentsInsightsMyLastViewedRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsMyLastViewedRetrieve_168")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/my_last_viewed/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	patchedInsight *PatchedInsight
}

func (r ApiEnvironmentsInsightsPartialUpdateRequest) Format(format string) ApiEnvironmentsInsightsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsPartialUpdateRequest) PatchedInsight(patchedInsight PatchedInsight) ApiEnvironmentsInsightsPartialUpdateRequest {
	r.patchedInsight = &patchedInsight
	return r
}

func (r ApiEnvironmentsInsightsPartialUpdateRequest) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsPartialUpdateExecute(r)
}

/*
EnvironmentsInsightsPartialUpdate Method for EnvironmentsInsightsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsPartialUpdateRequest {
	return ApiEnvironmentsInsightsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *EnvironmentsAPIService) EnvironmentsInsightsPartialUpdateExecute(r ApiEnvironmentsInsightsPartialUpdateRequest) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	patchedInsight *PatchedInsight
}

func (r ApiEnvironmentsInsightsPartialUpdate_0Request) Format(format string) ApiEnvironmentsInsightsPartialUpdate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsPartialUpdate_0Request) PatchedInsight(patchedInsight PatchedInsight) ApiEnvironmentsInsightsPartialUpdate_0Request {
	r.patchedInsight = &patchedInsight
	return r
}

func (r ApiEnvironmentsInsightsPartialUpdate_0Request) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsPartialUpdate_169Execute(r)
}

/*
EnvironmentsInsightsPartialUpdate_0 Method for EnvironmentsInsightsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsPartialUpdate_169(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsPartialUpdate_0Request {
	return ApiEnvironmentsInsightsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *EnvironmentsAPIService) EnvironmentsInsightsPartialUpdate_169Execute(r ApiEnvironmentsInsightsPartialUpdate_0Request) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsPartialUpdate_169")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	fromDashboard *int32
	refresh *string
}

func (r ApiEnvironmentsInsightsRetrieveRequest) Format(format string) ApiEnvironmentsInsightsRetrieveRequest {
	r.format = &format
	return r
}

//  Only if loading an insight in the context of a dashboard: The relevant dashboard&#39;s ID. When set, the specified dashboard&#39;s filters and date range override will be applied.
func (r ApiEnvironmentsInsightsRetrieveRequest) FromDashboard(fromDashboard int32) ApiEnvironmentsInsightsRetrieveRequest {
	r.fromDashboard = &fromDashboard
	return r
}

//  Whether to refresh the insight, how aggresively, and if sync or async: - &#x60;&#39;force_cache&#39;&#x60; - return cached data or a cache miss; always completes immediately as it never calculates - &#x60;&#39;blocking&#39;&#x60; - calculate synchronously (returning only when the query is done), UNLESS there are very fresh results in the cache - &#x60;&#39;async&#39;&#x60; - kick off background calculation (returning immediately with a query status), UNLESS there are very fresh results in the cache - &#x60;&#39;lazy_async&#39;&#x60; - kick off background calculation, UNLESS there are somewhat fresh results in the cache - &#x60;&#39;force_blocking&#39;&#x60; - calculate synchronously, even if fresh results are already cached - &#x60;&#39;force_async&#39;&#x60; - kick off background calculation, even if fresh results are already cached Background calculation can be tracked using the &#x60;query_status&#x60; response field.
func (r ApiEnvironmentsInsightsRetrieveRequest) Refresh(refresh string) ApiEnvironmentsInsightsRetrieveRequest {
	r.refresh = &refresh
	return r
}

func (r ApiEnvironmentsInsightsRetrieveRequest) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsRetrieveExecute(r)
}

/*
EnvironmentsInsightsRetrieve Method for EnvironmentsInsightsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsRetrieveRequest {
	return ApiEnvironmentsInsightsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *EnvironmentsAPIService) EnvironmentsInsightsRetrieveExecute(r ApiEnvironmentsInsightsRetrieveRequest) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.fromDashboard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_dashboard", r.fromDashboard, "form", "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "form", "")
	} else {
        var defaultValue string = "force_cache"
        parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", defaultValue, "form", "")
        r.refresh = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	fromDashboard *int32
	refresh *string
}

func (r ApiEnvironmentsInsightsRetrieve_0Request) Format(format string) ApiEnvironmentsInsightsRetrieve_0Request {
	r.format = &format
	return r
}

//  Only if loading an insight in the context of a dashboard: The relevant dashboard&#39;s ID. When set, the specified dashboard&#39;s filters and date range override will be applied.
func (r ApiEnvironmentsInsightsRetrieve_0Request) FromDashboard(fromDashboard int32) ApiEnvironmentsInsightsRetrieve_0Request {
	r.fromDashboard = &fromDashboard
	return r
}

//  Whether to refresh the insight, how aggresively, and if sync or async: - &#x60;&#39;force_cache&#39;&#x60; - return cached data or a cache miss; always completes immediately as it never calculates - &#x60;&#39;blocking&#39;&#x60; - calculate synchronously (returning only when the query is done), UNLESS there are very fresh results in the cache - &#x60;&#39;async&#39;&#x60; - kick off background calculation (returning immediately with a query status), UNLESS there are very fresh results in the cache - &#x60;&#39;lazy_async&#39;&#x60; - kick off background calculation, UNLESS there are somewhat fresh results in the cache - &#x60;&#39;force_blocking&#39;&#x60; - calculate synchronously, even if fresh results are already cached - &#x60;&#39;force_async&#39;&#x60; - kick off background calculation, even if fresh results are already cached Background calculation can be tracked using the &#x60;query_status&#x60; response field.
func (r ApiEnvironmentsInsightsRetrieve_0Request) Refresh(refresh string) ApiEnvironmentsInsightsRetrieve_0Request {
	r.refresh = &refresh
	return r
}

func (r ApiEnvironmentsInsightsRetrieve_0Request) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsRetrieve_170Execute(r)
}

/*
EnvironmentsInsightsRetrieve_0 Method for EnvironmentsInsightsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsRetrieve_170(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsRetrieve_0Request {
	return ApiEnvironmentsInsightsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *EnvironmentsAPIService) EnvironmentsInsightsRetrieve_170Execute(r ApiEnvironmentsInsightsRetrieve_0Request) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsRetrieve_170")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.fromDashboard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_dashboard", r.fromDashboard, "form", "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "form", "")
	} else {
        var defaultValue string = "force_cache"
        parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", defaultValue, "form", "")
        r.refresh = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsSharingListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	insightId int32
	projectId string
}

func (r ApiEnvironmentsInsightsSharingListRequest) Execute() ([]SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsSharingListExecute(r)
}

/*
EnvironmentsInsightsSharingList Method for EnvironmentsInsightsSharingList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsSharingListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingList(ctx context.Context, insightId int32, projectId string) ApiEnvironmentsInsightsSharingListRequest {
	return ApiEnvironmentsInsightsSharingListRequest{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingListExecute(r ApiEnvironmentsInsightsSharingListRequest) ([]SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsSharingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{insight_id}/sharing/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsSharingList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	insightId int32
	projectId string
}

func (r ApiEnvironmentsInsightsSharingList_0Request) Execute() ([]SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsSharingList_171Execute(r)
}

/*
EnvironmentsInsightsSharingList_0 Method for EnvironmentsInsightsSharingList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsSharingList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingList_171(ctx context.Context, insightId int32, projectId string) ApiEnvironmentsInsightsSharingList_0Request {
	return ApiEnvironmentsInsightsSharingList_0Request{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingList_171Execute(r ApiEnvironmentsInsightsSharingList_0Request) ([]SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsSharingList_171")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{insight_id}/sharing/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsSharingPasswordsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	insightId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsInsightsSharingPasswordsCreateRequest) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsInsightsSharingPasswordsCreateRequest {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsInsightsSharingPasswordsCreateRequest) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsSharingPasswordsCreateExecute(r)
}

/*
EnvironmentsInsightsSharingPasswordsCreate Method for EnvironmentsInsightsSharingPasswordsCreate

Create a new password for the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsSharingPasswordsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingPasswordsCreate(ctx context.Context, insightId int32, projectId string) ApiEnvironmentsInsightsSharingPasswordsCreateRequest {
	return ApiEnvironmentsInsightsSharingPasswordsCreateRequest{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingPasswordsCreateExecute(r ApiEnvironmentsInsightsSharingPasswordsCreateRequest) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsSharingPasswordsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{insight_id}/sharing/passwords/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsSharingPasswordsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	insightId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsInsightsSharingPasswordsCreate_0Request) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsInsightsSharingPasswordsCreate_0Request {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsInsightsSharingPasswordsCreate_0Request) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsSharingPasswordsCreate_172Execute(r)
}

/*
EnvironmentsInsightsSharingPasswordsCreate_0 Method for EnvironmentsInsightsSharingPasswordsCreate_0

Create a new password for the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsSharingPasswordsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingPasswordsCreate_172(ctx context.Context, insightId int32, projectId string) ApiEnvironmentsInsightsSharingPasswordsCreate_0Request {
	return ApiEnvironmentsInsightsSharingPasswordsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingPasswordsCreate_172Execute(r ApiEnvironmentsInsightsSharingPasswordsCreate_0Request) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsSharingPasswordsCreate_172")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{insight_id}/sharing/passwords/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsSharingPasswordsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	insightId int32
	passwordId string
	projectId string
}

func (r ApiEnvironmentsInsightsSharingPasswordsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsSharingPasswordsDestroyExecute(r)
}

/*
EnvironmentsInsightsSharingPasswordsDestroy Method for EnvironmentsInsightsSharingPasswordsDestroy

Delete a password from the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param passwordId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsSharingPasswordsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingPasswordsDestroy(ctx context.Context, insightId int32, passwordId string, projectId string) ApiEnvironmentsInsightsSharingPasswordsDestroyRequest {
	return ApiEnvironmentsInsightsSharingPasswordsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		passwordId: passwordId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingPasswordsDestroyExecute(r ApiEnvironmentsInsightsSharingPasswordsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsSharingPasswordsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{insight_id}/sharing/passwords/{password_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"password_id"+"}", url.PathEscape(parameterValueToString(r.passwordId, "passwordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsSharingPasswordsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	insightId int32
	passwordId string
	projectId string
}

func (r ApiEnvironmentsInsightsSharingPasswordsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsSharingPasswordsDestroy_173Execute(r)
}

/*
EnvironmentsInsightsSharingPasswordsDestroy_0 Method for EnvironmentsInsightsSharingPasswordsDestroy_0

Delete a password from the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param passwordId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsSharingPasswordsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingPasswordsDestroy_173(ctx context.Context, insightId int32, passwordId string, projectId string) ApiEnvironmentsInsightsSharingPasswordsDestroy_0Request {
	return ApiEnvironmentsInsightsSharingPasswordsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		passwordId: passwordId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingPasswordsDestroy_173Execute(r ApiEnvironmentsInsightsSharingPasswordsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsSharingPasswordsDestroy_173")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{insight_id}/sharing/passwords/{password_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"password_id"+"}", url.PathEscape(parameterValueToString(r.passwordId, "passwordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsSharingRefreshCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	insightId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsInsightsSharingRefreshCreateRequest) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsInsightsSharingRefreshCreateRequest {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsInsightsSharingRefreshCreateRequest) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsSharingRefreshCreateExecute(r)
}

/*
EnvironmentsInsightsSharingRefreshCreate Method for EnvironmentsInsightsSharingRefreshCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsSharingRefreshCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingRefreshCreate(ctx context.Context, insightId int32, projectId string) ApiEnvironmentsInsightsSharingRefreshCreateRequest {
	return ApiEnvironmentsInsightsSharingRefreshCreateRequest{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingRefreshCreateExecute(r ApiEnvironmentsInsightsSharingRefreshCreateRequest) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsSharingRefreshCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{insight_id}/sharing/refresh/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsSharingRefreshCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	insightId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsInsightsSharingRefreshCreate_0Request) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsInsightsSharingRefreshCreate_0Request {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsInsightsSharingRefreshCreate_0Request) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsSharingRefreshCreate_174Execute(r)
}

/*
EnvironmentsInsightsSharingRefreshCreate_0 Method for EnvironmentsInsightsSharingRefreshCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsSharingRefreshCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingRefreshCreate_174(ctx context.Context, insightId int32, projectId string) ApiEnvironmentsInsightsSharingRefreshCreate_0Request {
	return ApiEnvironmentsInsightsSharingRefreshCreate_0Request{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsInsightsSharingRefreshCreate_174Execute(r ApiEnvironmentsInsightsSharingRefreshCreate_0Request) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsSharingRefreshCreate_174")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{insight_id}/sharing/refresh/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	insight *Insight
}

func (r ApiEnvironmentsInsightsUpdateRequest) Format(format string) ApiEnvironmentsInsightsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsUpdateRequest) Insight(insight Insight) ApiEnvironmentsInsightsUpdateRequest {
	r.insight = &insight
	return r
}

func (r ApiEnvironmentsInsightsUpdateRequest) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsUpdateExecute(r)
}

/*
EnvironmentsInsightsUpdate Method for EnvironmentsInsightsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsUpdateRequest {
	return ApiEnvironmentsInsightsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *EnvironmentsAPIService) EnvironmentsInsightsUpdateExecute(r ApiEnvironmentsInsightsUpdateRequest) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	insight *Insight
}

func (r ApiEnvironmentsInsightsUpdate_0Request) Format(format string) ApiEnvironmentsInsightsUpdate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsUpdate_0Request) Insight(insight Insight) ApiEnvironmentsInsightsUpdate_0Request {
	r.insight = &insight
	return r
}

func (r ApiEnvironmentsInsightsUpdate_0Request) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.EnvironmentsInsightsUpdate_175Execute(r)
}

/*
EnvironmentsInsightsUpdate_0 Method for EnvironmentsInsightsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsUpdate_175(ctx context.Context, id int32, projectId string) ApiEnvironmentsInsightsUpdate_0Request {
	return ApiEnvironmentsInsightsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *EnvironmentsAPIService) EnvironmentsInsightsUpdate_175Execute(r ApiEnvironmentsInsightsUpdate_0Request) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsUpdate_175")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsViewedCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiEnvironmentsInsightsViewedCreateRequest) Format(format string) ApiEnvironmentsInsightsViewedCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsViewedCreateRequest) Insight(insight Insight) ApiEnvironmentsInsightsViewedCreateRequest {
	r.insight = &insight
	return r
}

func (r ApiEnvironmentsInsightsViewedCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsViewedCreateExecute(r)
}

/*
EnvironmentsInsightsViewedCreate Method for EnvironmentsInsightsViewedCreate

Update insight view timestamps.
Expects: {"insight_ids": [1, 2, 3, ...]}

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsViewedCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsViewedCreate(ctx context.Context, projectId string) ApiEnvironmentsInsightsViewedCreateRequest {
	return ApiEnvironmentsInsightsViewedCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsViewedCreateExecute(r ApiEnvironmentsInsightsViewedCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsViewedCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/viewed/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsInsightsViewedCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiEnvironmentsInsightsViewedCreate_0Request) Format(format string) ApiEnvironmentsInsightsViewedCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsInsightsViewedCreate_0Request) Insight(insight Insight) ApiEnvironmentsInsightsViewedCreate_0Request {
	r.insight = &insight
	return r
}

func (r ApiEnvironmentsInsightsViewedCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsInsightsViewedCreate_176Execute(r)
}

/*
EnvironmentsInsightsViewedCreate_0 Method for EnvironmentsInsightsViewedCreate_0

Update insight view timestamps.
Expects: {"insight_ids": [1, 2, 3, ...]}

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsInsightsViewedCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsInsightsViewedCreate_176(ctx context.Context, projectId string) ApiEnvironmentsInsightsViewedCreate_0Request {
	return ApiEnvironmentsInsightsViewedCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsInsightsViewedCreate_176Execute(r ApiEnvironmentsInsightsViewedCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsInsightsViewedCreate_176")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/insights/viewed/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsAuthorizeRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsIntegrationsAuthorizeRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsAuthorizeRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsAuthorizeRetrieve Method for EnvironmentsIntegrationsAuthorizeRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsAuthorizeRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsAuthorizeRetrieve(ctx context.Context, projectId string) ApiEnvironmentsIntegrationsAuthorizeRetrieveRequest {
	return ApiEnvironmentsIntegrationsAuthorizeRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsAuthorizeRetrieveExecute(r ApiEnvironmentsIntegrationsAuthorizeRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsAuthorizeRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/authorize/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsAuthorizeRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsIntegrationsAuthorizeRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsAuthorizeRetrieve_177Execute(r)
}

/*
EnvironmentsIntegrationsAuthorizeRetrieve_0 Method for EnvironmentsIntegrationsAuthorizeRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsAuthorizeRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsAuthorizeRetrieve_177(ctx context.Context, projectId string) ApiEnvironmentsIntegrationsAuthorizeRetrieve_0Request {
	return ApiEnvironmentsIntegrationsAuthorizeRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsAuthorizeRetrieve_177Execute(r ApiEnvironmentsIntegrationsAuthorizeRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsAuthorizeRetrieve_177")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/authorize/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsChannelsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsChannelsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsChannelsRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsChannelsRetrieve Method for EnvironmentsIntegrationsChannelsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsChannelsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsChannelsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsChannelsRetrieveRequest {
	return ApiEnvironmentsIntegrationsChannelsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsChannelsRetrieveExecute(r ApiEnvironmentsIntegrationsChannelsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsChannelsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/channels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsChannelsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsChannelsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsChannelsRetrieve_178Execute(r)
}

/*
EnvironmentsIntegrationsChannelsRetrieve_0 Method for EnvironmentsIntegrationsChannelsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsChannelsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsChannelsRetrieve_178(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsChannelsRetrieve_0Request {
	return ApiEnvironmentsIntegrationsChannelsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsChannelsRetrieve_178Execute(r ApiEnvironmentsIntegrationsChannelsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsChannelsRetrieve_178")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/channels/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsClickupListsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsClickupListsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsClickupListsRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsClickupListsRetrieve Method for EnvironmentsIntegrationsClickupListsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsClickupListsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupListsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsClickupListsRetrieveRequest {
	return ApiEnvironmentsIntegrationsClickupListsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupListsRetrieveExecute(r ApiEnvironmentsIntegrationsClickupListsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsClickupListsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/clickup_lists/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsClickupListsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsClickupListsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsClickupListsRetrieve_179Execute(r)
}

/*
EnvironmentsIntegrationsClickupListsRetrieve_0 Method for EnvironmentsIntegrationsClickupListsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsClickupListsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupListsRetrieve_179(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsClickupListsRetrieve_0Request {
	return ApiEnvironmentsIntegrationsClickupListsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupListsRetrieve_179Execute(r ApiEnvironmentsIntegrationsClickupListsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsClickupListsRetrieve_179")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/clickup_lists/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsClickupSpacesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsClickupSpacesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsClickupSpacesRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsClickupSpacesRetrieve Method for EnvironmentsIntegrationsClickupSpacesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsClickupSpacesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupSpacesRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsClickupSpacesRetrieveRequest {
	return ApiEnvironmentsIntegrationsClickupSpacesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupSpacesRetrieveExecute(r ApiEnvironmentsIntegrationsClickupSpacesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsClickupSpacesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/clickup_spaces/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsClickupSpacesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsClickupSpacesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsClickupSpacesRetrieve_180Execute(r)
}

/*
EnvironmentsIntegrationsClickupSpacesRetrieve_0 Method for EnvironmentsIntegrationsClickupSpacesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsClickupSpacesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupSpacesRetrieve_180(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsClickupSpacesRetrieve_0Request {
	return ApiEnvironmentsIntegrationsClickupSpacesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupSpacesRetrieve_180Execute(r ApiEnvironmentsIntegrationsClickupSpacesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsClickupSpacesRetrieve_180")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/clickup_spaces/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsClickupWorkspacesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsClickupWorkspacesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsClickupWorkspacesRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsClickupWorkspacesRetrieve Method for EnvironmentsIntegrationsClickupWorkspacesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsClickupWorkspacesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupWorkspacesRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsClickupWorkspacesRetrieveRequest {
	return ApiEnvironmentsIntegrationsClickupWorkspacesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupWorkspacesRetrieveExecute(r ApiEnvironmentsIntegrationsClickupWorkspacesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsClickupWorkspacesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/clickup_workspaces/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsClickupWorkspacesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsClickupWorkspacesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsClickupWorkspacesRetrieve_181Execute(r)
}

/*
EnvironmentsIntegrationsClickupWorkspacesRetrieve_0 Method for EnvironmentsIntegrationsClickupWorkspacesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsClickupWorkspacesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupWorkspacesRetrieve_181(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsClickupWorkspacesRetrieve_0Request {
	return ApiEnvironmentsIntegrationsClickupWorkspacesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsClickupWorkspacesRetrieve_181Execute(r ApiEnvironmentsIntegrationsClickupWorkspacesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsClickupWorkspacesRetrieve_181")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/clickup_workspaces/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	integration *Integration
}

func (r ApiEnvironmentsIntegrationsCreateRequest) Integration(integration Integration) ApiEnvironmentsIntegrationsCreateRequest {
	r.integration = &integration
	return r
}

func (r ApiEnvironmentsIntegrationsCreateRequest) Execute() (*Integration, *http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsCreateExecute(r)
}

/*
EnvironmentsIntegrationsCreate Method for EnvironmentsIntegrationsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsCreate(ctx context.Context, projectId string) ApiEnvironmentsIntegrationsCreateRequest {
	return ApiEnvironmentsIntegrationsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Integration
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsCreateExecute(r ApiEnvironmentsIntegrationsCreateRequest) (*Integration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Integration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.integration == nil {
		return localVarReturnValue, nil, reportError("integration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.integration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	integration *Integration
}

func (r ApiEnvironmentsIntegrationsCreate_0Request) Integration(integration Integration) ApiEnvironmentsIntegrationsCreate_0Request {
	r.integration = &integration
	return r
}

func (r ApiEnvironmentsIntegrationsCreate_0Request) Execute() (*Integration, *http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsCreate_182Execute(r)
}

/*
EnvironmentsIntegrationsCreate_0 Method for EnvironmentsIntegrationsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsCreate_182(ctx context.Context, projectId string) ApiEnvironmentsIntegrationsCreate_0Request {
	return ApiEnvironmentsIntegrationsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Integration
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsCreate_182Execute(r ApiEnvironmentsIntegrationsCreate_0Request) (*Integration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Integration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsCreate_182")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.integration == nil {
		return localVarReturnValue, nil, reportError("integration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.integration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsDestroyExecute(r)
}

/*
EnvironmentsIntegrationsDestroy Method for EnvironmentsIntegrationsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsDestroy(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsDestroyRequest {
	return ApiEnvironmentsIntegrationsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsDestroyExecute(r ApiEnvironmentsIntegrationsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsDestroy_183Execute(r)
}

/*
EnvironmentsIntegrationsDestroy_0 Method for EnvironmentsIntegrationsDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsDestroy_183(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsDestroy_0Request {
	return ApiEnvironmentsIntegrationsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsDestroy_183Execute(r ApiEnvironmentsIntegrationsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsDestroy_183")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsEmailVerifyCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	integration *Integration
}

func (r ApiEnvironmentsIntegrationsEmailVerifyCreateRequest) Integration(integration Integration) ApiEnvironmentsIntegrationsEmailVerifyCreateRequest {
	r.integration = &integration
	return r
}

func (r ApiEnvironmentsIntegrationsEmailVerifyCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsEmailVerifyCreateExecute(r)
}

/*
EnvironmentsIntegrationsEmailVerifyCreate Method for EnvironmentsIntegrationsEmailVerifyCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsEmailVerifyCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsEmailVerifyCreate(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsEmailVerifyCreateRequest {
	return ApiEnvironmentsIntegrationsEmailVerifyCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsEmailVerifyCreateExecute(r ApiEnvironmentsIntegrationsEmailVerifyCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsEmailVerifyCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/email/verify/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.integration == nil {
		return nil, reportError("integration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.integration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsEmailVerifyCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	integration *Integration
}

func (r ApiEnvironmentsIntegrationsEmailVerifyCreate_0Request) Integration(integration Integration) ApiEnvironmentsIntegrationsEmailVerifyCreate_0Request {
	r.integration = &integration
	return r
}

func (r ApiEnvironmentsIntegrationsEmailVerifyCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsEmailVerifyCreate_184Execute(r)
}

/*
EnvironmentsIntegrationsEmailVerifyCreate_0 Method for EnvironmentsIntegrationsEmailVerifyCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsEmailVerifyCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsEmailVerifyCreate_184(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsEmailVerifyCreate_0Request {
	return ApiEnvironmentsIntegrationsEmailVerifyCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsEmailVerifyCreate_184Execute(r ApiEnvironmentsIntegrationsEmailVerifyCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsEmailVerifyCreate_184")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/email/verify/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.integration == nil {
		return nil, reportError("integration is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.integration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsGithubReposRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsGithubReposRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsGithubReposRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsGithubReposRetrieve Method for EnvironmentsIntegrationsGithubReposRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsGithubReposRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGithubReposRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsGithubReposRetrieveRequest {
	return ApiEnvironmentsIntegrationsGithubReposRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGithubReposRetrieveExecute(r ApiEnvironmentsIntegrationsGithubReposRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsGithubReposRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/github_repos/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsGithubReposRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsGithubReposRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsGithubReposRetrieve_185Execute(r)
}

/*
EnvironmentsIntegrationsGithubReposRetrieve_0 Method for EnvironmentsIntegrationsGithubReposRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsGithubReposRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGithubReposRetrieve_185(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsGithubReposRetrieve_0Request {
	return ApiEnvironmentsIntegrationsGithubReposRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGithubReposRetrieve_185Execute(r ApiEnvironmentsIntegrationsGithubReposRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsGithubReposRetrieve_185")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/github_repos/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve Method for EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieveRequest {
	return ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieveExecute(r ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/google_accessible_accounts/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_186Execute(r)
}

/*
EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_0 Method for EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_186(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_0Request {
	return ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_186Execute(r ApiEnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsGoogleAccessibleAccountsRetrieve_186")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/google_accessible_accounts/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsGoogleConversionActionsRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsGoogleConversionActionsRetrieve Method for EnvironmentsIntegrationsGoogleConversionActionsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGoogleConversionActionsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieveRequest {
	return ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGoogleConversionActionsRetrieveExecute(r ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsGoogleConversionActionsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/google_conversion_actions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsGoogleConversionActionsRetrieve_187Execute(r)
}

/*
EnvironmentsIntegrationsGoogleConversionActionsRetrieve_0 Method for EnvironmentsIntegrationsGoogleConversionActionsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGoogleConversionActionsRetrieve_187(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieve_0Request {
	return ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsGoogleConversionActionsRetrieve_187Execute(r ApiEnvironmentsIntegrationsGoogleConversionActionsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsGoogleConversionActionsRetrieve_187")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/google_conversion_actions/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsLinearTeamsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsLinearTeamsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsLinearTeamsRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsLinearTeamsRetrieve Method for EnvironmentsIntegrationsLinearTeamsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsLinearTeamsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinearTeamsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsLinearTeamsRetrieveRequest {
	return ApiEnvironmentsIntegrationsLinearTeamsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinearTeamsRetrieveExecute(r ApiEnvironmentsIntegrationsLinearTeamsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsLinearTeamsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/linear_teams/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsLinearTeamsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsLinearTeamsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsLinearTeamsRetrieve_188Execute(r)
}

/*
EnvironmentsIntegrationsLinearTeamsRetrieve_0 Method for EnvironmentsIntegrationsLinearTeamsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsLinearTeamsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinearTeamsRetrieve_188(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsLinearTeamsRetrieve_0Request {
	return ApiEnvironmentsIntegrationsLinearTeamsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinearTeamsRetrieve_188Execute(r ApiEnvironmentsIntegrationsLinearTeamsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsLinearTeamsRetrieve_188")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/linear_teams/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsLinkedinAdsAccountsRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve Method for EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieveRequest {
	return ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinkedinAdsAccountsRetrieveExecute(r ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/linkedin_ads_accounts/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_189Execute(r)
}

/*
EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_0 Method for EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_189(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_0Request {
	return ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_189Execute(r ApiEnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsLinkedinAdsAccountsRetrieve_189")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/linkedin_ads_accounts/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve Method for EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieveRequest {
	return ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieveExecute(r ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/linkedin_ads_conversion_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_190Execute(r)
}

/*
EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_0 Method for EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_190(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_0Request {
	return ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_190Execute(r ApiEnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsLinkedinAdsConversionRulesRetrieve_190")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/linkedin_ads_conversion_rules/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsIntegrationsListRequest) Limit(limit int32) ApiEnvironmentsIntegrationsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsIntegrationsListRequest) Offset(offset int32) ApiEnvironmentsIntegrationsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsIntegrationsListRequest) Execute() (*PaginatedIntegrationList, *http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsListExecute(r)
}

/*
EnvironmentsIntegrationsList Method for EnvironmentsIntegrationsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsList(ctx context.Context, projectId string) ApiEnvironmentsIntegrationsListRequest {
	return ApiEnvironmentsIntegrationsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedIntegrationList
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsListExecute(r ApiEnvironmentsIntegrationsListRequest) (*PaginatedIntegrationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIntegrationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsIntegrationsList_0Request) Limit(limit int32) ApiEnvironmentsIntegrationsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsIntegrationsList_0Request) Offset(offset int32) ApiEnvironmentsIntegrationsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsIntegrationsList_0Request) Execute() (*PaginatedIntegrationList, *http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsList_191Execute(r)
}

/*
EnvironmentsIntegrationsList_0 Method for EnvironmentsIntegrationsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsList_191(ctx context.Context, projectId string) ApiEnvironmentsIntegrationsList_0Request {
	return ApiEnvironmentsIntegrationsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedIntegrationList
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsList_191Execute(r ApiEnvironmentsIntegrationsList_0Request) (*PaginatedIntegrationList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedIntegrationList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsList_191")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsRetrieveRequest) Execute() (*Integration, *http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsRetrieve Method for EnvironmentsIntegrationsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsRetrieveRequest {
	return ApiEnvironmentsIntegrationsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Integration
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsRetrieveExecute(r ApiEnvironmentsIntegrationsRetrieveRequest) (*Integration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Integration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsRetrieve_0Request) Execute() (*Integration, *http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsRetrieve_192Execute(r)
}

/*
EnvironmentsIntegrationsRetrieve_0 Method for EnvironmentsIntegrationsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsRetrieve_192(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsRetrieve_0Request {
	return ApiEnvironmentsIntegrationsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Integration
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsRetrieve_192Execute(r ApiEnvironmentsIntegrationsRetrieve_0Request) (*Integration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Integration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsRetrieve_192")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsTwilioPhoneNumbersRetrieveExecute(r)
}

/*
EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve Method for EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieveRequest {
	return ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsTwilioPhoneNumbersRetrieveExecute(r ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/twilio_phone_numbers/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_193Execute(r)
}

/*
EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_0 Method for EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this integration.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_193(ctx context.Context, id int32, projectId string) ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_0Request {
	return ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_193Execute(r ApiEnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIntegrationsTwilioPhoneNumbersRetrieve_193")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/integrations/{id}/twilio_phone_numbers/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsIsGeneratingDemoDataRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsIsGeneratingDemoDataRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsIsGeneratingDemoDataRetrieveExecute(r)
}

/*
EnvironmentsIsGeneratingDemoDataRetrieve Method for EnvironmentsIsGeneratingDemoDataRetrieve

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsIsGeneratingDemoDataRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsIsGeneratingDemoDataRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsIsGeneratingDemoDataRetrieveRequest {
	return ApiEnvironmentsIsGeneratingDemoDataRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsIsGeneratingDemoDataRetrieveExecute(r ApiEnvironmentsIsGeneratingDemoDataRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsIsGeneratingDemoDataRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/is_generating_demo_data/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsListRequest) Limit(limit int32) ApiEnvironmentsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsListRequest) Offset(offset int32) ApiEnvironmentsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsListRequest) Execute() (*PaginatedTeamBasicList, *http.Response, error) {
	return r.ApiService.EnvironmentsListExecute(r)
}

/*
EnvironmentsList Method for EnvironmentsList

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsList(ctx context.Context, projectId string) ApiEnvironmentsListRequest {
	return ApiEnvironmentsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedTeamBasicList
func (a *EnvironmentsAPIService) EnvironmentsListExecute(r ApiEnvironmentsListRequest) (*PaginatedTeamBasicList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTeamBasicList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsLlmAnalyticsTextReprCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	textReprRequest *TextReprRequest
}

func (r ApiEnvironmentsLlmAnalyticsTextReprCreateRequest) TextReprRequest(textReprRequest TextReprRequest) ApiEnvironmentsLlmAnalyticsTextReprCreateRequest {
	r.textReprRequest = &textReprRequest
	return r
}

func (r ApiEnvironmentsLlmAnalyticsTextReprCreateRequest) Execute() (*TextReprResponse, *http.Response, error) {
	return r.ApiService.EnvironmentsLlmAnalyticsTextReprCreateExecute(r)
}

/*
EnvironmentsLlmAnalyticsTextReprCreate Method for EnvironmentsLlmAnalyticsTextReprCreate


Generate a human-readable text representation of an LLM trace event.

This endpoint converts LLM analytics events ($ai_generation, $ai_span, $ai_embedding, or $ai_trace)
into formatted text representations suitable for display, logging, or analysis.

**Supported Event Types:**
- `$ai_generation`: Individual LLM API calls with input/output messages
- `$ai_span`: Logical spans with state transitions
- `$ai_embedding`: Embedding generation events (text input  vector)
- `$ai_trace`: Full traces with hierarchical structure

**Options:**
- `max_length`: Maximum character count (default: 4000000)
- `truncated`: Enable middle-content truncation within events (default: true)
- `truncate_buffer`: Characters at start/end when truncating (default: 1000)
- `include_markers`: Use interactive markers vs plain text indicators (default: true)
  - Frontend: set true for `<<<TRUNCATED|base64|...>>>` markers
  - Backend/LLM: set false for `... (X chars truncated) ...` text
- `collapsed`: Show summary vs full trace tree (default: false)
- `include_hierarchy`: Include tree structure for traces (default: true)
- `max_depth`: Maximum depth for hierarchical rendering (default: unlimited)
- `tools_collapse_threshold`: Number of tools before auto-collapsing list (default: 5)
  - Tool lists >5 items show `<<<TOOLS_EXPANDABLE|...>>>` marker for frontend
  - Or `[+] AVAILABLE TOOLS: N` for backend when `include_markers: false`
- `include_line_numbers`: Prefix each line with line number like L001:, L010: (default: false)

**Use Cases:**
- Frontend display: `truncated: true, include_markers: true, include_line_numbers: true`
- Backend LLM context (summary): `truncated: true, include_markers: false, collapsed: true`
- Backend LLM context (full): `truncated: false`

The response includes the formatted text and metadata about the rendering.
        

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLlmAnalyticsTextReprCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsLlmAnalyticsTextReprCreate(ctx context.Context, projectId string) ApiEnvironmentsLlmAnalyticsTextReprCreateRequest {
	return ApiEnvironmentsLlmAnalyticsTextReprCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return TextReprResponse
func (a *EnvironmentsAPIService) EnvironmentsLlmAnalyticsTextReprCreateExecute(r ApiEnvironmentsLlmAnalyticsTextReprCreateRequest) (*TextReprResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *TextReprResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLlmAnalyticsTextReprCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/llm_analytics/text_repr/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.textReprRequest == nil {
		return localVarReturnValue, nil, reportError("textReprRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.textReprRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 503 {
			var v map[string]interface{}
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsLogsAttributesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsLogsAttributesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsLogsAttributesRetrieveExecute(r)
}

/*
EnvironmentsLogsAttributesRetrieve Method for EnvironmentsLogsAttributesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLogsAttributesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsLogsAttributesRetrieve(ctx context.Context, projectId string) ApiEnvironmentsLogsAttributesRetrieveRequest {
	return ApiEnvironmentsLogsAttributesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsLogsAttributesRetrieveExecute(r ApiEnvironmentsLogsAttributesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLogsAttributesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/logs/attributes/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsLogsAttributesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsLogsAttributesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsLogsAttributesRetrieve_194Execute(r)
}

/*
EnvironmentsLogsAttributesRetrieve_0 Method for EnvironmentsLogsAttributesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLogsAttributesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsLogsAttributesRetrieve_194(ctx context.Context, projectId string) ApiEnvironmentsLogsAttributesRetrieve_0Request {
	return ApiEnvironmentsLogsAttributesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsLogsAttributesRetrieve_194Execute(r ApiEnvironmentsLogsAttributesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLogsAttributesRetrieve_194")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/logs/attributes/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsLogsQueryCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsLogsQueryCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsLogsQueryCreateExecute(r)
}

/*
EnvironmentsLogsQueryCreate Method for EnvironmentsLogsQueryCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLogsQueryCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsLogsQueryCreate(ctx context.Context, projectId string) ApiEnvironmentsLogsQueryCreateRequest {
	return ApiEnvironmentsLogsQueryCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsLogsQueryCreateExecute(r ApiEnvironmentsLogsQueryCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLogsQueryCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/logs/query/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsLogsQueryCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsLogsQueryCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsLogsQueryCreate_195Execute(r)
}

/*
EnvironmentsLogsQueryCreate_0 Method for EnvironmentsLogsQueryCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLogsQueryCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsLogsQueryCreate_195(ctx context.Context, projectId string) ApiEnvironmentsLogsQueryCreate_0Request {
	return ApiEnvironmentsLogsQueryCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsLogsQueryCreate_195Execute(r ApiEnvironmentsLogsQueryCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLogsQueryCreate_195")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/logs/query/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsLogsSparklineCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsLogsSparklineCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsLogsSparklineCreateExecute(r)
}

/*
EnvironmentsLogsSparklineCreate Method for EnvironmentsLogsSparklineCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLogsSparklineCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsLogsSparklineCreate(ctx context.Context, projectId string) ApiEnvironmentsLogsSparklineCreateRequest {
	return ApiEnvironmentsLogsSparklineCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsLogsSparklineCreateExecute(r ApiEnvironmentsLogsSparklineCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLogsSparklineCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/logs/sparkline/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsLogsSparklineCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsLogsSparklineCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsLogsSparklineCreate_196Execute(r)
}

/*
EnvironmentsLogsSparklineCreate_0 Method for EnvironmentsLogsSparklineCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLogsSparklineCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsLogsSparklineCreate_196(ctx context.Context, projectId string) ApiEnvironmentsLogsSparklineCreate_0Request {
	return ApiEnvironmentsLogsSparklineCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsLogsSparklineCreate_196Execute(r ApiEnvironmentsLogsSparklineCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLogsSparklineCreate_196")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/logs/sparkline/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsLogsValuesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsLogsValuesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsLogsValuesRetrieveExecute(r)
}

/*
EnvironmentsLogsValuesRetrieve Method for EnvironmentsLogsValuesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLogsValuesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsLogsValuesRetrieve(ctx context.Context, projectId string) ApiEnvironmentsLogsValuesRetrieveRequest {
	return ApiEnvironmentsLogsValuesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsLogsValuesRetrieveExecute(r ApiEnvironmentsLogsValuesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLogsValuesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/logs/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsLogsValuesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsLogsValuesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsLogsValuesRetrieve_197Execute(r)
}

/*
EnvironmentsLogsValuesRetrieve_0 Method for EnvironmentsLogsValuesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsLogsValuesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsLogsValuesRetrieve_197(ctx context.Context, projectId string) ApiEnvironmentsLogsValuesRetrieve_0Request {
	return ApiEnvironmentsLogsValuesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsLogsValuesRetrieve_197Execute(r ApiEnvironmentsLogsValuesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsLogsValuesRetrieve_197")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/logs/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsMaxToolsCreateAndQueryInsightCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsMaxToolsCreateAndQueryInsightCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsMaxToolsCreateAndQueryInsightCreateExecute(r)
}

/*
EnvironmentsMaxToolsCreateAndQueryInsightCreate Method for EnvironmentsMaxToolsCreateAndQueryInsightCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsMaxToolsCreateAndQueryInsightCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsMaxToolsCreateAndQueryInsightCreate(ctx context.Context, projectId string) ApiEnvironmentsMaxToolsCreateAndQueryInsightCreateRequest {
	return ApiEnvironmentsMaxToolsCreateAndQueryInsightCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsMaxToolsCreateAndQueryInsightCreateExecute(r ApiEnvironmentsMaxToolsCreateAndQueryInsightCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsMaxToolsCreateAndQueryInsightCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/max_tools/create_and_query_insight/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsMaxToolsCreateAndQueryInsightCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsMaxToolsCreateAndQueryInsightCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsMaxToolsCreateAndQueryInsightCreate_198Execute(r)
}

/*
EnvironmentsMaxToolsCreateAndQueryInsightCreate_0 Method for EnvironmentsMaxToolsCreateAndQueryInsightCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsMaxToolsCreateAndQueryInsightCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsMaxToolsCreateAndQueryInsightCreate_198(ctx context.Context, projectId string) ApiEnvironmentsMaxToolsCreateAndQueryInsightCreate_0Request {
	return ApiEnvironmentsMaxToolsCreateAndQueryInsightCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsMaxToolsCreateAndQueryInsightCreate_198Execute(r ApiEnvironmentsMaxToolsCreateAndQueryInsightCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsMaxToolsCreateAndQueryInsightCreate_198")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/max_tools/create_and_query_insight/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedTeam *PatchedTeam
}

func (r ApiEnvironmentsPartialUpdateRequest) PatchedTeam(patchedTeam PatchedTeam) ApiEnvironmentsPartialUpdateRequest {
	r.patchedTeam = &patchedTeam
	return r
}

func (r ApiEnvironmentsPartialUpdateRequest) Execute() (*Team, *http.Response, error) {
	return r.ApiService.EnvironmentsPartialUpdateExecute(r)
}

/*
EnvironmentsPartialUpdate Method for EnvironmentsPartialUpdate

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsPartialUpdateRequest {
	return ApiEnvironmentsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Team
func (a *EnvironmentsAPIService) EnvironmentsPartialUpdateExecute(r ApiEnvironmentsPartialUpdateRequest) (*Team, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Team
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTeam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	persistedFolder *PersistedFolder
}

func (r ApiEnvironmentsPersistedFolderCreateRequest) PersistedFolder(persistedFolder PersistedFolder) ApiEnvironmentsPersistedFolderCreateRequest {
	r.persistedFolder = &persistedFolder
	return r
}

func (r ApiEnvironmentsPersistedFolderCreateRequest) Execute() (*PersistedFolder, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderCreateExecute(r)
}

/*
EnvironmentsPersistedFolderCreate Method for EnvironmentsPersistedFolderCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderCreate(ctx context.Context, projectId string) ApiEnvironmentsPersistedFolderCreateRequest {
	return ApiEnvironmentsPersistedFolderCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PersistedFolder
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderCreateExecute(r ApiEnvironmentsPersistedFolderCreateRequest) (*PersistedFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersistedFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.persistedFolder == nil {
		return localVarReturnValue, nil, reportError("persistedFolder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.persistedFolder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	persistedFolder *PersistedFolder
}

func (r ApiEnvironmentsPersistedFolderCreate_0Request) PersistedFolder(persistedFolder PersistedFolder) ApiEnvironmentsPersistedFolderCreate_0Request {
	r.persistedFolder = &persistedFolder
	return r
}

func (r ApiEnvironmentsPersistedFolderCreate_0Request) Execute() (*PersistedFolder, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderCreate_199Execute(r)
}

/*
EnvironmentsPersistedFolderCreate_0 Method for EnvironmentsPersistedFolderCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderCreate_199(ctx context.Context, projectId string) ApiEnvironmentsPersistedFolderCreate_0Request {
	return ApiEnvironmentsPersistedFolderCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PersistedFolder
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderCreate_199Execute(r ApiEnvironmentsPersistedFolderCreate_0Request) (*PersistedFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersistedFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderCreate_199")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.persistedFolder == nil {
		return localVarReturnValue, nil, reportError("persistedFolder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.persistedFolder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsPersistedFolderDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderDestroyExecute(r)
}

/*
EnvironmentsPersistedFolderDestroy Method for EnvironmentsPersistedFolderDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this Persisted Folder.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsPersistedFolderDestroyRequest {
	return ApiEnvironmentsPersistedFolderDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderDestroyExecute(r ApiEnvironmentsPersistedFolderDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsPersistedFolderDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderDestroy_200Execute(r)
}

/*
EnvironmentsPersistedFolderDestroy_0 Method for EnvironmentsPersistedFolderDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this Persisted Folder.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderDestroy_200(ctx context.Context, id string, projectId string) ApiEnvironmentsPersistedFolderDestroy_0Request {
	return ApiEnvironmentsPersistedFolderDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderDestroy_200Execute(r ApiEnvironmentsPersistedFolderDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderDestroy_200")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsPersistedFolderListRequest) Limit(limit int32) ApiEnvironmentsPersistedFolderListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsPersistedFolderListRequest) Offset(offset int32) ApiEnvironmentsPersistedFolderListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsPersistedFolderListRequest) Execute() (*PaginatedPersistedFolderList, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderListExecute(r)
}

/*
EnvironmentsPersistedFolderList Method for EnvironmentsPersistedFolderList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderList(ctx context.Context, projectId string) ApiEnvironmentsPersistedFolderListRequest {
	return ApiEnvironmentsPersistedFolderListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedPersistedFolderList
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderListExecute(r ApiEnvironmentsPersistedFolderListRequest) (*PaginatedPersistedFolderList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPersistedFolderList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsPersistedFolderList_0Request) Limit(limit int32) ApiEnvironmentsPersistedFolderList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsPersistedFolderList_0Request) Offset(offset int32) ApiEnvironmentsPersistedFolderList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsPersistedFolderList_0Request) Execute() (*PaginatedPersistedFolderList, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderList_201Execute(r)
}

/*
EnvironmentsPersistedFolderList_0 Method for EnvironmentsPersistedFolderList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderList_201(ctx context.Context, projectId string) ApiEnvironmentsPersistedFolderList_0Request {
	return ApiEnvironmentsPersistedFolderList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedPersistedFolderList
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderList_201Execute(r ApiEnvironmentsPersistedFolderList_0Request) (*PaginatedPersistedFolderList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPersistedFolderList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderList_201")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedPersistedFolder *PatchedPersistedFolder
}

func (r ApiEnvironmentsPersistedFolderPartialUpdateRequest) PatchedPersistedFolder(patchedPersistedFolder PatchedPersistedFolder) ApiEnvironmentsPersistedFolderPartialUpdateRequest {
	r.patchedPersistedFolder = &patchedPersistedFolder
	return r
}

func (r ApiEnvironmentsPersistedFolderPartialUpdateRequest) Execute() (*PersistedFolder, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderPartialUpdateExecute(r)
}

/*
EnvironmentsPersistedFolderPartialUpdate Method for EnvironmentsPersistedFolderPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this Persisted Folder.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsPersistedFolderPartialUpdateRequest {
	return ApiEnvironmentsPersistedFolderPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PersistedFolder
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderPartialUpdateExecute(r ApiEnvironmentsPersistedFolderPartialUpdateRequest) (*PersistedFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersistedFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPersistedFolder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedPersistedFolder *PatchedPersistedFolder
}

func (r ApiEnvironmentsPersistedFolderPartialUpdate_0Request) PatchedPersistedFolder(patchedPersistedFolder PatchedPersistedFolder) ApiEnvironmentsPersistedFolderPartialUpdate_0Request {
	r.patchedPersistedFolder = &patchedPersistedFolder
	return r
}

func (r ApiEnvironmentsPersistedFolderPartialUpdate_0Request) Execute() (*PersistedFolder, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderPartialUpdate_202Execute(r)
}

/*
EnvironmentsPersistedFolderPartialUpdate_0 Method for EnvironmentsPersistedFolderPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this Persisted Folder.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderPartialUpdate_202(ctx context.Context, id string, projectId string) ApiEnvironmentsPersistedFolderPartialUpdate_0Request {
	return ApiEnvironmentsPersistedFolderPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PersistedFolder
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderPartialUpdate_202Execute(r ApiEnvironmentsPersistedFolderPartialUpdate_0Request) (*PersistedFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersistedFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderPartialUpdate_202")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPersistedFolder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsPersistedFolderRetrieveRequest) Execute() (*PersistedFolder, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderRetrieveExecute(r)
}

/*
EnvironmentsPersistedFolderRetrieve Method for EnvironmentsPersistedFolderRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this Persisted Folder.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsPersistedFolderRetrieveRequest {
	return ApiEnvironmentsPersistedFolderRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PersistedFolder
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderRetrieveExecute(r ApiEnvironmentsPersistedFolderRetrieveRequest) (*PersistedFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersistedFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsPersistedFolderRetrieve_0Request) Execute() (*PersistedFolder, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderRetrieve_203Execute(r)
}

/*
EnvironmentsPersistedFolderRetrieve_0 Method for EnvironmentsPersistedFolderRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this Persisted Folder.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderRetrieve_203(ctx context.Context, id string, projectId string) ApiEnvironmentsPersistedFolderRetrieve_0Request {
	return ApiEnvironmentsPersistedFolderRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PersistedFolder
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderRetrieve_203Execute(r ApiEnvironmentsPersistedFolderRetrieve_0Request) (*PersistedFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersistedFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderRetrieve_203")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	persistedFolder *PersistedFolder
}

func (r ApiEnvironmentsPersistedFolderUpdateRequest) PersistedFolder(persistedFolder PersistedFolder) ApiEnvironmentsPersistedFolderUpdateRequest {
	r.persistedFolder = &persistedFolder
	return r
}

func (r ApiEnvironmentsPersistedFolderUpdateRequest) Execute() (*PersistedFolder, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderUpdateExecute(r)
}

/*
EnvironmentsPersistedFolderUpdate Method for EnvironmentsPersistedFolderUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this Persisted Folder.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsPersistedFolderUpdateRequest {
	return ApiEnvironmentsPersistedFolderUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PersistedFolder
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderUpdateExecute(r ApiEnvironmentsPersistedFolderUpdateRequest) (*PersistedFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersistedFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.persistedFolder == nil {
		return localVarReturnValue, nil, reportError("persistedFolder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.persistedFolder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersistedFolderUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	persistedFolder *PersistedFolder
}

func (r ApiEnvironmentsPersistedFolderUpdate_0Request) PersistedFolder(persistedFolder PersistedFolder) ApiEnvironmentsPersistedFolderUpdate_0Request {
	r.persistedFolder = &persistedFolder
	return r
}

func (r ApiEnvironmentsPersistedFolderUpdate_0Request) Execute() (*PersistedFolder, *http.Response, error) {
	return r.ApiService.EnvironmentsPersistedFolderUpdate_204Execute(r)
}

/*
EnvironmentsPersistedFolderUpdate_0 Method for EnvironmentsPersistedFolderUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this Persisted Folder.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersistedFolderUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderUpdate_204(ctx context.Context, id string, projectId string) ApiEnvironmentsPersistedFolderUpdate_0Request {
	return ApiEnvironmentsPersistedFolderUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PersistedFolder
func (a *EnvironmentsAPIService) EnvironmentsPersistedFolderUpdate_204Execute(r ApiEnvironmentsPersistedFolderUpdate_0Request) (*PersistedFolder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PersistedFolder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersistedFolderUpdate_204")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persisted_folder/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.persistedFolder == nil {
		return localVarReturnValue, nil, reportError("persistedFolder is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.persistedFolder
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsActivityRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsActivityRetrieveRequest) Format(format string) ApiEnvironmentsPersonsActivityRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsActivityRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsActivityRetrieveExecute(r)
}

/*
EnvironmentsPersonsActivityRetrieve Method for EnvironmentsPersonsActivityRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsActivityRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsActivityRetrieve(ctx context.Context, projectId string) ApiEnvironmentsPersonsActivityRetrieveRequest {
	return ApiEnvironmentsPersonsActivityRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsActivityRetrieveExecute(r ApiEnvironmentsPersonsActivityRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsActivityRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsActivityRetrieve2Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsActivityRetrieve2Request) Format(format string) ApiEnvironmentsPersonsActivityRetrieve2Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsActivityRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsActivityRetrieve2Execute(r)
}

/*
EnvironmentsPersonsActivityRetrieve2 Method for EnvironmentsPersonsActivityRetrieve2

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsActivityRetrieve2Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsActivityRetrieve2(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsActivityRetrieve2Request {
	return ApiEnvironmentsPersonsActivityRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsActivityRetrieve2Execute(r ApiEnvironmentsPersonsActivityRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsActivityRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsActivityRetrieve2_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsActivityRetrieve2_0Request) Format(format string) ApiEnvironmentsPersonsActivityRetrieve2_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsActivityRetrieve2_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsActivityRetrieve2_205Execute(r)
}

/*
EnvironmentsPersonsActivityRetrieve2_0 Method for EnvironmentsPersonsActivityRetrieve2_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsActivityRetrieve2_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsActivityRetrieve2_205(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsActivityRetrieve2_0Request {
	return ApiEnvironmentsPersonsActivityRetrieve2_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsActivityRetrieve2_205Execute(r ApiEnvironmentsPersonsActivityRetrieve2_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsActivityRetrieve2_205")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsActivityRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsActivityRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsActivityRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsActivityRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsActivityRetrieve_206Execute(r)
}

/*
EnvironmentsPersonsActivityRetrieve_0 Method for EnvironmentsPersonsActivityRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsActivityRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsActivityRetrieve_206(ctx context.Context, projectId string) ApiEnvironmentsPersonsActivityRetrieve_0Request {
	return ApiEnvironmentsPersonsActivityRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsActivityRetrieve_206Execute(r ApiEnvironmentsPersonsActivityRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsActivityRetrieve_206")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsBulkDeleteCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	deleteEvents *bool
	distinctIds *map[string]interface{}
	format *string
	ids *map[string]interface{}
	person *Person
}

// If true, a task to delete all events associated with this person will be created and queued. The task does not run immediately and instead is batched together and at 5AM UTC every Sunday
func (r ApiEnvironmentsPersonsBulkDeleteCreateRequest) DeleteEvents(deleteEvents bool) ApiEnvironmentsPersonsBulkDeleteCreateRequest {
	r.deleteEvents = &deleteEvents
	return r
}

// A list of distinct IDs, up to 1000 of them. We&#39;ll delete all persons associated with those distinct IDs.
func (r ApiEnvironmentsPersonsBulkDeleteCreateRequest) DistinctIds(distinctIds map[string]interface{}) ApiEnvironmentsPersonsBulkDeleteCreateRequest {
	r.distinctIds = &distinctIds
	return r
}

func (r ApiEnvironmentsPersonsBulkDeleteCreateRequest) Format(format string) ApiEnvironmentsPersonsBulkDeleteCreateRequest {
	r.format = &format
	return r
}

// A list of PostHog person IDs, up to 1000 of them. We&#39;ll delete all the persons listed.
func (r ApiEnvironmentsPersonsBulkDeleteCreateRequest) Ids(ids map[string]interface{}) ApiEnvironmentsPersonsBulkDeleteCreateRequest {
	r.ids = &ids
	return r
}

func (r ApiEnvironmentsPersonsBulkDeleteCreateRequest) Person(person Person) ApiEnvironmentsPersonsBulkDeleteCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsBulkDeleteCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsBulkDeleteCreateExecute(r)
}

/*
EnvironmentsPersonsBulkDeleteCreate Method for EnvironmentsPersonsBulkDeleteCreate

This endpoint allows you to bulk delete persons, either by the PostHog person IDs or by distinct IDs. You can pass in a maximum of 1000 IDs per call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsBulkDeleteCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsBulkDeleteCreate(ctx context.Context, projectId string) ApiEnvironmentsPersonsBulkDeleteCreateRequest {
	return ApiEnvironmentsPersonsBulkDeleteCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsBulkDeleteCreateExecute(r ApiEnvironmentsPersonsBulkDeleteCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsBulkDeleteCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/bulk_delete/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", r.deleteEvents, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", defaultValue, "form", "")
        r.deleteEvents = &defaultValue
	}
	if r.distinctIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct_ids", r.distinctIds, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsBulkDeleteCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	deleteEvents *bool
	distinctIds *map[string]interface{}
	format *string
	ids *map[string]interface{}
	person *Person
}

// If true, a task to delete all events associated with this person will be created and queued. The task does not run immediately and instead is batched together and at 5AM UTC every Sunday
func (r ApiEnvironmentsPersonsBulkDeleteCreate_0Request) DeleteEvents(deleteEvents bool) ApiEnvironmentsPersonsBulkDeleteCreate_0Request {
	r.deleteEvents = &deleteEvents
	return r
}

// A list of distinct IDs, up to 1000 of them. We&#39;ll delete all persons associated with those distinct IDs.
func (r ApiEnvironmentsPersonsBulkDeleteCreate_0Request) DistinctIds(distinctIds map[string]interface{}) ApiEnvironmentsPersonsBulkDeleteCreate_0Request {
	r.distinctIds = &distinctIds
	return r
}

func (r ApiEnvironmentsPersonsBulkDeleteCreate_0Request) Format(format string) ApiEnvironmentsPersonsBulkDeleteCreate_0Request {
	r.format = &format
	return r
}

// A list of PostHog person IDs, up to 1000 of them. We&#39;ll delete all the persons listed.
func (r ApiEnvironmentsPersonsBulkDeleteCreate_0Request) Ids(ids map[string]interface{}) ApiEnvironmentsPersonsBulkDeleteCreate_0Request {
	r.ids = &ids
	return r
}

func (r ApiEnvironmentsPersonsBulkDeleteCreate_0Request) Person(person Person) ApiEnvironmentsPersonsBulkDeleteCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsBulkDeleteCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsBulkDeleteCreate_207Execute(r)
}

/*
EnvironmentsPersonsBulkDeleteCreate_0 Method for EnvironmentsPersonsBulkDeleteCreate_0

This endpoint allows you to bulk delete persons, either by the PostHog person IDs or by distinct IDs. You can pass in a maximum of 1000 IDs per call.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsBulkDeleteCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsBulkDeleteCreate_207(ctx context.Context, projectId string) ApiEnvironmentsPersonsBulkDeleteCreate_0Request {
	return ApiEnvironmentsPersonsBulkDeleteCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsBulkDeleteCreate_207Execute(r ApiEnvironmentsPersonsBulkDeleteCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsBulkDeleteCreate_207")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/bulk_delete/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", r.deleteEvents, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", defaultValue, "form", "")
        r.deleteEvents = &defaultValue
	}
	if r.distinctIds != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct_ids", r.distinctIds, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.ids != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ids", r.ids, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsCohortsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsCohortsRetrieveRequest) Format(format string) ApiEnvironmentsPersonsCohortsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsCohortsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsCohortsRetrieveExecute(r)
}

/*
EnvironmentsPersonsCohortsRetrieve Method for EnvironmentsPersonsCohortsRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsCohortsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsCohortsRetrieve(ctx context.Context, projectId string) ApiEnvironmentsPersonsCohortsRetrieveRequest {
	return ApiEnvironmentsPersonsCohortsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsCohortsRetrieveExecute(r ApiEnvironmentsPersonsCohortsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsCohortsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/cohorts/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsCohortsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsCohortsRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsCohortsRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsCohortsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsCohortsRetrieve_208Execute(r)
}

/*
EnvironmentsPersonsCohortsRetrieve_0 Method for EnvironmentsPersonsCohortsRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsCohortsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsCohortsRetrieve_208(ctx context.Context, projectId string) ApiEnvironmentsPersonsCohortsRetrieve_0Request {
	return ApiEnvironmentsPersonsCohortsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsCohortsRetrieve_208Execute(r ApiEnvironmentsPersonsCohortsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsCohortsRetrieve_208")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/cohorts/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsDeleteEventsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsDeleteEventsCreateRequest) Format(format string) ApiEnvironmentsPersonsDeleteEventsCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsDeleteEventsCreateRequest) Person(person Person) ApiEnvironmentsPersonsDeleteEventsCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsDeleteEventsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsDeleteEventsCreateExecute(r)
}

/*
EnvironmentsPersonsDeleteEventsCreate Method for EnvironmentsPersonsDeleteEventsCreate

Queue deletion of all events associated with this person. The task runs during non-peak hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsDeleteEventsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeleteEventsCreate(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsDeleteEventsCreateRequest {
	return ApiEnvironmentsPersonsDeleteEventsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeleteEventsCreateExecute(r ApiEnvironmentsPersonsDeleteEventsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsDeleteEventsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/delete_events/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsDeleteEventsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsDeleteEventsCreate_0Request) Format(format string) ApiEnvironmentsPersonsDeleteEventsCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsDeleteEventsCreate_0Request) Person(person Person) ApiEnvironmentsPersonsDeleteEventsCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsDeleteEventsCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsDeleteEventsCreate_209Execute(r)
}

/*
EnvironmentsPersonsDeleteEventsCreate_0 Method for EnvironmentsPersonsDeleteEventsCreate_0

Queue deletion of all events associated with this person. The task runs during non-peak hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsDeleteEventsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeleteEventsCreate_209(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsDeleteEventsCreate_0Request {
	return ApiEnvironmentsPersonsDeleteEventsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeleteEventsCreate_209Execute(r ApiEnvironmentsPersonsDeleteEventsCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsDeleteEventsCreate_209")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/delete_events/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsDeletePropertyCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	unset *string
	id int32
	projectId string
	format *string
	person *Person
}

// Specify the property key to delete
func (r ApiEnvironmentsPersonsDeletePropertyCreateRequest) Unset(unset string) ApiEnvironmentsPersonsDeletePropertyCreateRequest {
	r.unset = &unset
	return r
}

func (r ApiEnvironmentsPersonsDeletePropertyCreateRequest) Format(format string) ApiEnvironmentsPersonsDeletePropertyCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsDeletePropertyCreateRequest) Person(person Person) ApiEnvironmentsPersonsDeletePropertyCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsDeletePropertyCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsDeletePropertyCreateExecute(r)
}

/*
EnvironmentsPersonsDeletePropertyCreate Method for EnvironmentsPersonsDeletePropertyCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsDeletePropertyCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeletePropertyCreate(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsDeletePropertyCreateRequest {
	return ApiEnvironmentsPersonsDeletePropertyCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeletePropertyCreateExecute(r ApiEnvironmentsPersonsDeletePropertyCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsDeletePropertyCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/delete_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unset == nil {
		return nil, reportError("unset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "$unset", r.unset, "form", "")
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsDeletePropertyCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	unset *string
	id int32
	projectId string
	format *string
	person *Person
}

// Specify the property key to delete
func (r ApiEnvironmentsPersonsDeletePropertyCreate_0Request) Unset(unset string) ApiEnvironmentsPersonsDeletePropertyCreate_0Request {
	r.unset = &unset
	return r
}

func (r ApiEnvironmentsPersonsDeletePropertyCreate_0Request) Format(format string) ApiEnvironmentsPersonsDeletePropertyCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsDeletePropertyCreate_0Request) Person(person Person) ApiEnvironmentsPersonsDeletePropertyCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsDeletePropertyCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsDeletePropertyCreate_210Execute(r)
}

/*
EnvironmentsPersonsDeletePropertyCreate_0 Method for EnvironmentsPersonsDeletePropertyCreate_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsDeletePropertyCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeletePropertyCreate_210(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsDeletePropertyCreate_0Request {
	return ApiEnvironmentsPersonsDeletePropertyCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeletePropertyCreate_210Execute(r ApiEnvironmentsPersonsDeletePropertyCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsDeletePropertyCreate_210")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/delete_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unset == nil {
		return nil, reportError("unset is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "$unset", r.unset, "form", "")
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsDeleteRecordingsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsDeleteRecordingsCreateRequest) Format(format string) ApiEnvironmentsPersonsDeleteRecordingsCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsDeleteRecordingsCreateRequest) Person(person Person) ApiEnvironmentsPersonsDeleteRecordingsCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsDeleteRecordingsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsDeleteRecordingsCreateExecute(r)
}

/*
EnvironmentsPersonsDeleteRecordingsCreate Method for EnvironmentsPersonsDeleteRecordingsCreate

Queue deletion of all recordings associated with this person.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsDeleteRecordingsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeleteRecordingsCreate(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsDeleteRecordingsCreateRequest {
	return ApiEnvironmentsPersonsDeleteRecordingsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeleteRecordingsCreateExecute(r ApiEnvironmentsPersonsDeleteRecordingsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsDeleteRecordingsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/delete_recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request) Format(format string) ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request) Person(person Person) ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsDeleteRecordingsCreate_211Execute(r)
}

/*
EnvironmentsPersonsDeleteRecordingsCreate_0 Method for EnvironmentsPersonsDeleteRecordingsCreate_0

Queue deletion of all recordings associated with this person.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeleteRecordingsCreate_211(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request {
	return ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsDeleteRecordingsCreate_211Execute(r ApiEnvironmentsPersonsDeleteRecordingsCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsDeleteRecordingsCreate_211")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/delete_recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	deleteEvents *bool
	format *string
}

// If true, a task to delete all events associated with this person will be created and queued. The task does not run immediately and instead is batched together and at 5AM UTC every Sunday
func (r ApiEnvironmentsPersonsDestroyRequest) DeleteEvents(deleteEvents bool) ApiEnvironmentsPersonsDestroyRequest {
	r.deleteEvents = &deleteEvents
	return r
}

func (r ApiEnvironmentsPersonsDestroyRequest) Format(format string) ApiEnvironmentsPersonsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsDestroyExecute(r)
}

/*
EnvironmentsPersonsDestroy Method for EnvironmentsPersonsDestroy

Use this endpoint to delete individual persons. For bulk deletion, use the bulk_delete endpoint instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsDestroy(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsDestroyRequest {
	return ApiEnvironmentsPersonsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsDestroyExecute(r ApiEnvironmentsPersonsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", r.deleteEvents, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", defaultValue, "form", "")
        r.deleteEvents = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	deleteEvents *bool
	format *string
}

// If true, a task to delete all events associated with this person will be created and queued. The task does not run immediately and instead is batched together and at 5AM UTC every Sunday
func (r ApiEnvironmentsPersonsDestroy_0Request) DeleteEvents(deleteEvents bool) ApiEnvironmentsPersonsDestroy_0Request {
	r.deleteEvents = &deleteEvents
	return r
}

func (r ApiEnvironmentsPersonsDestroy_0Request) Format(format string) ApiEnvironmentsPersonsDestroy_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsDestroy_212Execute(r)
}

/*
EnvironmentsPersonsDestroy_0 Method for EnvironmentsPersonsDestroy_0

Use this endpoint to delete individual persons. For bulk deletion, use the bulk_delete endpoint instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsDestroy_212(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsDestroy_0Request {
	return ApiEnvironmentsPersonsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsDestroy_212Execute(r ApiEnvironmentsPersonsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsDestroy_212")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deleteEvents != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", r.deleteEvents, "form", "")
	} else {
        var defaultValue bool = false
        parameterAddToHeaderOrQuery(localVarQueryParams, "delete_events", defaultValue, "form", "")
        r.deleteEvents = &defaultValue
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsFunnelCorrelationCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsFunnelCorrelationCreateRequest) Format(format string) ApiEnvironmentsPersonsFunnelCorrelationCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsFunnelCorrelationCreateRequest) Person(person Person) ApiEnvironmentsPersonsFunnelCorrelationCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsFunnelCorrelationCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsFunnelCorrelationCreateExecute(r)
}

/*
EnvironmentsPersonsFunnelCorrelationCreate Method for EnvironmentsPersonsFunnelCorrelationCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsFunnelCorrelationCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCorrelationCreate(ctx context.Context, projectId string) ApiEnvironmentsPersonsFunnelCorrelationCreateRequest {
	return ApiEnvironmentsPersonsFunnelCorrelationCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCorrelationCreateExecute(r ApiEnvironmentsPersonsFunnelCorrelationCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsFunnelCorrelationCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/funnel/correlation/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request) Format(format string) ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request) Person(person Person) ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsFunnelCorrelationCreate_213Execute(r)
}

/*
EnvironmentsPersonsFunnelCorrelationCreate_0 Method for EnvironmentsPersonsFunnelCorrelationCreate_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCorrelationCreate_213(ctx context.Context, projectId string) ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request {
	return ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCorrelationCreate_213Execute(r ApiEnvironmentsPersonsFunnelCorrelationCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsFunnelCorrelationCreate_213")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/funnel/correlation/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsFunnelCorrelationRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsFunnelCorrelationRetrieveRequest) Format(format string) ApiEnvironmentsPersonsFunnelCorrelationRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsFunnelCorrelationRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsFunnelCorrelationRetrieveExecute(r)
}

/*
EnvironmentsPersonsFunnelCorrelationRetrieve Method for EnvironmentsPersonsFunnelCorrelationRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsFunnelCorrelationRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCorrelationRetrieve(ctx context.Context, projectId string) ApiEnvironmentsPersonsFunnelCorrelationRetrieveRequest {
	return ApiEnvironmentsPersonsFunnelCorrelationRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCorrelationRetrieveExecute(r ApiEnvironmentsPersonsFunnelCorrelationRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsFunnelCorrelationRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/funnel/correlation/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsFunnelCorrelationRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsFunnelCorrelationRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsFunnelCorrelationRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsFunnelCorrelationRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsFunnelCorrelationRetrieve_214Execute(r)
}

/*
EnvironmentsPersonsFunnelCorrelationRetrieve_0 Method for EnvironmentsPersonsFunnelCorrelationRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsFunnelCorrelationRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCorrelationRetrieve_214(ctx context.Context, projectId string) ApiEnvironmentsPersonsFunnelCorrelationRetrieve_0Request {
	return ApiEnvironmentsPersonsFunnelCorrelationRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCorrelationRetrieve_214Execute(r ApiEnvironmentsPersonsFunnelCorrelationRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsFunnelCorrelationRetrieve_214")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/funnel/correlation/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsFunnelCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsFunnelCreateRequest) Format(format string) ApiEnvironmentsPersonsFunnelCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsFunnelCreateRequest) Person(person Person) ApiEnvironmentsPersonsFunnelCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsFunnelCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsFunnelCreateExecute(r)
}

/*
EnvironmentsPersonsFunnelCreate Method for EnvironmentsPersonsFunnelCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsFunnelCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCreate(ctx context.Context, projectId string) ApiEnvironmentsPersonsFunnelCreateRequest {
	return ApiEnvironmentsPersonsFunnelCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCreateExecute(r ApiEnvironmentsPersonsFunnelCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsFunnelCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/funnel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsFunnelCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsFunnelCreate_0Request) Format(format string) ApiEnvironmentsPersonsFunnelCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsFunnelCreate_0Request) Person(person Person) ApiEnvironmentsPersonsFunnelCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsFunnelCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsFunnelCreate_215Execute(r)
}

/*
EnvironmentsPersonsFunnelCreate_0 Method for EnvironmentsPersonsFunnelCreate_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsFunnelCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCreate_215(ctx context.Context, projectId string) ApiEnvironmentsPersonsFunnelCreate_0Request {
	return ApiEnvironmentsPersonsFunnelCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelCreate_215Execute(r ApiEnvironmentsPersonsFunnelCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsFunnelCreate_215")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/funnel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsFunnelRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsFunnelRetrieveRequest) Format(format string) ApiEnvironmentsPersonsFunnelRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsFunnelRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsFunnelRetrieveExecute(r)
}

/*
EnvironmentsPersonsFunnelRetrieve Method for EnvironmentsPersonsFunnelRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsFunnelRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelRetrieve(ctx context.Context, projectId string) ApiEnvironmentsPersonsFunnelRetrieveRequest {
	return ApiEnvironmentsPersonsFunnelRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelRetrieveExecute(r ApiEnvironmentsPersonsFunnelRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsFunnelRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/funnel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsFunnelRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsFunnelRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsFunnelRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsFunnelRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsFunnelRetrieve_216Execute(r)
}

/*
EnvironmentsPersonsFunnelRetrieve_0 Method for EnvironmentsPersonsFunnelRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsFunnelRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelRetrieve_216(ctx context.Context, projectId string) ApiEnvironmentsPersonsFunnelRetrieve_0Request {
	return ApiEnvironmentsPersonsFunnelRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsFunnelRetrieve_216Execute(r ApiEnvironmentsPersonsFunnelRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsFunnelRetrieve_216")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/funnel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsLifecycleRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsLifecycleRetrieveRequest) Format(format string) ApiEnvironmentsPersonsLifecycleRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsLifecycleRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsLifecycleRetrieveExecute(r)
}

/*
EnvironmentsPersonsLifecycleRetrieve Method for EnvironmentsPersonsLifecycleRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsLifecycleRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsLifecycleRetrieve(ctx context.Context, projectId string) ApiEnvironmentsPersonsLifecycleRetrieveRequest {
	return ApiEnvironmentsPersonsLifecycleRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsLifecycleRetrieveExecute(r ApiEnvironmentsPersonsLifecycleRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsLifecycleRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/lifecycle/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsLifecycleRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsLifecycleRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsLifecycleRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsLifecycleRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsLifecycleRetrieve_217Execute(r)
}

/*
EnvironmentsPersonsLifecycleRetrieve_0 Method for EnvironmentsPersonsLifecycleRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsLifecycleRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsLifecycleRetrieve_217(ctx context.Context, projectId string) ApiEnvironmentsPersonsLifecycleRetrieve_0Request {
	return ApiEnvironmentsPersonsLifecycleRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsLifecycleRetrieve_217Execute(r ApiEnvironmentsPersonsLifecycleRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsLifecycleRetrieve_217")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/lifecycle/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	distinctId *string
	email *string
	format *string
	limit *int32
	offset *int32
	properties *[]Property
	search *string
}

// Filter list by distinct id.
func (r ApiEnvironmentsPersonsListRequest) DistinctId(distinctId string) ApiEnvironmentsPersonsListRequest {
	r.distinctId = &distinctId
	return r
}

// Filter persons by email (exact match)
func (r ApiEnvironmentsPersonsListRequest) Email(email string) ApiEnvironmentsPersonsListRequest {
	r.email = &email
	return r
}

func (r ApiEnvironmentsPersonsListRequest) Format(format string) ApiEnvironmentsPersonsListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsPersonsListRequest) Limit(limit int32) ApiEnvironmentsPersonsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsPersonsListRequest) Offset(offset int32) ApiEnvironmentsPersonsListRequest {
	r.offset = &offset
	return r
}

// Filter Persons by person properties.
func (r ApiEnvironmentsPersonsListRequest) Properties(properties []Property) ApiEnvironmentsPersonsListRequest {
	r.properties = &properties
	return r
}

// Search persons, either by email (full text search) or distinct_id (exact match).
func (r ApiEnvironmentsPersonsListRequest) Search(search string) ApiEnvironmentsPersonsListRequest {
	r.search = &search
	return r
}

func (r ApiEnvironmentsPersonsListRequest) Execute() (*PaginatedPersonList, *http.Response, error) {
	return r.ApiService.EnvironmentsPersonsListExecute(r)
}

/*
EnvironmentsPersonsList Method for EnvironmentsPersonsList

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsList(ctx context.Context, projectId string) ApiEnvironmentsPersonsListRequest {
	return ApiEnvironmentsPersonsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedPersonList
func (a *EnvironmentsAPIService) EnvironmentsPersonsListExecute(r ApiEnvironmentsPersonsListRequest) (*PaginatedPersonList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPersonList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinctId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct_id", r.distinctId, "form", "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	distinctId *string
	email *string
	format *string
	limit *int32
	offset *int32
	properties *[]Property
	search *string
}

// Filter list by distinct id.
func (r ApiEnvironmentsPersonsList_0Request) DistinctId(distinctId string) ApiEnvironmentsPersonsList_0Request {
	r.distinctId = &distinctId
	return r
}

// Filter persons by email (exact match)
func (r ApiEnvironmentsPersonsList_0Request) Email(email string) ApiEnvironmentsPersonsList_0Request {
	r.email = &email
	return r
}

func (r ApiEnvironmentsPersonsList_0Request) Format(format string) ApiEnvironmentsPersonsList_0Request {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsPersonsList_0Request) Limit(limit int32) ApiEnvironmentsPersonsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsPersonsList_0Request) Offset(offset int32) ApiEnvironmentsPersonsList_0Request {
	r.offset = &offset
	return r
}

// Filter Persons by person properties.
func (r ApiEnvironmentsPersonsList_0Request) Properties(properties []Property) ApiEnvironmentsPersonsList_0Request {
	r.properties = &properties
	return r
}

// Search persons, either by email (full text search) or distinct_id (exact match).
func (r ApiEnvironmentsPersonsList_0Request) Search(search string) ApiEnvironmentsPersonsList_0Request {
	r.search = &search
	return r
}

func (r ApiEnvironmentsPersonsList_0Request) Execute() (*PaginatedPersonList, *http.Response, error) {
	return r.ApiService.EnvironmentsPersonsList_218Execute(r)
}

/*
EnvironmentsPersonsList_0 Method for EnvironmentsPersonsList_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsList_218(ctx context.Context, projectId string) ApiEnvironmentsPersonsList_0Request {
	return ApiEnvironmentsPersonsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedPersonList
func (a *EnvironmentsAPIService) EnvironmentsPersonsList_218Execute(r ApiEnvironmentsPersonsList_0Request) (*PaginatedPersonList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPersonList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsList_218")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.distinctId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "distinct_id", r.distinctId, "form", "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.properties != nil {
		t := *r.properties
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "properties", s.Index(i).Interface(), "form", "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "properties", t, "form", "multi")
		}
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	patchedPerson *PatchedPerson
}

func (r ApiEnvironmentsPersonsPartialUpdateRequest) Format(format string) ApiEnvironmentsPersonsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsPartialUpdateRequest) PatchedPerson(patchedPerson PatchedPerson) ApiEnvironmentsPersonsPartialUpdateRequest {
	r.patchedPerson = &patchedPerson
	return r
}

func (r ApiEnvironmentsPersonsPartialUpdateRequest) Execute() (*Person, *http.Response, error) {
	return r.ApiService.EnvironmentsPersonsPartialUpdateExecute(r)
}

/*
EnvironmentsPersonsPartialUpdate Method for EnvironmentsPersonsPartialUpdate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsPartialUpdateRequest {
	return ApiEnvironmentsPersonsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *EnvironmentsAPIService) EnvironmentsPersonsPartialUpdateExecute(r ApiEnvironmentsPersonsPartialUpdateRequest) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPerson
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	patchedPerson *PatchedPerson
}

func (r ApiEnvironmentsPersonsPartialUpdate_0Request) Format(format string) ApiEnvironmentsPersonsPartialUpdate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsPartialUpdate_0Request) PatchedPerson(patchedPerson PatchedPerson) ApiEnvironmentsPersonsPartialUpdate_0Request {
	r.patchedPerson = &patchedPerson
	return r
}

func (r ApiEnvironmentsPersonsPartialUpdate_0Request) Execute() (*Person, *http.Response, error) {
	return r.ApiService.EnvironmentsPersonsPartialUpdate_219Execute(r)
}

/*
EnvironmentsPersonsPartialUpdate_0 Method for EnvironmentsPersonsPartialUpdate_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsPartialUpdate_219(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsPartialUpdate_0Request {
	return ApiEnvironmentsPersonsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *EnvironmentsAPIService) EnvironmentsPersonsPartialUpdate_219Execute(r ApiEnvironmentsPersonsPartialUpdate_0Request) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsPartialUpdate_219")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedPerson
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsPropertiesTimelineRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsPropertiesTimelineRetrieveRequest) Format(format string) ApiEnvironmentsPersonsPropertiesTimelineRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsPropertiesTimelineRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsPropertiesTimelineRetrieveExecute(r)
}

/*
EnvironmentsPersonsPropertiesTimelineRetrieve Method for EnvironmentsPersonsPropertiesTimelineRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsPropertiesTimelineRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsPropertiesTimelineRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsPropertiesTimelineRetrieveRequest {
	return ApiEnvironmentsPersonsPropertiesTimelineRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsPropertiesTimelineRetrieveExecute(r ApiEnvironmentsPersonsPropertiesTimelineRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsPropertiesTimelineRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/properties_timeline/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsPropertiesTimelineRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsPropertiesTimelineRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsPropertiesTimelineRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsPropertiesTimelineRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsPropertiesTimelineRetrieve_220Execute(r)
}

/*
EnvironmentsPersonsPropertiesTimelineRetrieve_0 Method for EnvironmentsPersonsPropertiesTimelineRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsPropertiesTimelineRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsPropertiesTimelineRetrieve_220(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsPropertiesTimelineRetrieve_0Request {
	return ApiEnvironmentsPersonsPropertiesTimelineRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsPropertiesTimelineRetrieve_220Execute(r ApiEnvironmentsPersonsPropertiesTimelineRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsPropertiesTimelineRetrieve_220")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/properties_timeline/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest) Format(format string) ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest) Person(person Person) ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsResetPersonDistinctIdCreateExecute(r)
}

/*
EnvironmentsPersonsResetPersonDistinctIdCreate Method for EnvironmentsPersonsResetPersonDistinctIdCreate

Reset a distinct_id for a deleted person. This allows the distinct_id to be used again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsResetPersonDistinctIdCreate(ctx context.Context, projectId string) ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest {
	return ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsResetPersonDistinctIdCreateExecute(r ApiEnvironmentsPersonsResetPersonDistinctIdCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsResetPersonDistinctIdCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/reset_person_distinct_id/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request) Format(format string) ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request) Person(person Person) ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsResetPersonDistinctIdCreate_221Execute(r)
}

/*
EnvironmentsPersonsResetPersonDistinctIdCreate_0 Method for EnvironmentsPersonsResetPersonDistinctIdCreate_0

Reset a distinct_id for a deleted person. This allows the distinct_id to be used again.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsResetPersonDistinctIdCreate_221(ctx context.Context, projectId string) ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request {
	return ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsResetPersonDistinctIdCreate_221Execute(r ApiEnvironmentsPersonsResetPersonDistinctIdCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsResetPersonDistinctIdCreate_221")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/reset_person_distinct_id/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsRetrieveRequest) Format(format string) ApiEnvironmentsPersonsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsRetrieveRequest) Execute() (*Person, *http.Response, error) {
	return r.ApiService.EnvironmentsPersonsRetrieveExecute(r)
}

/*
EnvironmentsPersonsRetrieve Method for EnvironmentsPersonsRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsRetrieveRequest {
	return ApiEnvironmentsPersonsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *EnvironmentsAPIService) EnvironmentsPersonsRetrieveExecute(r ApiEnvironmentsPersonsRetrieveRequest) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsRetrieve_0Request) Execute() (*Person, *http.Response, error) {
	return r.ApiService.EnvironmentsPersonsRetrieve_222Execute(r)
}

/*
EnvironmentsPersonsRetrieve_0 Method for EnvironmentsPersonsRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsRetrieve_222(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsRetrieve_0Request {
	return ApiEnvironmentsPersonsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *EnvironmentsAPIService) EnvironmentsPersonsRetrieve_222Execute(r ApiEnvironmentsPersonsRetrieve_0Request) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsRetrieve_222")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsSplitCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsSplitCreateRequest) Format(format string) ApiEnvironmentsPersonsSplitCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsSplitCreateRequest) Person(person Person) ApiEnvironmentsPersonsSplitCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsSplitCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsSplitCreateExecute(r)
}

/*
EnvironmentsPersonsSplitCreate Method for EnvironmentsPersonsSplitCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsSplitCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsSplitCreate(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsSplitCreateRequest {
	return ApiEnvironmentsPersonsSplitCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsSplitCreateExecute(r ApiEnvironmentsPersonsSplitCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsSplitCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/split/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsSplitCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsSplitCreate_0Request) Format(format string) ApiEnvironmentsPersonsSplitCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsSplitCreate_0Request) Person(person Person) ApiEnvironmentsPersonsSplitCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsSplitCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsSplitCreate_223Execute(r)
}

/*
EnvironmentsPersonsSplitCreate_0 Method for EnvironmentsPersonsSplitCreate_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsSplitCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsSplitCreate_223(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsSplitCreate_0Request {
	return ApiEnvironmentsPersonsSplitCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsSplitCreate_223Execute(r ApiEnvironmentsPersonsSplitCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsSplitCreate_223")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/split/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsStickinessRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsStickinessRetrieveRequest) Format(format string) ApiEnvironmentsPersonsStickinessRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsStickinessRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsStickinessRetrieveExecute(r)
}

/*
EnvironmentsPersonsStickinessRetrieve Method for EnvironmentsPersonsStickinessRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsStickinessRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsStickinessRetrieve(ctx context.Context, projectId string) ApiEnvironmentsPersonsStickinessRetrieveRequest {
	return ApiEnvironmentsPersonsStickinessRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsStickinessRetrieveExecute(r ApiEnvironmentsPersonsStickinessRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsStickinessRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/stickiness/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsStickinessRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsStickinessRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsStickinessRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsStickinessRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsStickinessRetrieve_224Execute(r)
}

/*
EnvironmentsPersonsStickinessRetrieve_0 Method for EnvironmentsPersonsStickinessRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsStickinessRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsStickinessRetrieve_224(ctx context.Context, projectId string) ApiEnvironmentsPersonsStickinessRetrieve_0Request {
	return ApiEnvironmentsPersonsStickinessRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsStickinessRetrieve_224Execute(r ApiEnvironmentsPersonsStickinessRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsStickinessRetrieve_224")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/stickiness/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsTrendsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsTrendsRetrieveRequest) Format(format string) ApiEnvironmentsPersonsTrendsRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsTrendsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsTrendsRetrieveExecute(r)
}

/*
EnvironmentsPersonsTrendsRetrieve Method for EnvironmentsPersonsTrendsRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsTrendsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsTrendsRetrieve(ctx context.Context, projectId string) ApiEnvironmentsPersonsTrendsRetrieveRequest {
	return ApiEnvironmentsPersonsTrendsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsTrendsRetrieveExecute(r ApiEnvironmentsPersonsTrendsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsTrendsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/trends/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsTrendsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsTrendsRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsTrendsRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsTrendsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsTrendsRetrieve_225Execute(r)
}

/*
EnvironmentsPersonsTrendsRetrieve_0 Method for EnvironmentsPersonsTrendsRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsTrendsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsTrendsRetrieve_225(ctx context.Context, projectId string) ApiEnvironmentsPersonsTrendsRetrieve_0Request {
	return ApiEnvironmentsPersonsTrendsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsTrendsRetrieve_225Execute(r ApiEnvironmentsPersonsTrendsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsTrendsRetrieve_225")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/trends/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsUpdateRequest) Format(format string) ApiEnvironmentsPersonsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsUpdateRequest) Person(person Person) ApiEnvironmentsPersonsUpdateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsUpdateRequest) Execute() (*Person, *http.Response, error) {
	return r.ApiService.EnvironmentsPersonsUpdateExecute(r)
}

/*
EnvironmentsPersonsUpdate Method for EnvironmentsPersonsUpdate

Only for setting properties on the person. "properties" from the request data will be updated via a "$set" event.
This means that only the properties listed will be updated, but other properties won't be removed nor updated.
If you would like to remove a property use the `delete_property` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsUpdateRequest {
	return ApiEnvironmentsPersonsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *EnvironmentsAPIService) EnvironmentsPersonsUpdateExecute(r ApiEnvironmentsPersonsUpdateRequest) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsUpdatePropertyCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	key *string
	projectId string
	value *interface{}
	format *string
	person *Person
}

// Specify the property key
func (r ApiEnvironmentsPersonsUpdatePropertyCreateRequest) Key(key string) ApiEnvironmentsPersonsUpdatePropertyCreateRequest {
	r.key = &key
	return r
}

// Specify the property value
func (r ApiEnvironmentsPersonsUpdatePropertyCreateRequest) Value(value interface{}) ApiEnvironmentsPersonsUpdatePropertyCreateRequest {
	r.value = &value
	return r
}

func (r ApiEnvironmentsPersonsUpdatePropertyCreateRequest) Format(format string) ApiEnvironmentsPersonsUpdatePropertyCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsUpdatePropertyCreateRequest) Person(person Person) ApiEnvironmentsPersonsUpdatePropertyCreateRequest {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsUpdatePropertyCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsUpdatePropertyCreateExecute(r)
}

/*
EnvironmentsPersonsUpdatePropertyCreate Method for EnvironmentsPersonsUpdatePropertyCreate

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsUpdatePropertyCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsUpdatePropertyCreate(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsUpdatePropertyCreateRequest {
	return ApiEnvironmentsPersonsUpdatePropertyCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsUpdatePropertyCreateExecute(r ApiEnvironmentsPersonsUpdatePropertyCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsUpdatePropertyCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/update_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.key == nil {
		return nil, reportError("key is required and must be specified")
	}
	if r.value == nil {
		return nil, reportError("value is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsUpdatePropertyCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	key *string
	projectId string
	value *interface{}
	format *string
	person *Person
}

// Specify the property key
func (r ApiEnvironmentsPersonsUpdatePropertyCreate_0Request) Key(key string) ApiEnvironmentsPersonsUpdatePropertyCreate_0Request {
	r.key = &key
	return r
}

// Specify the property value
func (r ApiEnvironmentsPersonsUpdatePropertyCreate_0Request) Value(value interface{}) ApiEnvironmentsPersonsUpdatePropertyCreate_0Request {
	r.value = &value
	return r
}

func (r ApiEnvironmentsPersonsUpdatePropertyCreate_0Request) Format(format string) ApiEnvironmentsPersonsUpdatePropertyCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsUpdatePropertyCreate_0Request) Person(person Person) ApiEnvironmentsPersonsUpdatePropertyCreate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsUpdatePropertyCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsUpdatePropertyCreate_226Execute(r)
}

/*
EnvironmentsPersonsUpdatePropertyCreate_0 Method for EnvironmentsPersonsUpdatePropertyCreate_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsUpdatePropertyCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsUpdatePropertyCreate_226(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsUpdatePropertyCreate_0Request {
	return ApiEnvironmentsPersonsUpdatePropertyCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsUpdatePropertyCreate_226Execute(r ApiEnvironmentsPersonsUpdatePropertyCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsUpdatePropertyCreate_226")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/update_property/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.key == nil {
		return nil, reportError("key is required and must be specified")
	}
	if r.value == nil {
		return nil, reportError("value is required and must be specified")
	}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "key", r.key, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "value", r.value, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	format *string
	person *Person
}

func (r ApiEnvironmentsPersonsUpdate_0Request) Format(format string) ApiEnvironmentsPersonsUpdate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsUpdate_0Request) Person(person Person) ApiEnvironmentsPersonsUpdate_0Request {
	r.person = &person
	return r
}

func (r ApiEnvironmentsPersonsUpdate_0Request) Execute() (*Person, *http.Response, error) {
	return r.ApiService.EnvironmentsPersonsUpdate_227Execute(r)
}

/*
EnvironmentsPersonsUpdate_0 Method for EnvironmentsPersonsUpdate_0

Only for setting properties on the person. "properties" from the request data will be updated via a "$set" event.
This means that only the properties listed will be updated, but other properties won't be removed nor updated.
If you would like to remove a property use the `delete_property` endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this person.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsUpdate_227(ctx context.Context, id int32, projectId string) ApiEnvironmentsPersonsUpdate_0Request {
	return ApiEnvironmentsPersonsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Person
func (a *EnvironmentsAPIService) EnvironmentsPersonsUpdate_227Execute(r ApiEnvironmentsPersonsUpdate_0Request) (*Person, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Person
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsUpdate_227")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.person
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsValuesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsValuesRetrieveRequest) Format(format string) ApiEnvironmentsPersonsValuesRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsValuesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsValuesRetrieveExecute(r)
}

/*
EnvironmentsPersonsValuesRetrieve Method for EnvironmentsPersonsValuesRetrieve

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsValuesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsValuesRetrieve(ctx context.Context, projectId string) ApiEnvironmentsPersonsValuesRetrieveRequest {
	return ApiEnvironmentsPersonsValuesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsValuesRetrieveExecute(r ApiEnvironmentsPersonsValuesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsValuesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPersonsValuesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	format *string
}

func (r ApiEnvironmentsPersonsValuesRetrieve_0Request) Format(format string) ApiEnvironmentsPersonsValuesRetrieve_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsPersonsValuesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsPersonsValuesRetrieve_228Execute(r)
}

/*
EnvironmentsPersonsValuesRetrieve_0 Method for EnvironmentsPersonsValuesRetrieve_0

This endpoint is meant for reading and deleting persons. To create or update persons, we recommend using the [capture API](https://posthog.com/docs/api/capture), the `$set` and `$unset` [properties](https://posthog.com/docs/product-analytics/user-properties), or one of our SDKs.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPersonsValuesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPersonsValuesRetrieve_228(ctx context.Context, projectId string) ApiEnvironmentsPersonsValuesRetrieve_0Request {
	return ApiEnvironmentsPersonsValuesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsPersonsValuesRetrieve_228Execute(r ApiEnvironmentsPersonsValuesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPersonsValuesRetrieve_228")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/persons/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsPluginConfigsLogsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	pluginConfigId string
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsPluginConfigsLogsListRequest) Limit(limit int32) ApiEnvironmentsPluginConfigsLogsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsPluginConfigsLogsListRequest) Offset(offset int32) ApiEnvironmentsPluginConfigsLogsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsPluginConfigsLogsListRequest) Execute() (*PaginatedPluginLogEntryList, *http.Response, error) {
	return r.ApiService.EnvironmentsPluginConfigsLogsListExecute(r)
}

/*
EnvironmentsPluginConfigsLogsList Method for EnvironmentsPluginConfigsLogsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pluginConfigId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPluginConfigsLogsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsPluginConfigsLogsList(ctx context.Context, pluginConfigId string, projectId string) ApiEnvironmentsPluginConfigsLogsListRequest {
	return ApiEnvironmentsPluginConfigsLogsListRequest{
		ApiService: a,
		ctx: ctx,
		pluginConfigId: pluginConfigId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedPluginLogEntryList
func (a *EnvironmentsAPIService) EnvironmentsPluginConfigsLogsListExecute(r ApiEnvironmentsPluginConfigsLogsListRequest) (*PaginatedPluginLogEntryList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPluginLogEntryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPluginConfigsLogsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/plugin_configs/{plugin_config_id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_config_id"+"}", url.PathEscape(parameterValueToString(r.pluginConfigId, "pluginConfigId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsPluginConfigsLogsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	pluginConfigId string
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsPluginConfigsLogsList_0Request) Limit(limit int32) ApiEnvironmentsPluginConfigsLogsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsPluginConfigsLogsList_0Request) Offset(offset int32) ApiEnvironmentsPluginConfigsLogsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsPluginConfigsLogsList_0Request) Execute() (*PaginatedPluginLogEntryList, *http.Response, error) {
	return r.ApiService.EnvironmentsPluginConfigsLogsList_229Execute(r)
}

/*
EnvironmentsPluginConfigsLogsList_0 Method for EnvironmentsPluginConfigsLogsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pluginConfigId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsPluginConfigsLogsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsPluginConfigsLogsList_229(ctx context.Context, pluginConfigId string, projectId string) ApiEnvironmentsPluginConfigsLogsList_0Request {
	return ApiEnvironmentsPluginConfigsLogsList_0Request{
		ApiService: a,
		ctx: ctx,
		pluginConfigId: pluginConfigId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedPluginLogEntryList
func (a *EnvironmentsAPIService) EnvironmentsPluginConfigsLogsList_229Execute(r ApiEnvironmentsPluginConfigsLogsList_0Request) (*PaginatedPluginLogEntryList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedPluginLogEntryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsPluginConfigsLogsList_229")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/plugin_configs/{plugin_config_id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"plugin_config_id"+"}", url.PathEscape(parameterValueToString(r.pluginConfigId, "pluginConfigId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryCheckAuthForAsyncCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsQueryCheckAuthForAsyncCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsQueryCheckAuthForAsyncCreateExecute(r)
}

/*
EnvironmentsQueryCheckAuthForAsyncCreate Method for EnvironmentsQueryCheckAuthForAsyncCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryCheckAuthForAsyncCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryCheckAuthForAsyncCreate(ctx context.Context, projectId string) ApiEnvironmentsQueryCheckAuthForAsyncCreateRequest {
	return ApiEnvironmentsQueryCheckAuthForAsyncCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsQueryCheckAuthForAsyncCreateExecute(r ApiEnvironmentsQueryCheckAuthForAsyncCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryCheckAuthForAsyncCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/check_auth_for_async/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryCheckAuthForAsyncCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsQueryCheckAuthForAsyncCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsQueryCheckAuthForAsyncCreate_230Execute(r)
}

/*
EnvironmentsQueryCheckAuthForAsyncCreate_0 Method for EnvironmentsQueryCheckAuthForAsyncCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryCheckAuthForAsyncCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryCheckAuthForAsyncCreate_230(ctx context.Context, projectId string) ApiEnvironmentsQueryCheckAuthForAsyncCreate_0Request {
	return ApiEnvironmentsQueryCheckAuthForAsyncCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsQueryCheckAuthForAsyncCreate_230Execute(r ApiEnvironmentsQueryCheckAuthForAsyncCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryCheckAuthForAsyncCreate_230")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/check_auth_for_async/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	queryRequest *QueryRequest
}

func (r ApiEnvironmentsQueryCreateRequest) QueryRequest(queryRequest QueryRequest) ApiEnvironmentsQueryCreateRequest {
	r.queryRequest = &queryRequest
	return r
}

func (r ApiEnvironmentsQueryCreateRequest) Execute() (*QueryResponseAlternative, *http.Response, error) {
	return r.ApiService.EnvironmentsQueryCreateExecute(r)
}

/*
EnvironmentsQueryCreate Method for EnvironmentsQueryCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryCreate(ctx context.Context, projectId string) ApiEnvironmentsQueryCreateRequest {
	return ApiEnvironmentsQueryCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryResponseAlternative
func (a *EnvironmentsAPIService) EnvironmentsQueryCreateExecute(r ApiEnvironmentsQueryCreateRequest) (*QueryResponseAlternative, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResponseAlternative
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryRequest == nil {
		return localVarReturnValue, nil, reportError("queryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	queryRequest *QueryRequest
}

func (r ApiEnvironmentsQueryCreate_0Request) QueryRequest(queryRequest QueryRequest) ApiEnvironmentsQueryCreate_0Request {
	r.queryRequest = &queryRequest
	return r
}

func (r ApiEnvironmentsQueryCreate_0Request) Execute() (*QueryResponseAlternative, *http.Response, error) {
	return r.ApiService.EnvironmentsQueryCreate_231Execute(r)
}

/*
EnvironmentsQueryCreate_0 Method for EnvironmentsQueryCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryCreate_231(ctx context.Context, projectId string) ApiEnvironmentsQueryCreate_0Request {
	return ApiEnvironmentsQueryCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryResponseAlternative
func (a *EnvironmentsAPIService) EnvironmentsQueryCreate_231Execute(r ApiEnvironmentsQueryCreate_0Request) (*QueryResponseAlternative, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryResponseAlternative
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryCreate_231")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryRequest == nil {
		return localVarReturnValue, nil, reportError("queryRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsQueryDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsQueryDestroyExecute(r)
}

/*
EnvironmentsQueryDestroy Method for EnvironmentsQueryDestroy

(Experimental)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsQueryDestroyRequest {
	return ApiEnvironmentsQueryDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsQueryDestroyExecute(r ApiEnvironmentsQueryDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsQueryDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsQueryDestroy_232Execute(r)
}

/*
EnvironmentsQueryDestroy_0 Method for EnvironmentsQueryDestroy_0

(Experimental)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryDestroy_232(ctx context.Context, id string, projectId string) ApiEnvironmentsQueryDestroy_0Request {
	return ApiEnvironmentsQueryDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsQueryDestroy_232Execute(r ApiEnvironmentsQueryDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryDestroy_232")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryDraftSqlRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsQueryDraftSqlRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsQueryDraftSqlRetrieveExecute(r)
}

/*
EnvironmentsQueryDraftSqlRetrieve Method for EnvironmentsQueryDraftSqlRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryDraftSqlRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryDraftSqlRetrieve(ctx context.Context, projectId string) ApiEnvironmentsQueryDraftSqlRetrieveRequest {
	return ApiEnvironmentsQueryDraftSqlRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsQueryDraftSqlRetrieveExecute(r ApiEnvironmentsQueryDraftSqlRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryDraftSqlRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/draft_sql/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryDraftSqlRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsQueryDraftSqlRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsQueryDraftSqlRetrieve_233Execute(r)
}

/*
EnvironmentsQueryDraftSqlRetrieve_0 Method for EnvironmentsQueryDraftSqlRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryDraftSqlRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryDraftSqlRetrieve_233(ctx context.Context, projectId string) ApiEnvironmentsQueryDraftSqlRetrieve_0Request {
	return ApiEnvironmentsQueryDraftSqlRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsQueryDraftSqlRetrieve_233Execute(r ApiEnvironmentsQueryDraftSqlRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryDraftSqlRetrieve_233")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/draft_sql/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryLogRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsQueryLogRetrieveRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EnvironmentsQueryLogRetrieveExecute(r)
}

/*
EnvironmentsQueryLogRetrieve Method for EnvironmentsQueryLogRetrieve

Get query log details from query_log_archive table for a specific query_id, the query must have been issued in last 24 hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryLogRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryLogRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsQueryLogRetrieveRequest {
	return ApiEnvironmentsQueryLogRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EnvironmentsAPIService) EnvironmentsQueryLogRetrieveExecute(r ApiEnvironmentsQueryLogRetrieveRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryLogRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/{id}/log/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryLogRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsQueryLogRetrieve_0Request) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.EnvironmentsQueryLogRetrieve_234Execute(r)
}

/*
EnvironmentsQueryLogRetrieve_0 Method for EnvironmentsQueryLogRetrieve_0

Get query log details from query_log_archive table for a specific query_id, the query must have been issued in last 24 hours.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryLogRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryLogRetrieve_234(ctx context.Context, id string, projectId string) ApiEnvironmentsQueryLogRetrieve_0Request {
	return ApiEnvironmentsQueryLogRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *EnvironmentsAPIService) EnvironmentsQueryLogRetrieve_234Execute(r ApiEnvironmentsQueryLogRetrieve_0Request) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryLogRetrieve_234")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/{id}/log/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsQueryRetrieveRequest) Execute() (*QueryStatusResponse, *http.Response, error) {
	return r.ApiService.EnvironmentsQueryRetrieveExecute(r)
}

/*
EnvironmentsQueryRetrieve Method for EnvironmentsQueryRetrieve

(Experimental)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsQueryRetrieveRequest {
	return ApiEnvironmentsQueryRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryStatusResponse
func (a *EnvironmentsAPIService) EnvironmentsQueryRetrieveExecute(r ApiEnvironmentsQueryRetrieveRequest) (*QueryStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsQueryRetrieve_0Request) Execute() (*QueryStatusResponse, *http.Response, error) {
	return r.ApiService.EnvironmentsQueryRetrieve_235Execute(r)
}

/*
EnvironmentsQueryRetrieve_0 Method for EnvironmentsQueryRetrieve_0

(Experimental)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryRetrieve_235(ctx context.Context, id string, projectId string) ApiEnvironmentsQueryRetrieve_0Request {
	return ApiEnvironmentsQueryRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryStatusResponse
func (a *EnvironmentsAPIService) EnvironmentsQueryRetrieve_235Execute(r ApiEnvironmentsQueryRetrieve_0Request) (*QueryStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryRetrieve_235")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryUpgradeCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	queryUpgradeRequest *QueryUpgradeRequest
}

func (r ApiEnvironmentsQueryUpgradeCreateRequest) QueryUpgradeRequest(queryUpgradeRequest QueryUpgradeRequest) ApiEnvironmentsQueryUpgradeCreateRequest {
	r.queryUpgradeRequest = &queryUpgradeRequest
	return r
}

func (r ApiEnvironmentsQueryUpgradeCreateRequest) Execute() (*QueryUpgradeResponse, *http.Response, error) {
	return r.ApiService.EnvironmentsQueryUpgradeCreateExecute(r)
}

/*
EnvironmentsQueryUpgradeCreate Method for EnvironmentsQueryUpgradeCreate

Upgrades a query without executing it. Returns a query with all nodes migrated to the latest version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryUpgradeCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryUpgradeCreate(ctx context.Context, projectId string) ApiEnvironmentsQueryUpgradeCreateRequest {
	return ApiEnvironmentsQueryUpgradeCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryUpgradeResponse
func (a *EnvironmentsAPIService) EnvironmentsQueryUpgradeCreateExecute(r ApiEnvironmentsQueryUpgradeCreateRequest) (*QueryUpgradeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryUpgradeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryUpgradeCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/upgrade/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryUpgradeRequest == nil {
		return localVarReturnValue, nil, reportError("queryUpgradeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryUpgradeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsQueryUpgradeCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	queryUpgradeRequest *QueryUpgradeRequest
}

func (r ApiEnvironmentsQueryUpgradeCreate_0Request) QueryUpgradeRequest(queryUpgradeRequest QueryUpgradeRequest) ApiEnvironmentsQueryUpgradeCreate_0Request {
	r.queryUpgradeRequest = &queryUpgradeRequest
	return r
}

func (r ApiEnvironmentsQueryUpgradeCreate_0Request) Execute() (*QueryUpgradeResponse, *http.Response, error) {
	return r.ApiService.EnvironmentsQueryUpgradeCreate_236Execute(r)
}

/*
EnvironmentsQueryUpgradeCreate_0 Method for EnvironmentsQueryUpgradeCreate_0

Upgrades a query without executing it. Returns a query with all nodes migrated to the latest version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsQueryUpgradeCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsQueryUpgradeCreate_236(ctx context.Context, projectId string) ApiEnvironmentsQueryUpgradeCreate_0Request {
	return ApiEnvironmentsQueryUpgradeCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryUpgradeResponse
func (a *EnvironmentsAPIService) EnvironmentsQueryUpgradeCreate_236Execute(r ApiEnvironmentsQueryUpgradeCreate_0Request) (*QueryUpgradeResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryUpgradeResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsQueryUpgradeCreate_236")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/query/upgrade/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.queryUpgradeRequest == nil {
		return localVarReturnValue, nil, reportError("queryUpgradeRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.queryUpgradeRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsResetTokenPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedTeam *PatchedTeam
}

func (r ApiEnvironmentsResetTokenPartialUpdateRequest) PatchedTeam(patchedTeam PatchedTeam) ApiEnvironmentsResetTokenPartialUpdateRequest {
	r.patchedTeam = &patchedTeam
	return r
}

func (r ApiEnvironmentsResetTokenPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsResetTokenPartialUpdateExecute(r)
}

/*
EnvironmentsResetTokenPartialUpdate Method for EnvironmentsResetTokenPartialUpdate

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsResetTokenPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsResetTokenPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsResetTokenPartialUpdateRequest {
	return ApiEnvironmentsResetTokenPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsResetTokenPartialUpdateExecute(r ApiEnvironmentsResetTokenPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsResetTokenPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/reset_token/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTeam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsRetrieveRequest) Execute() (*Team, *http.Response, error) {
	return r.ApiService.EnvironmentsRetrieveExecute(r)
}

/*
EnvironmentsRetrieve Method for EnvironmentsRetrieve

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsRetrieveRequest {
	return ApiEnvironmentsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Team
func (a *EnvironmentsAPIService) EnvironmentsRetrieveExecute(r ApiEnvironmentsRetrieveRequest) (*Team, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Team
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsRotateSecretTokenPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedTeam *PatchedTeam
}

func (r ApiEnvironmentsRotateSecretTokenPartialUpdateRequest) PatchedTeam(patchedTeam PatchedTeam) ApiEnvironmentsRotateSecretTokenPartialUpdateRequest {
	r.patchedTeam = &patchedTeam
	return r
}

func (r ApiEnvironmentsRotateSecretTokenPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsRotateSecretTokenPartialUpdateExecute(r)
}

/*
EnvironmentsRotateSecretTokenPartialUpdate Method for EnvironmentsRotateSecretTokenPartialUpdate

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsRotateSecretTokenPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsRotateSecretTokenPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsRotateSecretTokenPartialUpdateRequest {
	return ApiEnvironmentsRotateSecretTokenPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsRotateSecretTokenPartialUpdateExecute(r ApiEnvironmentsRotateSecretTokenPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsRotateSecretTokenPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/rotate_secret_token/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTeam
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionRecordingPlaylist *SessionRecordingPlaylist
}

func (r ApiEnvironmentsSessionRecordingPlaylistsCreateRequest) SessionRecordingPlaylist(sessionRecordingPlaylist SessionRecordingPlaylist) ApiEnvironmentsSessionRecordingPlaylistsCreateRequest {
	r.sessionRecordingPlaylist = &sessionRecordingPlaylist
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsCreateRequest) Execute() (*SessionRecordingPlaylist, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsCreateExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsCreate Method for EnvironmentsSessionRecordingPlaylistsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingPlaylistsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsCreate(ctx context.Context, projectId string) ApiEnvironmentsSessionRecordingPlaylistsCreateRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionRecordingPlaylist
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsCreateExecute(r ApiEnvironmentsSessionRecordingPlaylistsCreateRequest) (*SessionRecordingPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecordingPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionRecordingPlaylist
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionRecordingPlaylist *SessionRecordingPlaylist
}

func (r ApiEnvironmentsSessionRecordingPlaylistsCreate_0Request) SessionRecordingPlaylist(sessionRecordingPlaylist SessionRecordingPlaylist) ApiEnvironmentsSessionRecordingPlaylistsCreate_0Request {
	r.sessionRecordingPlaylist = &sessionRecordingPlaylist
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsCreate_0Request) Execute() (*SessionRecordingPlaylist, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsCreate_237Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsCreate_0 Method for EnvironmentsSessionRecordingPlaylistsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingPlaylistsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsCreate_237(ctx context.Context, projectId string) ApiEnvironmentsSessionRecordingPlaylistsCreate_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionRecordingPlaylist
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsCreate_237Execute(r ApiEnvironmentsSessionRecordingPlaylistsCreate_0Request) (*SessionRecordingPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecordingPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsCreate_237")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionRecordingPlaylist
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsDestroyExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsDestroy Method for EnvironmentsSessionRecordingPlaylistsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsDestroy(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsDestroyRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsDestroyExecute(r ApiEnvironmentsSessionRecordingPlaylistsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsDestroy_238Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsDestroy_0 Method for EnvironmentsSessionRecordingPlaylistsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsDestroy_238(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsDestroy_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsDestroy_238Execute(r ApiEnvironmentsSessionRecordingPlaylistsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsDestroy_238")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	createdBy *int32
	limit *int32
	offset *int32
	shortId *string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsListRequest) CreatedBy(createdBy int32) ApiEnvironmentsSessionRecordingPlaylistsListRequest {
	r.createdBy = &createdBy
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsSessionRecordingPlaylistsListRequest) Limit(limit int32) ApiEnvironmentsSessionRecordingPlaylistsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsSessionRecordingPlaylistsListRequest) Offset(offset int32) ApiEnvironmentsSessionRecordingPlaylistsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsListRequest) ShortId(shortId string) ApiEnvironmentsSessionRecordingPlaylistsListRequest {
	r.shortId = &shortId
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsListRequest) Execute() (*PaginatedSessionRecordingPlaylistList, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsListExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsList Method for EnvironmentsSessionRecordingPlaylistsList

Override list to include synthetic playlists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingPlaylistsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsList(ctx context.Context, projectId string) ApiEnvironmentsSessionRecordingPlaylistsListRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedSessionRecordingPlaylistList
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsListExecute(r ApiEnvironmentsSessionRecordingPlaylistsListRequest) (*PaginatedSessionRecordingPlaylistList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSessionRecordingPlaylistList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.shortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "short_id", r.shortId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	createdBy *int32
	limit *int32
	offset *int32
	shortId *string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsList_0Request) CreatedBy(createdBy int32) ApiEnvironmentsSessionRecordingPlaylistsList_0Request {
	r.createdBy = &createdBy
	return r
}

// Number of results to return per page.
func (r ApiEnvironmentsSessionRecordingPlaylistsList_0Request) Limit(limit int32) ApiEnvironmentsSessionRecordingPlaylistsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsSessionRecordingPlaylistsList_0Request) Offset(offset int32) ApiEnvironmentsSessionRecordingPlaylistsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsList_0Request) ShortId(shortId string) ApiEnvironmentsSessionRecordingPlaylistsList_0Request {
	r.shortId = &shortId
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsList_0Request) Execute() (*PaginatedSessionRecordingPlaylistList, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsList_239Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsList_0 Method for EnvironmentsSessionRecordingPlaylistsList_0

Override list to include synthetic playlists

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingPlaylistsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsList_239(ctx context.Context, projectId string) ApiEnvironmentsSessionRecordingPlaylistsList_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedSessionRecordingPlaylistList
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsList_239Execute(r ApiEnvironmentsSessionRecordingPlaylistsList_0Request) (*PaginatedSessionRecordingPlaylistList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSessionRecordingPlaylistList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsList_239")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.shortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "short_id", r.shortId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
	patchedSessionRecordingPlaylist *PatchedSessionRecordingPlaylist
}

func (r ApiEnvironmentsSessionRecordingPlaylistsPartialUpdateRequest) PatchedSessionRecordingPlaylist(patchedSessionRecordingPlaylist PatchedSessionRecordingPlaylist) ApiEnvironmentsSessionRecordingPlaylistsPartialUpdateRequest {
	r.patchedSessionRecordingPlaylist = &patchedSessionRecordingPlaylist
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsPartialUpdateRequest) Execute() (*SessionRecordingPlaylist, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsPartialUpdateExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsPartialUpdate Method for EnvironmentsSessionRecordingPlaylistsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsPartialUpdate(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsPartialUpdateRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
//  @return SessionRecordingPlaylist
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsPartialUpdateExecute(r ApiEnvironmentsSessionRecordingPlaylistsPartialUpdateRequest) (*SessionRecordingPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecordingPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSessionRecordingPlaylist
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
	patchedSessionRecordingPlaylist *PatchedSessionRecordingPlaylist
}

func (r ApiEnvironmentsSessionRecordingPlaylistsPartialUpdate_0Request) PatchedSessionRecordingPlaylist(patchedSessionRecordingPlaylist PatchedSessionRecordingPlaylist) ApiEnvironmentsSessionRecordingPlaylistsPartialUpdate_0Request {
	r.patchedSessionRecordingPlaylist = &patchedSessionRecordingPlaylist
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsPartialUpdate_0Request) Execute() (*SessionRecordingPlaylist, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsPartialUpdate_240Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsPartialUpdate_0 Method for EnvironmentsSessionRecordingPlaylistsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsPartialUpdate_240(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsPartialUpdate_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
//  @return SessionRecordingPlaylist
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsPartialUpdate_240Execute(r ApiEnvironmentsSessionRecordingPlaylistsPartialUpdate_0Request) (*SessionRecordingPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecordingPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsPartialUpdate_240")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSessionRecordingPlaylist
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionRecordingId string
	shortId string
	sessionRecordingPlaylist *SessionRecordingPlaylist
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreateRequest) SessionRecordingPlaylist(sessionRecordingPlaylist SessionRecordingPlaylist) ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreateRequest {
	r.sessionRecordingPlaylist = &sessionRecordingPlaylist
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsRecordingsCreateExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsRecordingsCreate Method for EnvironmentsSessionRecordingPlaylistsRecordingsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param sessionRecordingId
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsCreate(ctx context.Context, projectId string, sessionRecordingId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreateRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		sessionRecordingId: sessionRecordingId,
		shortId: shortId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsCreateExecute(r ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsRecordingsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/recordings/{session_recording_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_recording_id"+"}", url.PathEscape(parameterValueToString(r.sessionRecordingId, "sessionRecordingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionRecordingPlaylist
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionRecordingId string
	shortId string
	sessionRecordingPlaylist *SessionRecordingPlaylist
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreate_0Request) SessionRecordingPlaylist(sessionRecordingPlaylist SessionRecordingPlaylist) ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreate_0Request {
	r.sessionRecordingPlaylist = &sessionRecordingPlaylist
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsRecordingsCreate_241Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsRecordingsCreate_0 Method for EnvironmentsSessionRecordingPlaylistsRecordingsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param sessionRecordingId
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsCreate_241(ctx context.Context, projectId string, sessionRecordingId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreate_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		sessionRecordingId: sessionRecordingId,
		shortId: shortId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsCreate_241Execute(r ApiEnvironmentsSessionRecordingPlaylistsRecordingsCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsRecordingsCreate_241")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/recordings/{session_recording_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_recording_id"+"}", url.PathEscape(parameterValueToString(r.sessionRecordingId, "sessionRecordingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionRecordingPlaylist
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionRecordingId string
	shortId string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsRecordingsDestroyExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsRecordingsDestroy Method for EnvironmentsSessionRecordingPlaylistsRecordingsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param sessionRecordingId
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsDestroy(ctx context.Context, projectId string, sessionRecordingId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroyRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		sessionRecordingId: sessionRecordingId,
		shortId: shortId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsDestroyExecute(r ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsRecordingsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/recordings/{session_recording_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_recording_id"+"}", url.PathEscape(parameterValueToString(r.sessionRecordingId, "sessionRecordingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	sessionRecordingId string
	shortId string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsRecordingsDestroy_242Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsRecordingsDestroy_0 Method for EnvironmentsSessionRecordingPlaylistsRecordingsDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param sessionRecordingId
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsDestroy_242(ctx context.Context, projectId string, sessionRecordingId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroy_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		sessionRecordingId: sessionRecordingId,
		shortId: shortId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsDestroy_242Execute(r ApiEnvironmentsSessionRecordingPlaylistsRecordingsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsRecordingsDestroy_242")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/recordings/{session_recording_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"session_recording_id"+"}", url.PathEscape(parameterValueToString(r.sessionRecordingId, "sessionRecordingId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsRecordingsRetrieveExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve Method for EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieveRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsRetrieveExecute(r ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_243Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_0 Method for EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_243(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_243Execute(r ApiEnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsRecordingsRetrieve_243")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRetrieveRequest) Execute() (*SessionRecordingPlaylist, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsRetrieveExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsRetrieve Method for EnvironmentsSessionRecordingPlaylistsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRetrieve(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsRetrieveRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
//  @return SessionRecordingPlaylist
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRetrieveExecute(r ApiEnvironmentsSessionRecordingPlaylistsRetrieveRequest) (*SessionRecordingPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecordingPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
}

func (r ApiEnvironmentsSessionRecordingPlaylistsRetrieve_0Request) Execute() (*SessionRecordingPlaylist, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsRetrieve_244Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsRetrieve_0 Method for EnvironmentsSessionRecordingPlaylistsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRetrieve_244(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsRetrieve_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
//  @return SessionRecordingPlaylist
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsRetrieve_244Execute(r ApiEnvironmentsSessionRecordingPlaylistsRetrieve_0Request) (*SessionRecordingPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecordingPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsRetrieve_244")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
	sessionRecordingPlaylist *SessionRecordingPlaylist
}

func (r ApiEnvironmentsSessionRecordingPlaylistsUpdateRequest) SessionRecordingPlaylist(sessionRecordingPlaylist SessionRecordingPlaylist) ApiEnvironmentsSessionRecordingPlaylistsUpdateRequest {
	r.sessionRecordingPlaylist = &sessionRecordingPlaylist
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsUpdateRequest) Execute() (*SessionRecordingPlaylist, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsUpdateExecute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsUpdate Method for EnvironmentsSessionRecordingPlaylistsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsUpdate(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsUpdateRequest {
	return ApiEnvironmentsSessionRecordingPlaylistsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
//  @return SessionRecordingPlaylist
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsUpdateExecute(r ApiEnvironmentsSessionRecordingPlaylistsUpdateRequest) (*SessionRecordingPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecordingPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionRecordingPlaylist
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingPlaylistsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	shortId string
	sessionRecordingPlaylist *SessionRecordingPlaylist
}

func (r ApiEnvironmentsSessionRecordingPlaylistsUpdate_0Request) SessionRecordingPlaylist(sessionRecordingPlaylist SessionRecordingPlaylist) ApiEnvironmentsSessionRecordingPlaylistsUpdate_0Request {
	r.sessionRecordingPlaylist = &sessionRecordingPlaylist
	return r
}

func (r ApiEnvironmentsSessionRecordingPlaylistsUpdate_0Request) Execute() (*SessionRecordingPlaylist, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingPlaylistsUpdate_245Execute(r)
}

/*
EnvironmentsSessionRecordingPlaylistsUpdate_0 Method for EnvironmentsSessionRecordingPlaylistsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param shortId
 @return ApiEnvironmentsSessionRecordingPlaylistsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsUpdate_245(ctx context.Context, projectId string, shortId string) ApiEnvironmentsSessionRecordingPlaylistsUpdate_0Request {
	return ApiEnvironmentsSessionRecordingPlaylistsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		shortId: shortId,
	}
}

// Execute executes the request
//  @return SessionRecordingPlaylist
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingPlaylistsUpdate_245Execute(r ApiEnvironmentsSessionRecordingPlaylistsUpdate_0Request) (*SessionRecordingPlaylist, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecordingPlaylist
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingPlaylistsUpdate_245")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recording_playlists/{short_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"short_id"+"}", url.PathEscape(parameterValueToString(r.shortId, "shortId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionRecordingPlaylist
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsSessionRecordingsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsDestroyExecute(r)
}

/*
EnvironmentsSessionRecordingsDestroy Method for EnvironmentsSessionRecordingsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this session recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsSessionRecordingsDestroyRequest {
	return ApiEnvironmentsSessionRecordingsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsDestroyExecute(r ApiEnvironmentsSessionRecordingsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsSessionRecordingsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsDestroy_246Execute(r)
}

/*
EnvironmentsSessionRecordingsDestroy_0 Method for EnvironmentsSessionRecordingsDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this session recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsDestroy_246(ctx context.Context, id string, projectId string) ApiEnvironmentsSessionRecordingsDestroy_0Request {
	return ApiEnvironmentsSessionRecordingsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsDestroy_246Execute(r ApiEnvironmentsSessionRecordingsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsDestroy_246")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsSessionRecordingsListRequest) Limit(limit int32) ApiEnvironmentsSessionRecordingsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsSessionRecordingsListRequest) Offset(offset int32) ApiEnvironmentsSessionRecordingsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsSessionRecordingsListRequest) Execute() (*PaginatedSessionRecordingList, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsListExecute(r)
}

/*
EnvironmentsSessionRecordingsList Method for EnvironmentsSessionRecordingsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsList(ctx context.Context, projectId string) ApiEnvironmentsSessionRecordingsListRequest {
	return ApiEnvironmentsSessionRecordingsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedSessionRecordingList
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsListExecute(r ApiEnvironmentsSessionRecordingsListRequest) (*PaginatedSessionRecordingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSessionRecordingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsSessionRecordingsList_0Request) Limit(limit int32) ApiEnvironmentsSessionRecordingsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsSessionRecordingsList_0Request) Offset(offset int32) ApiEnvironmentsSessionRecordingsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsSessionRecordingsList_0Request) Execute() (*PaginatedSessionRecordingList, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsList_247Execute(r)
}

/*
EnvironmentsSessionRecordingsList_0 Method for EnvironmentsSessionRecordingsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsList_247(ctx context.Context, projectId string) ApiEnvironmentsSessionRecordingsList_0Request {
	return ApiEnvironmentsSessionRecordingsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedSessionRecordingList
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsList_247Execute(r ApiEnvironmentsSessionRecordingsList_0Request) (*PaginatedSessionRecordingList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSessionRecordingList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsList_247")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedSessionRecording *PatchedSessionRecording
}

func (r ApiEnvironmentsSessionRecordingsPartialUpdateRequest) PatchedSessionRecording(patchedSessionRecording PatchedSessionRecording) ApiEnvironmentsSessionRecordingsPartialUpdateRequest {
	r.patchedSessionRecording = &patchedSessionRecording
	return r
}

func (r ApiEnvironmentsSessionRecordingsPartialUpdateRequest) Execute() (*SessionRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsPartialUpdateExecute(r)
}

/*
EnvironmentsSessionRecordingsPartialUpdate Method for EnvironmentsSessionRecordingsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this session recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsSessionRecordingsPartialUpdateRequest {
	return ApiEnvironmentsSessionRecordingsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionRecording
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsPartialUpdateExecute(r ApiEnvironmentsSessionRecordingsPartialUpdateRequest) (*SessionRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSessionRecording
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedSessionRecording *PatchedSessionRecording
}

func (r ApiEnvironmentsSessionRecordingsPartialUpdate_0Request) PatchedSessionRecording(patchedSessionRecording PatchedSessionRecording) ApiEnvironmentsSessionRecordingsPartialUpdate_0Request {
	r.patchedSessionRecording = &patchedSessionRecording
	return r
}

func (r ApiEnvironmentsSessionRecordingsPartialUpdate_0Request) Execute() (*SessionRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsPartialUpdate_248Execute(r)
}

/*
EnvironmentsSessionRecordingsPartialUpdate_0 Method for EnvironmentsSessionRecordingsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this session recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsPartialUpdate_248(ctx context.Context, id string, projectId string) ApiEnvironmentsSessionRecordingsPartialUpdate_0Request {
	return ApiEnvironmentsSessionRecordingsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionRecording
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsPartialUpdate_248Execute(r ApiEnvironmentsSessionRecordingsPartialUpdate_0Request) (*SessionRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsPartialUpdate_248")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSessionRecording
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsSessionRecordingsRetrieveRequest) Execute() (*SessionRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsRetrieveExecute(r)
}

/*
EnvironmentsSessionRecordingsRetrieve Method for EnvironmentsSessionRecordingsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this session recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsSessionRecordingsRetrieveRequest {
	return ApiEnvironmentsSessionRecordingsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionRecording
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsRetrieveExecute(r ApiEnvironmentsSessionRecordingsRetrieveRequest) (*SessionRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsSessionRecordingsRetrieve_0Request) Execute() (*SessionRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsRetrieve_249Execute(r)
}

/*
EnvironmentsSessionRecordingsRetrieve_0 Method for EnvironmentsSessionRecordingsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this session recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsRetrieve_249(ctx context.Context, id string, projectId string) ApiEnvironmentsSessionRecordingsRetrieve_0Request {
	return ApiEnvironmentsSessionRecordingsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionRecording
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsRetrieve_249Execute(r ApiEnvironmentsSessionRecordingsRetrieve_0Request) (*SessionRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsRetrieve_249")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsSharingListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	recordingId string
}

func (r ApiEnvironmentsSessionRecordingsSharingListRequest) Execute() ([]SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsSharingListExecute(r)
}

/*
EnvironmentsSessionRecordingsSharingList Method for EnvironmentsSessionRecordingsSharingList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param recordingId
 @return ApiEnvironmentsSessionRecordingsSharingListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingList(ctx context.Context, projectId string, recordingId string) ApiEnvironmentsSessionRecordingsSharingListRequest {
	return ApiEnvironmentsSessionRecordingsSharingListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return []SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingListExecute(r ApiEnvironmentsSessionRecordingsSharingListRequest) ([]SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsSharingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{recording_id}/sharing/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_id"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsSharingList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	recordingId string
}

func (r ApiEnvironmentsSessionRecordingsSharingList_0Request) Execute() ([]SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsSharingList_250Execute(r)
}

/*
EnvironmentsSessionRecordingsSharingList_0 Method for EnvironmentsSessionRecordingsSharingList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param recordingId
 @return ApiEnvironmentsSessionRecordingsSharingList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingList_250(ctx context.Context, projectId string, recordingId string) ApiEnvironmentsSessionRecordingsSharingList_0Request {
	return ApiEnvironmentsSessionRecordingsSharingList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return []SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingList_250Execute(r ApiEnvironmentsSessionRecordingsSharingList_0Request) ([]SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsSharingList_250")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{recording_id}/sharing/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_id"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsSharingPasswordsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	recordingId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsSessionRecordingsSharingPasswordsCreateRequest) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsSessionRecordingsSharingPasswordsCreateRequest {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsSessionRecordingsSharingPasswordsCreateRequest) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsSharingPasswordsCreateExecute(r)
}

/*
EnvironmentsSessionRecordingsSharingPasswordsCreate Method for EnvironmentsSessionRecordingsSharingPasswordsCreate

Create a new password for the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param recordingId
 @return ApiEnvironmentsSessionRecordingsSharingPasswordsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingPasswordsCreate(ctx context.Context, projectId string, recordingId string) ApiEnvironmentsSessionRecordingsSharingPasswordsCreateRequest {
	return ApiEnvironmentsSessionRecordingsSharingPasswordsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingPasswordsCreateExecute(r ApiEnvironmentsSessionRecordingsSharingPasswordsCreateRequest) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsSharingPasswordsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{recording_id}/sharing/passwords/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_id"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsSharingPasswordsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	recordingId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsSessionRecordingsSharingPasswordsCreate_0Request) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsSessionRecordingsSharingPasswordsCreate_0Request {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsSessionRecordingsSharingPasswordsCreate_0Request) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsSharingPasswordsCreate_251Execute(r)
}

/*
EnvironmentsSessionRecordingsSharingPasswordsCreate_0 Method for EnvironmentsSessionRecordingsSharingPasswordsCreate_0

Create a new password for the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param recordingId
 @return ApiEnvironmentsSessionRecordingsSharingPasswordsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingPasswordsCreate_251(ctx context.Context, projectId string, recordingId string) ApiEnvironmentsSessionRecordingsSharingPasswordsCreate_0Request {
	return ApiEnvironmentsSessionRecordingsSharingPasswordsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingPasswordsCreate_251Execute(r ApiEnvironmentsSessionRecordingsSharingPasswordsCreate_0Request) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsSharingPasswordsCreate_251")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{recording_id}/sharing/passwords/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_id"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsSharingPasswordsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	passwordId string
	projectId string
	recordingId string
}

func (r ApiEnvironmentsSessionRecordingsSharingPasswordsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsSharingPasswordsDestroyExecute(r)
}

/*
EnvironmentsSessionRecordingsSharingPasswordsDestroy Method for EnvironmentsSessionRecordingsSharingPasswordsDestroy

Delete a password from the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param passwordId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param recordingId
 @return ApiEnvironmentsSessionRecordingsSharingPasswordsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingPasswordsDestroy(ctx context.Context, passwordId string, projectId string, recordingId string) ApiEnvironmentsSessionRecordingsSharingPasswordsDestroyRequest {
	return ApiEnvironmentsSessionRecordingsSharingPasswordsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		passwordId: passwordId,
		projectId: projectId,
		recordingId: recordingId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingPasswordsDestroyExecute(r ApiEnvironmentsSessionRecordingsSharingPasswordsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsSharingPasswordsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{recording_id}/sharing/passwords/{password_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"password_id"+"}", url.PathEscape(parameterValueToString(r.passwordId, "passwordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_id"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsSharingPasswordsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	passwordId string
	projectId string
	recordingId string
}

func (r ApiEnvironmentsSessionRecordingsSharingPasswordsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsSharingPasswordsDestroy_252Execute(r)
}

/*
EnvironmentsSessionRecordingsSharingPasswordsDestroy_0 Method for EnvironmentsSessionRecordingsSharingPasswordsDestroy_0

Delete a password from the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param passwordId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param recordingId
 @return ApiEnvironmentsSessionRecordingsSharingPasswordsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingPasswordsDestroy_252(ctx context.Context, passwordId string, projectId string, recordingId string) ApiEnvironmentsSessionRecordingsSharingPasswordsDestroy_0Request {
	return ApiEnvironmentsSessionRecordingsSharingPasswordsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		passwordId: passwordId,
		projectId: projectId,
		recordingId: recordingId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingPasswordsDestroy_252Execute(r ApiEnvironmentsSessionRecordingsSharingPasswordsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsSharingPasswordsDestroy_252")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{recording_id}/sharing/passwords/{password_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"password_id"+"}", url.PathEscape(parameterValueToString(r.passwordId, "passwordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_id"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsSharingRefreshCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	recordingId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsSessionRecordingsSharingRefreshCreateRequest) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsSessionRecordingsSharingRefreshCreateRequest {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsSessionRecordingsSharingRefreshCreateRequest) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsSharingRefreshCreateExecute(r)
}

/*
EnvironmentsSessionRecordingsSharingRefreshCreate Method for EnvironmentsSessionRecordingsSharingRefreshCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param recordingId
 @return ApiEnvironmentsSessionRecordingsSharingRefreshCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingRefreshCreate(ctx context.Context, projectId string, recordingId string) ApiEnvironmentsSessionRecordingsSharingRefreshCreateRequest {
	return ApiEnvironmentsSessionRecordingsSharingRefreshCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingRefreshCreateExecute(r ApiEnvironmentsSessionRecordingsSharingRefreshCreateRequest) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsSharingRefreshCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{recording_id}/sharing/refresh/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_id"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsSharingRefreshCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	recordingId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiEnvironmentsSessionRecordingsSharingRefreshCreate_0Request) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiEnvironmentsSessionRecordingsSharingRefreshCreate_0Request {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiEnvironmentsSessionRecordingsSharingRefreshCreate_0Request) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsSharingRefreshCreate_253Execute(r)
}

/*
EnvironmentsSessionRecordingsSharingRefreshCreate_0 Method for EnvironmentsSessionRecordingsSharingRefreshCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param recordingId
 @return ApiEnvironmentsSessionRecordingsSharingRefreshCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingRefreshCreate_253(ctx context.Context, projectId string, recordingId string) ApiEnvironmentsSessionRecordingsSharingRefreshCreate_0Request {
	return ApiEnvironmentsSessionRecordingsSharingRefreshCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
		recordingId: recordingId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsSharingRefreshCreate_253Execute(r ApiEnvironmentsSessionRecordingsSharingRefreshCreate_0Request) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsSharingRefreshCreate_253")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{recording_id}/sharing/refresh/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recording_id"+"}", url.PathEscape(parameterValueToString(r.recordingId, "recordingId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	sessionRecording *SessionRecording
}

func (r ApiEnvironmentsSessionRecordingsUpdateRequest) SessionRecording(sessionRecording SessionRecording) ApiEnvironmentsSessionRecordingsUpdateRequest {
	r.sessionRecording = &sessionRecording
	return r
}

func (r ApiEnvironmentsSessionRecordingsUpdateRequest) Execute() (*SessionRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsUpdateExecute(r)
}

/*
EnvironmentsSessionRecordingsUpdate Method for EnvironmentsSessionRecordingsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this session recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsSessionRecordingsUpdateRequest {
	return ApiEnvironmentsSessionRecordingsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionRecording
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsUpdateExecute(r ApiEnvironmentsSessionRecordingsUpdateRequest) (*SessionRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionRecording
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionRecordingsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	sessionRecording *SessionRecording
}

func (r ApiEnvironmentsSessionRecordingsUpdate_0Request) SessionRecording(sessionRecording SessionRecording) ApiEnvironmentsSessionRecordingsUpdate_0Request {
	r.sessionRecording = &sessionRecording
	return r
}

func (r ApiEnvironmentsSessionRecordingsUpdate_0Request) Execute() (*SessionRecording, *http.Response, error) {
	return r.ApiService.EnvironmentsSessionRecordingsUpdate_254Execute(r)
}

/*
EnvironmentsSessionRecordingsUpdate_0 Method for EnvironmentsSessionRecordingsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this session recording.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionRecordingsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsUpdate_254(ctx context.Context, id string, projectId string) ApiEnvironmentsSessionRecordingsUpdate_0Request {
	return ApiEnvironmentsSessionRecordingsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SessionRecording
func (a *EnvironmentsAPIService) EnvironmentsSessionRecordingsUpdate_254Execute(r ApiEnvironmentsSessionRecordingsUpdate_0Request) (*SessionRecording, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SessionRecording
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionRecordingsUpdate_254")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/session_recordings/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sessionRecording
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionsPropertyDefinitionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsSessionsPropertyDefinitionsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionsPropertyDefinitionsRetrieveExecute(r)
}

/*
EnvironmentsSessionsPropertyDefinitionsRetrieve Method for EnvironmentsSessionsPropertyDefinitionsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionsPropertyDefinitionsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionsPropertyDefinitionsRetrieve(ctx context.Context, projectId string) ApiEnvironmentsSessionsPropertyDefinitionsRetrieveRequest {
	return ApiEnvironmentsSessionsPropertyDefinitionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionsPropertyDefinitionsRetrieveExecute(r ApiEnvironmentsSessionsPropertyDefinitionsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionsPropertyDefinitionsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/sessions/property_definitions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionsPropertyDefinitionsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsSessionsPropertyDefinitionsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionsPropertyDefinitionsRetrieve_255Execute(r)
}

/*
EnvironmentsSessionsPropertyDefinitionsRetrieve_0 Method for EnvironmentsSessionsPropertyDefinitionsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionsPropertyDefinitionsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionsPropertyDefinitionsRetrieve_255(ctx context.Context, projectId string) ApiEnvironmentsSessionsPropertyDefinitionsRetrieve_0Request {
	return ApiEnvironmentsSessionsPropertyDefinitionsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionsPropertyDefinitionsRetrieve_255Execute(r ApiEnvironmentsSessionsPropertyDefinitionsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionsPropertyDefinitionsRetrieve_255")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/sessions/property_definitions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionsValuesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsSessionsValuesRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionsValuesRetrieveExecute(r)
}

/*
EnvironmentsSessionsValuesRetrieve Method for EnvironmentsSessionsValuesRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionsValuesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionsValuesRetrieve(ctx context.Context, projectId string) ApiEnvironmentsSessionsValuesRetrieveRequest {
	return ApiEnvironmentsSessionsValuesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionsValuesRetrieveExecute(r ApiEnvironmentsSessionsValuesRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionsValuesRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/sessions/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSessionsValuesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
}

func (r ApiEnvironmentsSessionsValuesRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSessionsValuesRetrieve_256Execute(r)
}

/*
EnvironmentsSessionsValuesRetrieve_0 Method for EnvironmentsSessionsValuesRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSessionsValuesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSessionsValuesRetrieve_256(ctx context.Context, projectId string) ApiEnvironmentsSessionsValuesRetrieve_0Request {
	return ApiEnvironmentsSessionsValuesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSessionsValuesRetrieve_256Execute(r ApiEnvironmentsSessionsValuesRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSessionsValuesRetrieve_256")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/sessions/values/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	subscription *Subscription
}

func (r ApiEnvironmentsSubscriptionsCreateRequest) Subscription(subscription Subscription) ApiEnvironmentsSubscriptionsCreateRequest {
	r.subscription = &subscription
	return r
}

func (r ApiEnvironmentsSubscriptionsCreateRequest) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsCreateExecute(r)
}

/*
EnvironmentsSubscriptionsCreate Method for EnvironmentsSubscriptionsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsCreate(ctx context.Context, projectId string) ApiEnvironmentsSubscriptionsCreateRequest {
	return ApiEnvironmentsSubscriptionsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Subscription
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsCreateExecute(r ApiEnvironmentsSubscriptionsCreateRequest) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscription == nil {
		return localVarReturnValue, nil, reportError("subscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	subscription *Subscription
}

func (r ApiEnvironmentsSubscriptionsCreate_0Request) Subscription(subscription Subscription) ApiEnvironmentsSubscriptionsCreate_0Request {
	r.subscription = &subscription
	return r
}

func (r ApiEnvironmentsSubscriptionsCreate_0Request) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsCreate_257Execute(r)
}

/*
EnvironmentsSubscriptionsCreate_0 Method for EnvironmentsSubscriptionsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsCreate_257(ctx context.Context, projectId string) ApiEnvironmentsSubscriptionsCreate_0Request {
	return ApiEnvironmentsSubscriptionsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Subscription
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsCreate_257Execute(r ApiEnvironmentsSubscriptionsCreate_0Request) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsCreate_257")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscription == nil {
		return localVarReturnValue, nil, reportError("subscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsSubscriptionsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsDestroyExecute(r)
}

/*
EnvironmentsSubscriptionsDestroy Method for EnvironmentsSubscriptionsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this subscription.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsDestroy(ctx context.Context, id int32, projectId string) ApiEnvironmentsSubscriptionsDestroyRequest {
	return ApiEnvironmentsSubscriptionsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsDestroyExecute(r ApiEnvironmentsSubscriptionsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsSubscriptionsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsDestroy_258Execute(r)
}

/*
EnvironmentsSubscriptionsDestroy_0 Method for EnvironmentsSubscriptionsDestroy_0

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this subscription.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsDestroy_258(ctx context.Context, id int32, projectId string) ApiEnvironmentsSubscriptionsDestroy_0Request {
	return ApiEnvironmentsSubscriptionsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsDestroy_258Execute(r ApiEnvironmentsSubscriptionsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsDestroy_258")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsSubscriptionsListRequest) Limit(limit int32) ApiEnvironmentsSubscriptionsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsSubscriptionsListRequest) Offset(offset int32) ApiEnvironmentsSubscriptionsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsSubscriptionsListRequest) Execute() (*PaginatedSubscriptionList, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsListExecute(r)
}

/*
EnvironmentsSubscriptionsList Method for EnvironmentsSubscriptionsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsList(ctx context.Context, projectId string) ApiEnvironmentsSubscriptionsListRequest {
	return ApiEnvironmentsSubscriptionsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedSubscriptionList
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsListExecute(r ApiEnvironmentsSubscriptionsListRequest) (*PaginatedSubscriptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsSubscriptionsList_0Request) Limit(limit int32) ApiEnvironmentsSubscriptionsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsSubscriptionsList_0Request) Offset(offset int32) ApiEnvironmentsSubscriptionsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsSubscriptionsList_0Request) Execute() (*PaginatedSubscriptionList, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsList_259Execute(r)
}

/*
EnvironmentsSubscriptionsList_0 Method for EnvironmentsSubscriptionsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsList_259(ctx context.Context, projectId string) ApiEnvironmentsSubscriptionsList_0Request {
	return ApiEnvironmentsSubscriptionsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedSubscriptionList
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsList_259Execute(r ApiEnvironmentsSubscriptionsList_0Request) (*PaginatedSubscriptionList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedSubscriptionList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsList_259")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedSubscription *PatchedSubscription
}

func (r ApiEnvironmentsSubscriptionsPartialUpdateRequest) PatchedSubscription(patchedSubscription PatchedSubscription) ApiEnvironmentsSubscriptionsPartialUpdateRequest {
	r.patchedSubscription = &patchedSubscription
	return r
}

func (r ApiEnvironmentsSubscriptionsPartialUpdateRequest) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsPartialUpdateExecute(r)
}

/*
EnvironmentsSubscriptionsPartialUpdate Method for EnvironmentsSubscriptionsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this subscription.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsPartialUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsSubscriptionsPartialUpdateRequest {
	return ApiEnvironmentsSubscriptionsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Subscription
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsPartialUpdateExecute(r ApiEnvironmentsSubscriptionsPartialUpdateRequest) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	patchedSubscription *PatchedSubscription
}

func (r ApiEnvironmentsSubscriptionsPartialUpdate_0Request) PatchedSubscription(patchedSubscription PatchedSubscription) ApiEnvironmentsSubscriptionsPartialUpdate_0Request {
	r.patchedSubscription = &patchedSubscription
	return r
}

func (r ApiEnvironmentsSubscriptionsPartialUpdate_0Request) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsPartialUpdate_260Execute(r)
}

/*
EnvironmentsSubscriptionsPartialUpdate_0 Method for EnvironmentsSubscriptionsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this subscription.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsPartialUpdate_260(ctx context.Context, id int32, projectId string) ApiEnvironmentsSubscriptionsPartialUpdate_0Request {
	return ApiEnvironmentsSubscriptionsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Subscription
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsPartialUpdate_260Execute(r ApiEnvironmentsSubscriptionsPartialUpdate_0Request) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsPartialUpdate_260")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedSubscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsSubscriptionsRetrieveRequest) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsRetrieveExecute(r)
}

/*
EnvironmentsSubscriptionsRetrieve Method for EnvironmentsSubscriptionsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this subscription.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsRetrieve(ctx context.Context, id int32, projectId string) ApiEnvironmentsSubscriptionsRetrieveRequest {
	return ApiEnvironmentsSubscriptionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Subscription
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsRetrieveExecute(r ApiEnvironmentsSubscriptionsRetrieveRequest) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
}

func (r ApiEnvironmentsSubscriptionsRetrieve_0Request) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsRetrieve_261Execute(r)
}

/*
EnvironmentsSubscriptionsRetrieve_0 Method for EnvironmentsSubscriptionsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this subscription.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsRetrieve_261(ctx context.Context, id int32, projectId string) ApiEnvironmentsSubscriptionsRetrieve_0Request {
	return ApiEnvironmentsSubscriptionsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Subscription
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsRetrieve_261Execute(r ApiEnvironmentsSubscriptionsRetrieve_0Request) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsRetrieve_261")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	subscription *Subscription
}

func (r ApiEnvironmentsSubscriptionsUpdateRequest) Subscription(subscription Subscription) ApiEnvironmentsSubscriptionsUpdateRequest {
	r.subscription = &subscription
	return r
}

func (r ApiEnvironmentsSubscriptionsUpdateRequest) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsUpdateExecute(r)
}

/*
EnvironmentsSubscriptionsUpdate Method for EnvironmentsSubscriptionsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this subscription.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsSubscriptionsUpdateRequest {
	return ApiEnvironmentsSubscriptionsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Subscription
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsUpdateExecute(r ApiEnvironmentsSubscriptionsUpdateRequest) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscription == nil {
		return localVarReturnValue, nil, reportError("subscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsSubscriptionsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	subscription *Subscription
}

func (r ApiEnvironmentsSubscriptionsUpdate_0Request) Subscription(subscription Subscription) ApiEnvironmentsSubscriptionsUpdate_0Request {
	r.subscription = &subscription
	return r
}

func (r ApiEnvironmentsSubscriptionsUpdate_0Request) Execute() (*Subscription, *http.Response, error) {
	return r.ApiService.EnvironmentsSubscriptionsUpdate_262Execute(r)
}

/*
EnvironmentsSubscriptionsUpdate_0 Method for EnvironmentsSubscriptionsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this subscription.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsSubscriptionsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsUpdate_262(ctx context.Context, id int32, projectId string) ApiEnvironmentsSubscriptionsUpdate_0Request {
	return ApiEnvironmentsSubscriptionsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Subscription
func (a *EnvironmentsAPIService) EnvironmentsSubscriptionsUpdate_262Execute(r ApiEnvironmentsSubscriptionsUpdate_0Request) (*Subscription, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Subscription
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsSubscriptionsUpdate_262")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/subscriptions/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscription == nil {
		return localVarReturnValue, nil, reportError("subscription is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.subscription
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id int32
	projectId string
	team *Team
}

func (r ApiEnvironmentsUpdateRequest) Team(team Team) ApiEnvironmentsUpdateRequest {
	r.team = &team
	return r
}

func (r ApiEnvironmentsUpdateRequest) Execute() (*Team, *http.Response, error) {
	return r.ApiService.EnvironmentsUpdateExecute(r)
}

/*
EnvironmentsUpdate Method for EnvironmentsUpdate

Projects for the current organization.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this environment (aka team).
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsUpdate(ctx context.Context, id int32, projectId string) ApiEnvironmentsUpdateRequest {
	return ApiEnvironmentsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Team
func (a *EnvironmentsAPIService) EnvironmentsUpdateExecute(r ApiEnvironmentsUpdateRequest) (*Team, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Team
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/environments/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.team
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	id *string
	createdBy *UserBasic
	createdAt *time.Time
	transcript *string
	audio *string
	intervieweeEmails *[]string
	summary *string
}

func (r ApiEnvironmentsUserInterviewsCreateRequest) Id(id string) ApiEnvironmentsUserInterviewsCreateRequest {
	r.id = &id
	return r
}

func (r ApiEnvironmentsUserInterviewsCreateRequest) CreatedBy(createdBy UserBasic) ApiEnvironmentsUserInterviewsCreateRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsUserInterviewsCreateRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsUserInterviewsCreateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsUserInterviewsCreateRequest) Transcript(transcript string) ApiEnvironmentsUserInterviewsCreateRequest {
	r.transcript = &transcript
	return r
}

func (r ApiEnvironmentsUserInterviewsCreateRequest) Audio(audio string) ApiEnvironmentsUserInterviewsCreateRequest {
	r.audio = &audio
	return r
}

func (r ApiEnvironmentsUserInterviewsCreateRequest) IntervieweeEmails(intervieweeEmails []string) ApiEnvironmentsUserInterviewsCreateRequest {
	r.intervieweeEmails = &intervieweeEmails
	return r
}

func (r ApiEnvironmentsUserInterviewsCreateRequest) Summary(summary string) ApiEnvironmentsUserInterviewsCreateRequest {
	r.summary = &summary
	return r
}

func (r ApiEnvironmentsUserInterviewsCreateRequest) Execute() (*UserInterview, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsCreateExecute(r)
}

/*
EnvironmentsUserInterviewsCreate Method for EnvironmentsUserInterviewsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsCreate(ctx context.Context, projectId string) ApiEnvironmentsUserInterviewsCreateRequest {
	return ApiEnvironmentsUserInterviewsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return UserInterview
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsCreateExecute(r ApiEnvironmentsUserInterviewsCreateRequest) (*UserInterview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInterview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.createdBy == nil {
		return localVarReturnValue, nil, reportError("createdBy is required and must be specified")
	}
	if r.createdAt == nil {
		return localVarReturnValue, nil, reportError("createdAt is required and must be specified")
	}
	if r.transcript == nil {
		return localVarReturnValue, nil, reportError("transcript is required and must be specified")
	}
	if r.audio == nil {
		return localVarReturnValue, nil, reportError("audio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_by", r.createdBy, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.intervieweeEmails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interviewee_emails", r.intervieweeEmails, "", "csv")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "transcript", r.transcript, "", "")
	if r.summary != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "summary", r.summary, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "audio", r.audio, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	id *string
	createdBy *UserBasic
	createdAt *time.Time
	transcript *string
	audio *string
	intervieweeEmails *[]string
	summary *string
}

func (r ApiEnvironmentsUserInterviewsCreate_0Request) Id(id string) ApiEnvironmentsUserInterviewsCreate_0Request {
	r.id = &id
	return r
}

func (r ApiEnvironmentsUserInterviewsCreate_0Request) CreatedBy(createdBy UserBasic) ApiEnvironmentsUserInterviewsCreate_0Request {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsUserInterviewsCreate_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsUserInterviewsCreate_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsUserInterviewsCreate_0Request) Transcript(transcript string) ApiEnvironmentsUserInterviewsCreate_0Request {
	r.transcript = &transcript
	return r
}

func (r ApiEnvironmentsUserInterviewsCreate_0Request) Audio(audio string) ApiEnvironmentsUserInterviewsCreate_0Request {
	r.audio = &audio
	return r
}

func (r ApiEnvironmentsUserInterviewsCreate_0Request) IntervieweeEmails(intervieweeEmails []string) ApiEnvironmentsUserInterviewsCreate_0Request {
	r.intervieweeEmails = &intervieweeEmails
	return r
}

func (r ApiEnvironmentsUserInterviewsCreate_0Request) Summary(summary string) ApiEnvironmentsUserInterviewsCreate_0Request {
	r.summary = &summary
	return r
}

func (r ApiEnvironmentsUserInterviewsCreate_0Request) Execute() (*UserInterview, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsCreate_263Execute(r)
}

/*
EnvironmentsUserInterviewsCreate_0 Method for EnvironmentsUserInterviewsCreate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsCreate_263(ctx context.Context, projectId string) ApiEnvironmentsUserInterviewsCreate_0Request {
	return ApiEnvironmentsUserInterviewsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return UserInterview
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsCreate_263Execute(r ApiEnvironmentsUserInterviewsCreate_0Request) (*UserInterview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInterview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsCreate_263")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return localVarReturnValue, nil, reportError("id is required and must be specified")
	}
	if r.createdBy == nil {
		return localVarReturnValue, nil, reportError("createdBy is required and must be specified")
	}
	if r.createdAt == nil {
		return localVarReturnValue, nil, reportError("createdAt is required and must be specified")
	}
	if r.transcript == nil {
		return localVarReturnValue, nil, reportError("transcript is required and must be specified")
	}
	if r.audio == nil {
		return localVarReturnValue, nil, reportError("audio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_by", r.createdBy, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.intervieweeEmails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interviewee_emails", r.intervieweeEmails, "", "csv")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "transcript", r.transcript, "", "")
	if r.summary != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "summary", r.summary, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "audio", r.audio, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsUserInterviewsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsDestroyExecute(r)
}

/*
EnvironmentsUserInterviewsDestroy Method for EnvironmentsUserInterviewsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user interview.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsUserInterviewsDestroyRequest {
	return ApiEnvironmentsUserInterviewsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsDestroyExecute(r ApiEnvironmentsUserInterviewsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsUserInterviewsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsDestroy_264Execute(r)
}

/*
EnvironmentsUserInterviewsDestroy_0 Method for EnvironmentsUserInterviewsDestroy_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user interview.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsDestroy_264(ctx context.Context, id string, projectId string) ApiEnvironmentsUserInterviewsDestroy_0Request {
	return ApiEnvironmentsUserInterviewsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsDestroy_264Execute(r ApiEnvironmentsUserInterviewsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsDestroy_264")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsUserInterviewsListRequest) Limit(limit int32) ApiEnvironmentsUserInterviewsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsUserInterviewsListRequest) Offset(offset int32) ApiEnvironmentsUserInterviewsListRequest {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsUserInterviewsListRequest) Execute() (*PaginatedUserInterviewList, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsListExecute(r)
}

/*
EnvironmentsUserInterviewsList Method for EnvironmentsUserInterviewsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsList(ctx context.Context, projectId string) ApiEnvironmentsUserInterviewsListRequest {
	return ApiEnvironmentsUserInterviewsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedUserInterviewList
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsListExecute(r ApiEnvironmentsUserInterviewsListRequest) (*PaginatedUserInterviewList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedUserInterviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiEnvironmentsUserInterviewsList_0Request) Limit(limit int32) ApiEnvironmentsUserInterviewsList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsUserInterviewsList_0Request) Offset(offset int32) ApiEnvironmentsUserInterviewsList_0Request {
	r.offset = &offset
	return r
}

func (r ApiEnvironmentsUserInterviewsList_0Request) Execute() (*PaginatedUserInterviewList, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsList_265Execute(r)
}

/*
EnvironmentsUserInterviewsList_0 Method for EnvironmentsUserInterviewsList_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsList_265(ctx context.Context, projectId string) ApiEnvironmentsUserInterviewsList_0Request {
	return ApiEnvironmentsUserInterviewsList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedUserInterviewList
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsList_265Execute(r ApiEnvironmentsUserInterviewsList_0Request) (*PaginatedUserInterviewList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedUserInterviewList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsList_265")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	id2 *string
	createdBy *UserBasic
	createdAt *time.Time
	intervieweeEmails *[]string
	transcript *string
	summary *string
	audio *string
}

func (r ApiEnvironmentsUserInterviewsPartialUpdateRequest) Id2(id2 string) ApiEnvironmentsUserInterviewsPartialUpdateRequest {
	r.id2 = &id2
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdateRequest) CreatedBy(createdBy UserBasic) ApiEnvironmentsUserInterviewsPartialUpdateRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdateRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsUserInterviewsPartialUpdateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdateRequest) IntervieweeEmails(intervieweeEmails []string) ApiEnvironmentsUserInterviewsPartialUpdateRequest {
	r.intervieweeEmails = &intervieweeEmails
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdateRequest) Transcript(transcript string) ApiEnvironmentsUserInterviewsPartialUpdateRequest {
	r.transcript = &transcript
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdateRequest) Summary(summary string) ApiEnvironmentsUserInterviewsPartialUpdateRequest {
	r.summary = &summary
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdateRequest) Audio(audio string) ApiEnvironmentsUserInterviewsPartialUpdateRequest {
	r.audio = &audio
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdateRequest) Execute() (*UserInterview, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsPartialUpdateExecute(r)
}

/*
EnvironmentsUserInterviewsPartialUpdate Method for EnvironmentsUserInterviewsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user interview.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsUserInterviewsPartialUpdateRequest {
	return ApiEnvironmentsUserInterviewsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return UserInterview
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsPartialUpdateExecute(r ApiEnvironmentsUserInterviewsPartialUpdateRequest) (*UserInterview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInterview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	}
	if r.createdBy != nil {
		paramJson, err := parameterToJson(*r.createdBy)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("created_by", paramJson)
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	}
	if r.intervieweeEmails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interviewee_emails", r.intervieweeEmails, "", "csv")
	}
	if r.transcript != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transcript", r.transcript, "", "")
	}
	if r.summary != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "summary", r.summary, "", "")
	}
	if r.audio != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "audio", r.audio, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	id2 *string
	createdBy *UserBasic
	createdAt *time.Time
	intervieweeEmails *[]string
	transcript *string
	summary *string
	audio *string
}

func (r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) Id2(id2 string) ApiEnvironmentsUserInterviewsPartialUpdate_0Request {
	r.id2 = &id2
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) CreatedBy(createdBy UserBasic) ApiEnvironmentsUserInterviewsPartialUpdate_0Request {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsUserInterviewsPartialUpdate_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) IntervieweeEmails(intervieweeEmails []string) ApiEnvironmentsUserInterviewsPartialUpdate_0Request {
	r.intervieweeEmails = &intervieweeEmails
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) Transcript(transcript string) ApiEnvironmentsUserInterviewsPartialUpdate_0Request {
	r.transcript = &transcript
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) Summary(summary string) ApiEnvironmentsUserInterviewsPartialUpdate_0Request {
	r.summary = &summary
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) Audio(audio string) ApiEnvironmentsUserInterviewsPartialUpdate_0Request {
	r.audio = &audio
	return r
}

func (r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) Execute() (*UserInterview, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsPartialUpdate_266Execute(r)
}

/*
EnvironmentsUserInterviewsPartialUpdate_0 Method for EnvironmentsUserInterviewsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user interview.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsPartialUpdate_266(ctx context.Context, id string, projectId string) ApiEnvironmentsUserInterviewsPartialUpdate_0Request {
	return ApiEnvironmentsUserInterviewsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return UserInterview
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsPartialUpdate_266Execute(r ApiEnvironmentsUserInterviewsPartialUpdate_0Request) (*UserInterview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInterview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsPartialUpdate_266")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.id2 != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	}
	if r.createdBy != nil {
		paramJson, err := parameterToJson(*r.createdBy)
		if err != nil {
			return localVarReturnValue, nil, err
		}
		localVarFormParams.Add("created_by", paramJson)
	}
	if r.createdAt != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	}
	if r.intervieweeEmails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interviewee_emails", r.intervieweeEmails, "", "csv")
	}
	if r.transcript != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "transcript", r.transcript, "", "")
	}
	if r.summary != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "summary", r.summary, "", "")
	}
	if r.audio != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "audio", r.audio, "", "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsUserInterviewsRetrieveRequest) Execute() (*UserInterview, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsRetrieveExecute(r)
}

/*
EnvironmentsUserInterviewsRetrieve Method for EnvironmentsUserInterviewsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user interview.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsUserInterviewsRetrieveRequest {
	return ApiEnvironmentsUserInterviewsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return UserInterview
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsRetrieveExecute(r ApiEnvironmentsUserInterviewsRetrieveRequest) (*UserInterview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInterview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsUserInterviewsRetrieve_0Request) Execute() (*UserInterview, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsRetrieve_267Execute(r)
}

/*
EnvironmentsUserInterviewsRetrieve_0 Method for EnvironmentsUserInterviewsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user interview.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsRetrieve_267(ctx context.Context, id string, projectId string) ApiEnvironmentsUserInterviewsRetrieve_0Request {
	return ApiEnvironmentsUserInterviewsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return UserInterview
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsRetrieve_267Execute(r ApiEnvironmentsUserInterviewsRetrieve_0Request) (*UserInterview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInterview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsRetrieve_267")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	id2 *string
	createdBy *UserBasic
	createdAt *time.Time
	transcript *string
	audio *string
	intervieweeEmails *[]string
	summary *string
}

func (r ApiEnvironmentsUserInterviewsUpdateRequest) Id2(id2 string) ApiEnvironmentsUserInterviewsUpdateRequest {
	r.id2 = &id2
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdateRequest) CreatedBy(createdBy UserBasic) ApiEnvironmentsUserInterviewsUpdateRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdateRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsUserInterviewsUpdateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdateRequest) Transcript(transcript string) ApiEnvironmentsUserInterviewsUpdateRequest {
	r.transcript = &transcript
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdateRequest) Audio(audio string) ApiEnvironmentsUserInterviewsUpdateRequest {
	r.audio = &audio
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdateRequest) IntervieweeEmails(intervieweeEmails []string) ApiEnvironmentsUserInterviewsUpdateRequest {
	r.intervieweeEmails = &intervieweeEmails
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdateRequest) Summary(summary string) ApiEnvironmentsUserInterviewsUpdateRequest {
	r.summary = &summary
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdateRequest) Execute() (*UserInterview, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsUpdateExecute(r)
}

/*
EnvironmentsUserInterviewsUpdate Method for EnvironmentsUserInterviewsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user interview.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsUserInterviewsUpdateRequest {
	return ApiEnvironmentsUserInterviewsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return UserInterview
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsUpdateExecute(r ApiEnvironmentsUserInterviewsUpdateRequest) (*UserInterview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInterview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id2 == nil {
		return localVarReturnValue, nil, reportError("id2 is required and must be specified")
	}
	if r.createdBy == nil {
		return localVarReturnValue, nil, reportError("createdBy is required and must be specified")
	}
	if r.createdAt == nil {
		return localVarReturnValue, nil, reportError("createdAt is required and must be specified")
	}
	if r.transcript == nil {
		return localVarReturnValue, nil, reportError("transcript is required and must be specified")
	}
	if r.audio == nil {
		return localVarReturnValue, nil, reportError("audio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_by", r.createdBy, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.intervieweeEmails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interviewee_emails", r.intervieweeEmails, "", "csv")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "transcript", r.transcript, "", "")
	if r.summary != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "summary", r.summary, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "audio", r.audio, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsUserInterviewsUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	id2 *string
	createdBy *UserBasic
	createdAt *time.Time
	transcript *string
	audio *string
	intervieweeEmails *[]string
	summary *string
}

func (r ApiEnvironmentsUserInterviewsUpdate_0Request) Id2(id2 string) ApiEnvironmentsUserInterviewsUpdate_0Request {
	r.id2 = &id2
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdate_0Request) CreatedBy(createdBy UserBasic) ApiEnvironmentsUserInterviewsUpdate_0Request {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdate_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsUserInterviewsUpdate_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdate_0Request) Transcript(transcript string) ApiEnvironmentsUserInterviewsUpdate_0Request {
	r.transcript = &transcript
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdate_0Request) Audio(audio string) ApiEnvironmentsUserInterviewsUpdate_0Request {
	r.audio = &audio
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdate_0Request) IntervieweeEmails(intervieweeEmails []string) ApiEnvironmentsUserInterviewsUpdate_0Request {
	r.intervieweeEmails = &intervieweeEmails
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdate_0Request) Summary(summary string) ApiEnvironmentsUserInterviewsUpdate_0Request {
	r.summary = &summary
	return r
}

func (r ApiEnvironmentsUserInterviewsUpdate_0Request) Execute() (*UserInterview, *http.Response, error) {
	return r.ApiService.EnvironmentsUserInterviewsUpdate_268Execute(r)
}

/*
EnvironmentsUserInterviewsUpdate_0 Method for EnvironmentsUserInterviewsUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this user interview.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsUserInterviewsUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsUpdate_268(ctx context.Context, id string, projectId string) ApiEnvironmentsUserInterviewsUpdate_0Request {
	return ApiEnvironmentsUserInterviewsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return UserInterview
func (a *EnvironmentsAPIService) EnvironmentsUserInterviewsUpdate_268Execute(r ApiEnvironmentsUserInterviewsUpdate_0Request) (*UserInterview, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserInterview
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsUserInterviewsUpdate_268")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/user_interviews/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id2 == nil {
		return localVarReturnValue, nil, reportError("id2 is required and must be specified")
	}
	if r.createdBy == nil {
		return localVarReturnValue, nil, reportError("createdBy is required and must be specified")
	}
	if r.createdAt == nil {
		return localVarReturnValue, nil, reportError("createdAt is required and must be specified")
	}
	if r.transcript == nil {
		return localVarReturnValue, nil, reportError("transcript is required and must be specified")
	}
	if r.audio == nil {
		return localVarReturnValue, nil, reportError("audio is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id2, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_by", r.createdBy, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	if r.intervieweeEmails != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "interviewee_emails", r.intervieweeEmails, "", "csv")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "transcript", r.transcript, "", "")
	if r.summary != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "summary", r.summary, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "audio", r.audio, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesActivityRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesActivityRetrieveRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesActivityRetrieveExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesActivityRetrieve Method for EnvironmentsWarehouseSavedQueriesActivityRetrieve

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesActivityRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesActivityRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesActivityRetrieveRequest {
	return ApiEnvironmentsWarehouseSavedQueriesActivityRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesActivityRetrieveExecute(r ApiEnvironmentsWarehouseSavedQueriesActivityRetrieveRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesActivityRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesActivityRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesActivityRetrieve_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesActivityRetrieve_269Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesActivityRetrieve_0 Method for EnvironmentsWarehouseSavedQueriesActivityRetrieve_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesActivityRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesActivityRetrieve_269(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesActivityRetrieve_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesActivityRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesActivityRetrieve_269Execute(r ApiEnvironmentsWarehouseSavedQueriesActivityRetrieve_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesActivityRetrieve_269")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesAncestorsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesAncestorsCreateRequest) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesAncestorsCreateRequest {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesAncestorsCreateRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesAncestorsCreateExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesAncestorsCreate Method for EnvironmentsWarehouseSavedQueriesAncestorsCreate

Return the ancestors of this saved query.

By default, we return the immediate parents. The `level` parameter can be used to
look further back into the ancestor tree. If `level` overshoots (i.e. points to only
ancestors beyond the root), we return an empty list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesAncestorsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesAncestorsCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesAncestorsCreateRequest {
	return ApiEnvironmentsWarehouseSavedQueriesAncestorsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesAncestorsCreateExecute(r ApiEnvironmentsWarehouseSavedQueriesAncestorsCreateRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesAncestorsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/ancestors/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesAncestorsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesAncestorsCreate_0Request) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesAncestorsCreate_0Request {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesAncestorsCreate_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesAncestorsCreate_270Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesAncestorsCreate_0 Method for EnvironmentsWarehouseSavedQueriesAncestorsCreate_0

Return the ancestors of this saved query.

By default, we return the immediate parents. The `level` parameter can be used to
look further back into the ancestor tree. If `level` overshoots (i.e. points to only
ancestors beyond the root), we return an empty list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesAncestorsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesAncestorsCreate_270(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesAncestorsCreate_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesAncestorsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesAncestorsCreate_270Execute(r ApiEnvironmentsWarehouseSavedQueriesAncestorsCreate_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesAncestorsCreate_270")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/ancestors/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesCancelCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesCancelCreateRequest) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesCancelCreateRequest {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesCancelCreateRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesCancelCreateExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesCancelCreate Method for EnvironmentsWarehouseSavedQueriesCancelCreate

Cancel a running saved query workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesCancelCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesCancelCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesCancelCreateRequest {
	return ApiEnvironmentsWarehouseSavedQueriesCancelCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesCancelCreateExecute(r ApiEnvironmentsWarehouseSavedQueriesCancelCreateRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesCancelCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesCancelCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesCancelCreate_0Request) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesCancelCreate_0Request {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesCancelCreate_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesCancelCreate_271Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesCancelCreate_0 Method for EnvironmentsWarehouseSavedQueriesCancelCreate_0

Cancel a running saved query workflow.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesCancelCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesCancelCreate_271(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesCancelCreate_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesCancelCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesCancelCreate_271Execute(r ApiEnvironmentsWarehouseSavedQueriesCancelCreate_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesCancelCreate_271")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesCreateRequest) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesCreateRequest {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesCreateRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesCreateExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesCreate Method for EnvironmentsWarehouseSavedQueriesCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesCreate(ctx context.Context, projectId string) ApiEnvironmentsWarehouseSavedQueriesCreateRequest {
	return ApiEnvironmentsWarehouseSavedQueriesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesCreateExecute(r ApiEnvironmentsWarehouseSavedQueriesCreateRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesCreate_0Request) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesCreate_0Request {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesCreate_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesCreate_272Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesCreate_0 Method for EnvironmentsWarehouseSavedQueriesCreate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesCreate_272(ctx context.Context, projectId string) ApiEnvironmentsWarehouseSavedQueriesCreate_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesCreate_272Execute(r ApiEnvironmentsWarehouseSavedQueriesCreate_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesCreate_272")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieveRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesDependenciesRetrieveExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesDependenciesRetrieve Method for EnvironmentsWarehouseSavedQueriesDependenciesRetrieve

Return the count of immediate upstream and downstream dependencies for this saved query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDependenciesRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieveRequest {
	return ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDependenciesRetrieveExecute(r ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieveRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesDependenciesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/dependencies/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieve_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesDependenciesRetrieve_273Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesDependenciesRetrieve_0 Method for EnvironmentsWarehouseSavedQueriesDependenciesRetrieve_0

Return the count of immediate upstream and downstream dependencies for this saved query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDependenciesRetrieve_273(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieve_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDependenciesRetrieve_273Execute(r ApiEnvironmentsWarehouseSavedQueriesDependenciesRetrieve_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesDependenciesRetrieve_273")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/dependencies/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesDescendantsCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesDescendantsCreateRequest) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesDescendantsCreateRequest {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesDescendantsCreateRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesDescendantsCreateExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesDescendantsCreate Method for EnvironmentsWarehouseSavedQueriesDescendantsCreate

Return the descendants of this saved query.

By default, we return the immediate children. The `level` parameter can be used to
look further ahead into the descendants tree. If `level` overshoots (i.e. points to only
descendants further than a leaf), we return an empty list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesDescendantsCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDescendantsCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesDescendantsCreateRequest {
	return ApiEnvironmentsWarehouseSavedQueriesDescendantsCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDescendantsCreateExecute(r ApiEnvironmentsWarehouseSavedQueriesDescendantsCreateRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesDescendantsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/descendants/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesDescendantsCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesDescendantsCreate_0Request) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesDescendantsCreate_0Request {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesDescendantsCreate_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesDescendantsCreate_274Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesDescendantsCreate_0 Method for EnvironmentsWarehouseSavedQueriesDescendantsCreate_0

Return the descendants of this saved query.

By default, we return the immediate children. The `level` parameter can be used to
look further ahead into the descendants tree. If `level` overshoots (i.e. points to only
descendants further than a leaf), we return an empty list.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesDescendantsCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDescendantsCreate_274(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesDescendantsCreate_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesDescendantsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDescendantsCreate_274Execute(r ApiEnvironmentsWarehouseSavedQueriesDescendantsCreate_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesDescendantsCreate_274")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/descendants/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesDestroyExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesDestroy Method for EnvironmentsWarehouseSavedQueriesDestroy

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesDestroyRequest {
	return ApiEnvironmentsWarehouseSavedQueriesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDestroyExecute(r ApiEnvironmentsWarehouseSavedQueriesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesDestroy_275Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesDestroy_0 Method for EnvironmentsWarehouseSavedQueriesDestroy_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDestroy_275(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesDestroy_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesDestroy_275Execute(r ApiEnvironmentsWarehouseSavedQueriesDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesDestroy_275")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	page *int32
	search *string
}

// A page number within the paginated result set.
func (r ApiEnvironmentsWarehouseSavedQueriesListRequest) Page(page int32) ApiEnvironmentsWarehouseSavedQueriesListRequest {
	r.page = &page
	return r
}

// A search term.
func (r ApiEnvironmentsWarehouseSavedQueriesListRequest) Search(search string) ApiEnvironmentsWarehouseSavedQueriesListRequest {
	r.search = &search
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesListRequest) Execute() (*PaginatedDataWarehouseSavedQueryList, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesListExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesList Method for EnvironmentsWarehouseSavedQueriesList

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesList(ctx context.Context, projectId string) ApiEnvironmentsWarehouseSavedQueriesListRequest {
	return ApiEnvironmentsWarehouseSavedQueriesListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDataWarehouseSavedQueryList
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesListExecute(r ApiEnvironmentsWarehouseSavedQueriesListRequest) (*PaginatedDataWarehouseSavedQueryList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDataWarehouseSavedQueryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	page *int32
	search *string
}

// A page number within the paginated result set.
func (r ApiEnvironmentsWarehouseSavedQueriesList_0Request) Page(page int32) ApiEnvironmentsWarehouseSavedQueriesList_0Request {
	r.page = &page
	return r
}

// A search term.
func (r ApiEnvironmentsWarehouseSavedQueriesList_0Request) Search(search string) ApiEnvironmentsWarehouseSavedQueriesList_0Request {
	r.search = &search
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesList_0Request) Execute() (*PaginatedDataWarehouseSavedQueryList, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesList_276Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesList_0 Method for EnvironmentsWarehouseSavedQueriesList_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesList_276(ctx context.Context, projectId string) ApiEnvironmentsWarehouseSavedQueriesList_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedDataWarehouseSavedQueryList
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesList_276Execute(r ApiEnvironmentsWarehouseSavedQueriesList_0Request) (*PaginatedDataWarehouseSavedQueryList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedDataWarehouseSavedQueryList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesList_276")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedDataWarehouseSavedQuery *PatchedDataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesPartialUpdateRequest) PatchedDataWarehouseSavedQuery(patchedDataWarehouseSavedQuery PatchedDataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesPartialUpdateRequest {
	r.patchedDataWarehouseSavedQuery = &patchedDataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesPartialUpdateRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesPartialUpdateExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesPartialUpdate Method for EnvironmentsWarehouseSavedQueriesPartialUpdate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesPartialUpdateRequest {
	return ApiEnvironmentsWarehouseSavedQueriesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesPartialUpdateExecute(r ApiEnvironmentsWarehouseSavedQueriesPartialUpdateRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedDataWarehouseSavedQuery *PatchedDataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesPartialUpdate_0Request) PatchedDataWarehouseSavedQuery(patchedDataWarehouseSavedQuery PatchedDataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesPartialUpdate_0Request {
	r.patchedDataWarehouseSavedQuery = &patchedDataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesPartialUpdate_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesPartialUpdate_277Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesPartialUpdate_0 Method for EnvironmentsWarehouseSavedQueriesPartialUpdate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesPartialUpdate_277(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesPartialUpdate_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesPartialUpdate_277Execute(r ApiEnvironmentsWarehouseSavedQueriesPartialUpdate_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesPartialUpdate_277")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedDataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesRetrieveRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesRetrieveExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesRetrieve Method for EnvironmentsWarehouseSavedQueriesRetrieve

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesRetrieveRequest {
	return ApiEnvironmentsWarehouseSavedQueriesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRetrieveExecute(r ApiEnvironmentsWarehouseSavedQueriesRetrieveRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesRetrieve_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesRetrieve_278Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesRetrieve_0 Method for EnvironmentsWarehouseSavedQueriesRetrieve_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRetrieve_278(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesRetrieve_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRetrieve_278Execute(r ApiEnvironmentsWarehouseSavedQueriesRetrieve_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesRetrieve_278")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreateRequest) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreateRequest {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreateRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesRevertMaterializationCreateExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate Method for EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate

Undo materialization, revert back to the original view.
(i.e. delete the materialized table and the schedule)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreateRequest {
	return ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRevertMaterializationCreateExecute(r ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreateRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/revert_materialization/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0Request) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0Request {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_279Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0 Method for EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0

Undo materialization, revert back to the original view.
(i.e. delete the materialized table and the schedule)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_279(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_279Execute(r ApiEnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesRevertMaterializationCreate_279")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/revert_materialization/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesRunCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesRunCreateRequest) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesRunCreateRequest {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesRunCreateRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesRunCreateExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesRunCreate Method for EnvironmentsWarehouseSavedQueriesRunCreate

Run this saved query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesRunCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRunCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesRunCreateRequest {
	return ApiEnvironmentsWarehouseSavedQueriesRunCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRunCreateExecute(r ApiEnvironmentsWarehouseSavedQueriesRunCreateRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesRunCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesRunCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesRunCreate_0Request) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesRunCreate_0Request {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesRunCreate_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesRunCreate_280Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesRunCreate_0 Method for EnvironmentsWarehouseSavedQueriesRunCreate_0

Run this saved query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesRunCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRunCreate_280(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesRunCreate_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesRunCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRunCreate_280Execute(r ApiEnvironmentsWarehouseSavedQueriesRunCreate_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesRunCreate_280")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieveRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesRunHistoryRetrieveExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve Method for EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve

Return the recent run history (up to 5 most recent) for this materialized view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieveRequest {
	return ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRunHistoryRetrieveExecute(r ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieveRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/run_history/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_281Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_0 Method for EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_0

Return the recent run history (up to 5 most recent) for this materialized view.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_281(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_281Execute(r ApiEnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesRunHistoryRetrieve_281")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/run_history/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesUpdateRequest) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesUpdateRequest {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesUpdateRequest) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesUpdateExecute(r)
}

/*
EnvironmentsWarehouseSavedQueriesUpdate Method for EnvironmentsWarehouseSavedQueriesUpdate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesUpdateRequest {
	return ApiEnvironmentsWarehouseSavedQueriesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesUpdateExecute(r ApiEnvironmentsWarehouseSavedQueriesUpdateRequest) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseSavedQueriesUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	dataWarehouseSavedQuery *DataWarehouseSavedQuery
}

func (r ApiEnvironmentsWarehouseSavedQueriesUpdate_0Request) DataWarehouseSavedQuery(dataWarehouseSavedQuery DataWarehouseSavedQuery) ApiEnvironmentsWarehouseSavedQueriesUpdate_0Request {
	r.dataWarehouseSavedQuery = &dataWarehouseSavedQuery
	return r
}

func (r ApiEnvironmentsWarehouseSavedQueriesUpdate_0Request) Execute() (*DataWarehouseSavedQuery, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseSavedQueriesUpdate_282Execute(r)
}

/*
EnvironmentsWarehouseSavedQueriesUpdate_0 Method for EnvironmentsWarehouseSavedQueriesUpdate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse saved query.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseSavedQueriesUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesUpdate_282(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseSavedQueriesUpdate_0Request {
	return ApiEnvironmentsWarehouseSavedQueriesUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return DataWarehouseSavedQuery
func (a *EnvironmentsAPIService) EnvironmentsWarehouseSavedQueriesUpdate_282Execute(r ApiEnvironmentsWarehouseSavedQueriesUpdate_0Request) (*DataWarehouseSavedQuery, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DataWarehouseSavedQuery
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseSavedQueriesUpdate_282")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_saved_queries/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dataWarehouseSavedQuery == nil {
		return localVarReturnValue, nil, reportError("dataWarehouseSavedQuery is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.dataWarehouseSavedQuery
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	table *Table
}

func (r ApiEnvironmentsWarehouseTablesCreateRequest) Table(table Table) ApiEnvironmentsWarehouseTablesCreateRequest {
	r.table = &table
	return r
}

func (r ApiEnvironmentsWarehouseTablesCreateRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesCreateExecute(r)
}

/*
EnvironmentsWarehouseTablesCreate Method for EnvironmentsWarehouseTablesCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesCreate(ctx context.Context, projectId string) ApiEnvironmentsWarehouseTablesCreateRequest {
	return ApiEnvironmentsWarehouseTablesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesCreateExecute(r ApiEnvironmentsWarehouseTablesCreateRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return localVarReturnValue, nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	table *Table
}

func (r ApiEnvironmentsWarehouseTablesCreate_0Request) Table(table Table) ApiEnvironmentsWarehouseTablesCreate_0Request {
	r.table = &table
	return r
}

func (r ApiEnvironmentsWarehouseTablesCreate_0Request) Execute() (*Table, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesCreate_283Execute(r)
}

/*
EnvironmentsWarehouseTablesCreate_0 Method for EnvironmentsWarehouseTablesCreate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesCreate_283(ctx context.Context, projectId string) ApiEnvironmentsWarehouseTablesCreate_0Request {
	return ApiEnvironmentsWarehouseTablesCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesCreate_283Execute(r ApiEnvironmentsWarehouseTablesCreate_0Request) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesCreate_283")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return localVarReturnValue, nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesDestroyRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseTablesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesDestroyExecute(r)
}

/*
EnvironmentsWarehouseTablesDestroy Method for EnvironmentsWarehouseTablesDestroy

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesDestroyRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesDestroy(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesDestroyRequest {
	return ApiEnvironmentsWarehouseTablesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesDestroyExecute(r ApiEnvironmentsWarehouseTablesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesDestroy_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseTablesDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesDestroy_284Execute(r)
}

/*
EnvironmentsWarehouseTablesDestroy_0 Method for EnvironmentsWarehouseTablesDestroy_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesDestroy_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesDestroy_284(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesDestroy_0Request {
	return ApiEnvironmentsWarehouseTablesDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesDestroy_284Execute(r ApiEnvironmentsWarehouseTablesDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesDestroy_284")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesFileCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	id *string
	name *string
	format *TableFormatEnum
	createdBy *UserBasic
	createdAt *time.Time
	urlPattern *string
	credential *Credential
	columns *string
	externalDataSource *SimpleExternalDataSourceSerializers
	externalSchema *string
	deleted *bool
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) Id(id string) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.id = &id
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) Name(name string) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.name = &name
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) Format(format TableFormatEnum) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.format = &format
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) CreatedBy(createdBy UserBasic) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) CreatedAt(createdAt time.Time) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) UrlPattern(urlPattern string) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.urlPattern = &urlPattern
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) Credential(credential Credential) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.credential = &credential
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) Columns(columns string) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.columns = &columns
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) ExternalDataSource(externalDataSource SimpleExternalDataSourceSerializers) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.externalDataSource = &externalDataSource
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) ExternalSchema(externalSchema string) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.externalSchema = &externalSchema
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) Deleted(deleted bool) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	r.deleted = &deleted
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesFileCreateExecute(r)
}

/*
EnvironmentsWarehouseTablesFileCreate Method for EnvironmentsWarehouseTablesFileCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesFileCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesFileCreate(ctx context.Context, projectId string) ApiEnvironmentsWarehouseTablesFileCreateRequest {
	return ApiEnvironmentsWarehouseTablesFileCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesFileCreateExecute(r ApiEnvironmentsWarehouseTablesFileCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesFileCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/file/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) > 128 {
		return nil, reportError("name must have less than 128 elements")
	}
	if r.format == nil {
		return nil, reportError("format is required and must be specified")
	}
	if r.createdBy == nil {
		return nil, reportError("createdBy is required and must be specified")
	}
	if r.createdAt == nil {
		return nil, reportError("createdAt is required and must be specified")
	}
	if r.urlPattern == nil {
		return nil, reportError("urlPattern is required and must be specified")
	}
	if strlen(*r.urlPattern) > 500 {
		return nil, reportError("urlPattern must have less than 500 elements")
	}
	if r.credential == nil {
		return nil, reportError("credential is required and must be specified")
	}
	if r.columns == nil {
		return nil, reportError("columns is required and must be specified")
	}
	if r.externalDataSource == nil {
		return nil, reportError("externalDataSource is required and must be specified")
	}
	if r.externalSchema == nil {
		return nil, reportError("externalSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deleted", r.deleted, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "format", r.format, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_by", r.createdBy, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "url_pattern", r.urlPattern, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "credential", r.credential, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "columns", r.columns, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "external_data_source", r.externalDataSource, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "external_schema", r.externalSchema, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesFileCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	id *string
	name *string
	format *TableFormatEnum
	createdBy *UserBasic
	createdAt *time.Time
	urlPattern *string
	credential *Credential
	columns *string
	externalDataSource *SimpleExternalDataSourceSerializers
	externalSchema *string
	deleted *bool
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) Id(id string) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.id = &id
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) Name(name string) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.name = &name
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) Format(format TableFormatEnum) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.format = &format
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) CreatedBy(createdBy UserBasic) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.createdBy = &createdBy
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) CreatedAt(createdAt time.Time) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.createdAt = &createdAt
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) UrlPattern(urlPattern string) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.urlPattern = &urlPattern
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) Credential(credential Credential) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.credential = &credential
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) Columns(columns string) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.columns = &columns
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) ExternalDataSource(externalDataSource SimpleExternalDataSourceSerializers) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.externalDataSource = &externalDataSource
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) ExternalSchema(externalSchema string) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.externalSchema = &externalSchema
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) Deleted(deleted bool) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	r.deleted = &deleted
	return r
}

func (r ApiEnvironmentsWarehouseTablesFileCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesFileCreate_285Execute(r)
}

/*
EnvironmentsWarehouseTablesFileCreate_0 Method for EnvironmentsWarehouseTablesFileCreate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesFileCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesFileCreate_285(ctx context.Context, projectId string) ApiEnvironmentsWarehouseTablesFileCreate_0Request {
	return ApiEnvironmentsWarehouseTablesFileCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesFileCreate_285Execute(r ApiEnvironmentsWarehouseTablesFileCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesFileCreate_285")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/file/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) > 128 {
		return nil, reportError("name must have less than 128 elements")
	}
	if r.format == nil {
		return nil, reportError("format is required and must be specified")
	}
	if r.createdBy == nil {
		return nil, reportError("createdBy is required and must be specified")
	}
	if r.createdAt == nil {
		return nil, reportError("createdAt is required and must be specified")
	}
	if r.urlPattern == nil {
		return nil, reportError("urlPattern is required and must be specified")
	}
	if strlen(*r.urlPattern) > 500 {
		return nil, reportError("urlPattern must have less than 500 elements")
	}
	if r.credential == nil {
		return nil, reportError("credential is required and must be specified")
	}
	if r.columns == nil {
		return nil, reportError("columns is required and must be specified")
	}
	if r.externalDataSource == nil {
		return nil, reportError("externalDataSource is required and must be specified")
	}
	if r.externalSchema == nil {
		return nil, reportError("externalSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deleted", r.deleted, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "format", r.format, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_by", r.createdBy, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "url_pattern", r.urlPattern, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "credential", r.credential, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "columns", r.columns, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "external_data_source", r.externalDataSource, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "external_schema", r.externalSchema, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesListRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
	search *string
}

// Number of results to return per page.
func (r ApiEnvironmentsWarehouseTablesListRequest) Limit(limit int32) ApiEnvironmentsWarehouseTablesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsWarehouseTablesListRequest) Offset(offset int32) ApiEnvironmentsWarehouseTablesListRequest {
	r.offset = &offset
	return r
}

// A search term.
func (r ApiEnvironmentsWarehouseTablesListRequest) Search(search string) ApiEnvironmentsWarehouseTablesListRequest {
	r.search = &search
	return r
}

func (r ApiEnvironmentsWarehouseTablesListRequest) Execute() (*PaginatedTableList, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesListExecute(r)
}

/*
EnvironmentsWarehouseTablesList Method for EnvironmentsWarehouseTablesList

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesListRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesList(ctx context.Context, projectId string) ApiEnvironmentsWarehouseTablesListRequest {
	return ApiEnvironmentsWarehouseTablesListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedTableList
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesListExecute(r ApiEnvironmentsWarehouseTablesListRequest) (*PaginatedTableList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTableList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesList_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	projectId string
	limit *int32
	offset *int32
	search *string
}

// Number of results to return per page.
func (r ApiEnvironmentsWarehouseTablesList_0Request) Limit(limit int32) ApiEnvironmentsWarehouseTablesList_0Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiEnvironmentsWarehouseTablesList_0Request) Offset(offset int32) ApiEnvironmentsWarehouseTablesList_0Request {
	r.offset = &offset
	return r
}

// A search term.
func (r ApiEnvironmentsWarehouseTablesList_0Request) Search(search string) ApiEnvironmentsWarehouseTablesList_0Request {
	r.search = &search
	return r
}

func (r ApiEnvironmentsWarehouseTablesList_0Request) Execute() (*PaginatedTableList, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesList_286Execute(r)
}

/*
EnvironmentsWarehouseTablesList_0 Method for EnvironmentsWarehouseTablesList_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesList_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesList_286(ctx context.Context, projectId string) ApiEnvironmentsWarehouseTablesList_0Request {
	return ApiEnvironmentsWarehouseTablesList_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedTableList
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesList_286Execute(r ApiEnvironmentsWarehouseTablesList_0Request) (*PaginatedTableList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTableList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesList_286")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedTable *PatchedTable
}

func (r ApiEnvironmentsWarehouseTablesPartialUpdateRequest) PatchedTable(patchedTable PatchedTable) ApiEnvironmentsWarehouseTablesPartialUpdateRequest {
	r.patchedTable = &patchedTable
	return r
}

func (r ApiEnvironmentsWarehouseTablesPartialUpdateRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesPartialUpdateExecute(r)
}

/*
EnvironmentsWarehouseTablesPartialUpdate Method for EnvironmentsWarehouseTablesPartialUpdate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesPartialUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesPartialUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesPartialUpdateRequest {
	return ApiEnvironmentsWarehouseTablesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesPartialUpdateExecute(r ApiEnvironmentsWarehouseTablesPartialUpdateRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTable
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	patchedTable *PatchedTable
}

func (r ApiEnvironmentsWarehouseTablesPartialUpdate_0Request) PatchedTable(patchedTable PatchedTable) ApiEnvironmentsWarehouseTablesPartialUpdate_0Request {
	r.patchedTable = &patchedTable
	return r
}

func (r ApiEnvironmentsWarehouseTablesPartialUpdate_0Request) Execute() (*Table, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesPartialUpdate_287Execute(r)
}

/*
EnvironmentsWarehouseTablesPartialUpdate_0 Method for EnvironmentsWarehouseTablesPartialUpdate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesPartialUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesPartialUpdate_287(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesPartialUpdate_0Request {
	return ApiEnvironmentsWarehouseTablesPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesPartialUpdate_287Execute(r ApiEnvironmentsWarehouseTablesPartialUpdate_0Request) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesPartialUpdate_287")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTable
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesRefreshSchemaCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	table *Table
}

func (r ApiEnvironmentsWarehouseTablesRefreshSchemaCreateRequest) Table(table Table) ApiEnvironmentsWarehouseTablesRefreshSchemaCreateRequest {
	r.table = &table
	return r
}

func (r ApiEnvironmentsWarehouseTablesRefreshSchemaCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesRefreshSchemaCreateExecute(r)
}

/*
EnvironmentsWarehouseTablesRefreshSchemaCreate Method for EnvironmentsWarehouseTablesRefreshSchemaCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesRefreshSchemaCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesRefreshSchemaCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesRefreshSchemaCreateRequest {
	return ApiEnvironmentsWarehouseTablesRefreshSchemaCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesRefreshSchemaCreateExecute(r ApiEnvironmentsWarehouseTablesRefreshSchemaCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesRefreshSchemaCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/refresh_schema/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesRefreshSchemaCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	table *Table
}

func (r ApiEnvironmentsWarehouseTablesRefreshSchemaCreate_0Request) Table(table Table) ApiEnvironmentsWarehouseTablesRefreshSchemaCreate_0Request {
	r.table = &table
	return r
}

func (r ApiEnvironmentsWarehouseTablesRefreshSchemaCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesRefreshSchemaCreate_288Execute(r)
}

/*
EnvironmentsWarehouseTablesRefreshSchemaCreate_0 Method for EnvironmentsWarehouseTablesRefreshSchemaCreate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesRefreshSchemaCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesRefreshSchemaCreate_288(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesRefreshSchemaCreate_0Request {
	return ApiEnvironmentsWarehouseTablesRefreshSchemaCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesRefreshSchemaCreate_288Execute(r ApiEnvironmentsWarehouseTablesRefreshSchemaCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesRefreshSchemaCreate_288")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/refresh_schema/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseTablesRetrieveRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesRetrieveExecute(r)
}

/*
EnvironmentsWarehouseTablesRetrieve Method for EnvironmentsWarehouseTablesRetrieve

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesRetrieve(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesRetrieveRequest {
	return ApiEnvironmentsWarehouseTablesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesRetrieveExecute(r ApiEnvironmentsWarehouseTablesRetrieveRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
}

func (r ApiEnvironmentsWarehouseTablesRetrieve_0Request) Execute() (*Table, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesRetrieve_289Execute(r)
}

/*
EnvironmentsWarehouseTablesRetrieve_0 Method for EnvironmentsWarehouseTablesRetrieve_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesRetrieve_289(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesRetrieve_0Request {
	return ApiEnvironmentsWarehouseTablesRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesRetrieve_289Execute(r ApiEnvironmentsWarehouseTablesRetrieve_0Request) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesRetrieve_289")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesUpdateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	table *Table
}

func (r ApiEnvironmentsWarehouseTablesUpdateRequest) Table(table Table) ApiEnvironmentsWarehouseTablesUpdateRequest {
	r.table = &table
	return r
}

func (r ApiEnvironmentsWarehouseTablesUpdateRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesUpdateExecute(r)
}

/*
EnvironmentsWarehouseTablesUpdate Method for EnvironmentsWarehouseTablesUpdate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesUpdateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesUpdate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesUpdateRequest {
	return ApiEnvironmentsWarehouseTablesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesUpdateExecute(r ApiEnvironmentsWarehouseTablesUpdateRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return localVarReturnValue, nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesUpdateSchemaCreateRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	table *Table
}

func (r ApiEnvironmentsWarehouseTablesUpdateSchemaCreateRequest) Table(table Table) ApiEnvironmentsWarehouseTablesUpdateSchemaCreateRequest {
	r.table = &table
	return r
}

func (r ApiEnvironmentsWarehouseTablesUpdateSchemaCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesUpdateSchemaCreateExecute(r)
}

/*
EnvironmentsWarehouseTablesUpdateSchemaCreate Method for EnvironmentsWarehouseTablesUpdateSchemaCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesUpdateSchemaCreateRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesUpdateSchemaCreate(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesUpdateSchemaCreateRequest {
	return ApiEnvironmentsWarehouseTablesUpdateSchemaCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesUpdateSchemaCreateExecute(r ApiEnvironmentsWarehouseTablesUpdateSchemaCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesUpdateSchemaCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/update_schema/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesUpdateSchemaCreate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	table *Table
}

func (r ApiEnvironmentsWarehouseTablesUpdateSchemaCreate_0Request) Table(table Table) ApiEnvironmentsWarehouseTablesUpdateSchemaCreate_0Request {
	r.table = &table
	return r
}

func (r ApiEnvironmentsWarehouseTablesUpdateSchemaCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesUpdateSchemaCreate_290Execute(r)
}

/*
EnvironmentsWarehouseTablesUpdateSchemaCreate_0 Method for EnvironmentsWarehouseTablesUpdateSchemaCreate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesUpdateSchemaCreate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesUpdateSchemaCreate_290(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesUpdateSchemaCreate_0Request {
	return ApiEnvironmentsWarehouseTablesUpdateSchemaCreate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesUpdateSchemaCreate_290Execute(r ApiEnvironmentsWarehouseTablesUpdateSchemaCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesUpdateSchemaCreate_290")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/update_schema/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWarehouseTablesUpdate_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	id string
	projectId string
	table *Table
}

func (r ApiEnvironmentsWarehouseTablesUpdate_0Request) Table(table Table) ApiEnvironmentsWarehouseTablesUpdate_0Request {
	r.table = &table
	return r
}

func (r ApiEnvironmentsWarehouseTablesUpdate_0Request) Execute() (*Table, *http.Response, error) {
	return r.ApiService.EnvironmentsWarehouseTablesUpdate_291Execute(r)
}

/*
EnvironmentsWarehouseTablesUpdate_0 Method for EnvironmentsWarehouseTablesUpdate_0

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWarehouseTablesUpdate_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesUpdate_291(ctx context.Context, id string, projectId string) ApiEnvironmentsWarehouseTablesUpdate_0Request {
	return ApiEnvironmentsWarehouseTablesUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *EnvironmentsAPIService) EnvironmentsWarehouseTablesUpdate_291Execute(r ApiEnvironmentsWarehouseTablesUpdate_0Request) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWarehouseTablesUpdate_291")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return localVarReturnValue, nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsWebVitalsRetrieveRequest struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	pathname *string
	projectId string
}

// Filter web vitals by pathname
func (r ApiEnvironmentsWebVitalsRetrieveRequest) Pathname(pathname string) ApiEnvironmentsWebVitalsRetrieveRequest {
	r.pathname = &pathname
	return r
}

func (r ApiEnvironmentsWebVitalsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWebVitalsRetrieveExecute(r)
}

/*
EnvironmentsWebVitalsRetrieve Method for EnvironmentsWebVitalsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWebVitalsRetrieveRequest
*/
func (a *EnvironmentsAPIService) EnvironmentsWebVitalsRetrieve(ctx context.Context, projectId string) ApiEnvironmentsWebVitalsRetrieveRequest {
	return ApiEnvironmentsWebVitalsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWebVitalsRetrieveExecute(r ApiEnvironmentsWebVitalsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWebVitalsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/web_vitals/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pathname == nil {
		return nil, reportError("pathname is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pathname", r.pathname, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsWebVitalsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EnvironmentsAPIService
	pathname *string
	projectId string
}

// Filter web vitals by pathname
func (r ApiEnvironmentsWebVitalsRetrieve_0Request) Pathname(pathname string) ApiEnvironmentsWebVitalsRetrieve_0Request {
	r.pathname = &pathname
	return r
}

func (r ApiEnvironmentsWebVitalsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsWebVitalsRetrieve_292Execute(r)
}

/*
EnvironmentsWebVitalsRetrieve_0 Method for EnvironmentsWebVitalsRetrieve_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsWebVitalsRetrieve_0Request
*/
func (a *EnvironmentsAPIService) EnvironmentsWebVitalsRetrieve_292(ctx context.Context, projectId string) ApiEnvironmentsWebVitalsRetrieve_0Request {
	return ApiEnvironmentsWebVitalsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EnvironmentsAPIService) EnvironmentsWebVitalsRetrieve_292Execute(r ApiEnvironmentsWebVitalsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EnvironmentsAPIService.EnvironmentsWebVitalsRetrieve_292")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/web_vitals/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.pathname == nil {
		return nil, reportError("pathname is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "pathname", r.pathname, "form", "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

/*
PostHog API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package posthogapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// EndpointsAPIService EndpointsAPI service
type EndpointsAPIService service

type ApiEndpointsCreateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
	endpointRequest *EndpointRequest
}

func (r ApiEndpointsCreateRequest) EndpointRequest(endpointRequest EndpointRequest) ApiEndpointsCreateRequest {
	r.endpointRequest = &endpointRequest
	return r
}

func (r ApiEndpointsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsCreateExecute(r)
}

/*
EndpointsCreate Method for EndpointsCreate

Create a new endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsCreateRequest
*/
func (a *EndpointsAPIService) EndpointsCreate(ctx context.Context, projectId string) ApiEndpointsCreateRequest {
	return ApiEndpointsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsCreateExecute(r ApiEndpointsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsCreate_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
	endpointRequest *EndpointRequest
}

func (r ApiEndpointsCreate_0Request) EndpointRequest(endpointRequest EndpointRequest) ApiEndpointsCreate_0Request {
	r.endpointRequest = &endpointRequest
	return r
}

func (r ApiEndpointsCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsCreate_1Execute(r)
}

/*
EndpointsCreate_0 Method for EndpointsCreate_0

Create a new endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsCreate_0Request
*/
func (a *EndpointsAPIService) EndpointsCreate_1(ctx context.Context, projectId string) ApiEndpointsCreate_0Request {
	return ApiEndpointsCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsCreate_1Execute(r ApiEndpointsCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsCreate_1")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsDestroyRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsDestroyExecute(r)
}

/*
EndpointsDestroy Method for EndpointsDestroy

Delete an endpoint and clean up materialized query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsDestroyRequest
*/
func (a *EndpointsAPIService) EndpointsDestroy(ctx context.Context, name string, projectId string) ApiEndpointsDestroyRequest {
	return ApiEndpointsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsDestroyExecute(r ApiEndpointsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsDestroy_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsDestroy_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsDestroy_2Execute(r)
}

/*
EndpointsDestroy_0 Method for EndpointsDestroy_0

Delete an endpoint and clean up materialized query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsDestroy_0Request
*/
func (a *EndpointsAPIService) EndpointsDestroy_2(ctx context.Context, name string, projectId string) ApiEndpointsDestroy_0Request {
	return ApiEndpointsDestroy_0Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsDestroy_2Execute(r ApiEndpointsDestroy_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsDestroy_2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsLastExecutionTimesCreateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
	endpointLastExecutionTimesRequest *EndpointLastExecutionTimesRequest
}

func (r ApiEndpointsLastExecutionTimesCreateRequest) EndpointLastExecutionTimesRequest(endpointLastExecutionTimesRequest EndpointLastExecutionTimesRequest) ApiEndpointsLastExecutionTimesCreateRequest {
	r.endpointLastExecutionTimesRequest = &endpointLastExecutionTimesRequest
	return r
}

func (r ApiEndpointsLastExecutionTimesCreateRequest) Execute() (*QueryStatusResponse, *http.Response, error) {
	return r.ApiService.EndpointsLastExecutionTimesCreateExecute(r)
}

/*
EndpointsLastExecutionTimesCreate Method for EndpointsLastExecutionTimesCreate

Get the last execution times in the past 6 months for multiple endpoints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsLastExecutionTimesCreateRequest
*/
func (a *EndpointsAPIService) EndpointsLastExecutionTimesCreate(ctx context.Context, projectId string) ApiEndpointsLastExecutionTimesCreateRequest {
	return ApiEndpointsLastExecutionTimesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryStatusResponse
func (a *EndpointsAPIService) EndpointsLastExecutionTimesCreateExecute(r ApiEndpointsLastExecutionTimesCreateRequest) (*QueryStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsLastExecutionTimesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/last_execution_times/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointLastExecutionTimesRequest == nil {
		return localVarReturnValue, nil, reportError("endpointLastExecutionTimesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointLastExecutionTimesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsLastExecutionTimesCreate_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
	endpointLastExecutionTimesRequest *EndpointLastExecutionTimesRequest
}

func (r ApiEndpointsLastExecutionTimesCreate_0Request) EndpointLastExecutionTimesRequest(endpointLastExecutionTimesRequest EndpointLastExecutionTimesRequest) ApiEndpointsLastExecutionTimesCreate_0Request {
	r.endpointLastExecutionTimesRequest = &endpointLastExecutionTimesRequest
	return r
}

func (r ApiEndpointsLastExecutionTimesCreate_0Request) Execute() (*QueryStatusResponse, *http.Response, error) {
	return r.ApiService.EndpointsLastExecutionTimesCreate_3Execute(r)
}

/*
EndpointsLastExecutionTimesCreate_0 Method for EndpointsLastExecutionTimesCreate_0

Get the last execution times in the past 6 months for multiple endpoints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsLastExecutionTimesCreate_0Request
*/
func (a *EndpointsAPIService) EndpointsLastExecutionTimesCreate_3(ctx context.Context, projectId string) ApiEndpointsLastExecutionTimesCreate_0Request {
	return ApiEndpointsLastExecutionTimesCreate_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryStatusResponse
func (a *EndpointsAPIService) EndpointsLastExecutionTimesCreate_3Execute(r ApiEndpointsLastExecutionTimesCreate_0Request) (*QueryStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsLastExecutionTimesCreate_3")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/last_execution_times/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointLastExecutionTimesRequest == nil {
		return localVarReturnValue, nil, reportError("endpointLastExecutionTimesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointLastExecutionTimesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEndpointsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsPartialUpdateExecute(r)
}

/*
EndpointsPartialUpdate Method for EndpointsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsPartialUpdateRequest
*/
func (a *EndpointsAPIService) EndpointsPartialUpdate(ctx context.Context, name string, projectId string) ApiEndpointsPartialUpdateRequest {
	return ApiEndpointsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsPartialUpdateExecute(r ApiEndpointsPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsPartialUpdate_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsPartialUpdate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsPartialUpdate_4Execute(r)
}

/*
EndpointsPartialUpdate_0 Method for EndpointsPartialUpdate_0

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsPartialUpdate_0Request
*/
func (a *EndpointsAPIService) EndpointsPartialUpdate_4(ctx context.Context, name string, projectId string) ApiEndpointsPartialUpdate_0Request {
	return ApiEndpointsPartialUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsPartialUpdate_4Execute(r ApiEndpointsPartialUpdate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsPartialUpdate_4")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsRetrieveRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
}

func (r ApiEndpointsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsRetrieveExecute(r)
}

/*
EndpointsRetrieve Method for EndpointsRetrieve

List all endpoints for the team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsRetrieveRequest
*/
func (a *EndpointsAPIService) EndpointsRetrieve(ctx context.Context, projectId string) ApiEndpointsRetrieveRequest {
	return ApiEndpointsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsRetrieveExecute(r ApiEndpointsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsRetrieve2Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsRetrieve2Execute(r)
}

/*
EndpointsRetrieve2 Method for EndpointsRetrieve2

Retrieve an endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsRetrieve2Request
*/
func (a *EndpointsAPIService) EndpointsRetrieve2(ctx context.Context, name string, projectId string) ApiEndpointsRetrieve2Request {
	return ApiEndpointsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsRetrieve2Execute(r ApiEndpointsRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsRetrieve2_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsRetrieve2_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsRetrieve2_5Execute(r)
}

/*
EndpointsRetrieve2_0 Method for EndpointsRetrieve2_0

Retrieve an endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsRetrieve2_0Request
*/
func (a *EndpointsAPIService) EndpointsRetrieve2_5(ctx context.Context, name string, projectId string) ApiEndpointsRetrieve2_0Request {
	return ApiEndpointsRetrieve2_0Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsRetrieve2_5Execute(r ApiEndpointsRetrieve2_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsRetrieve2_5")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
}

func (r ApiEndpointsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsRetrieve_6Execute(r)
}

/*
EndpointsRetrieve_0 Method for EndpointsRetrieve_0

List all endpoints for the team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsRetrieve_0Request
*/
func (a *EndpointsAPIService) EndpointsRetrieve_6(ctx context.Context, projectId string) ApiEndpointsRetrieve_0Request {
	return ApiEndpointsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsRetrieve_6Execute(r ApiEndpointsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsRetrieve_6")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsRunCreateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	endpointRunRequest *EndpointRunRequest
}

func (r ApiEndpointsRunCreateRequest) EndpointRunRequest(endpointRunRequest EndpointRunRequest) ApiEndpointsRunCreateRequest {
	r.endpointRunRequest = &endpointRunRequest
	return r
}

func (r ApiEndpointsRunCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsRunCreateExecute(r)
}

/*
EndpointsRunCreate Method for EndpointsRunCreate

Execute endpoint with optional materialization. Supports version parameter, runs latest version if not set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsRunCreateRequest
*/
func (a *EndpointsAPIService) EndpointsRunCreate(ctx context.Context, name string, projectId string) ApiEndpointsRunCreateRequest {
	return ApiEndpointsRunCreateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsRunCreateExecute(r ApiEndpointsRunCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsRunCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsRunCreate_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	endpointRunRequest *EndpointRunRequest
}

func (r ApiEndpointsRunCreate_0Request) EndpointRunRequest(endpointRunRequest EndpointRunRequest) ApiEndpointsRunCreate_0Request {
	r.endpointRunRequest = &endpointRunRequest
	return r
}

func (r ApiEndpointsRunCreate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsRunCreate_7Execute(r)
}

/*
EndpointsRunCreate_0 Method for EndpointsRunCreate_0

Execute endpoint with optional materialization. Supports version parameter, runs latest version if not set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsRunCreate_0Request
*/
func (a *EndpointsAPIService) EndpointsRunCreate_7(ctx context.Context, name string, projectId string) ApiEndpointsRunCreate_0Request {
	return ApiEndpointsRunCreate_0Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsRunCreate_7Execute(r ApiEndpointsRunCreate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsRunCreate_7")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsRunRetrieveRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsRunRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsRunRetrieveExecute(r)
}

/*
EndpointsRunRetrieve Method for EndpointsRunRetrieve

Execute endpoint with optional materialization. Supports version parameter, runs latest version if not set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsRunRetrieveRequest
*/
func (a *EndpointsAPIService) EndpointsRunRetrieve(ctx context.Context, name string, projectId string) ApiEndpointsRunRetrieveRequest {
	return ApiEndpointsRunRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsRunRetrieveExecute(r ApiEndpointsRunRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsRunRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsRunRetrieve_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsRunRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsRunRetrieve_8Execute(r)
}

/*
EndpointsRunRetrieve_0 Method for EndpointsRunRetrieve_0

Execute endpoint with optional materialization. Supports version parameter, runs latest version if not set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsRunRetrieve_0Request
*/
func (a *EndpointsAPIService) EndpointsRunRetrieve_8(ctx context.Context, name string, projectId string) ApiEndpointsRunRetrieve_0Request {
	return ApiEndpointsRunRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsRunRetrieve_8Execute(r ApiEndpointsRunRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsRunRetrieve_8")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsUpdateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	endpointRequest *EndpointRequest
}

func (r ApiEndpointsUpdateRequest) EndpointRequest(endpointRequest EndpointRequest) ApiEndpointsUpdateRequest {
	r.endpointRequest = &endpointRequest
	return r
}

func (r ApiEndpointsUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsUpdateExecute(r)
}

/*
EndpointsUpdate Method for EndpointsUpdate

Update an existing endpoint. Parameters are optional.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsUpdateRequest
*/
func (a *EndpointsAPIService) EndpointsUpdate(ctx context.Context, name string, projectId string) ApiEndpointsUpdateRequest {
	return ApiEndpointsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsUpdateExecute(r ApiEndpointsUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsUpdate_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	endpointRequest *EndpointRequest
}

func (r ApiEndpointsUpdate_0Request) EndpointRequest(endpointRequest EndpointRequest) ApiEndpointsUpdate_0Request {
	r.endpointRequest = &endpointRequest
	return r
}

func (r ApiEndpointsUpdate_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsUpdate_9Execute(r)
}

/*
EndpointsUpdate_0 Method for EndpointsUpdate_0

Update an existing endpoint. Parameters are optional.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsUpdate_0Request
*/
func (a *EndpointsAPIService) EndpointsUpdate_9(ctx context.Context, name string, projectId string) ApiEndpointsUpdate_0Request {
	return ApiEndpointsUpdate_0Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsUpdate_9Execute(r ApiEndpointsUpdate_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsUpdate_9")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsVersionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsVersionsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsVersionsRetrieveExecute(r)
}

/*
EndpointsVersionsRetrieve Method for EndpointsVersionsRetrieve

List all versions for an endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsVersionsRetrieveRequest
*/
func (a *EndpointsAPIService) EndpointsVersionsRetrieve(ctx context.Context, name string, projectId string) ApiEndpointsVersionsRetrieveRequest {
	return ApiEndpointsVersionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsVersionsRetrieveExecute(r ApiEndpointsVersionsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsVersionsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/versions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsVersionsRetrieve2Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	versionNumber string
}

func (r ApiEndpointsVersionsRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsVersionsRetrieve2Execute(r)
}

/*
EndpointsVersionsRetrieve2 Method for EndpointsVersionsRetrieve2

Get details of a specific endpoint version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param versionNumber
 @return ApiEndpointsVersionsRetrieve2Request
*/
func (a *EndpointsAPIService) EndpointsVersionsRetrieve2(ctx context.Context, name string, projectId string, versionNumber string) ApiEndpointsVersionsRetrieve2Request {
	return ApiEndpointsVersionsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsVersionsRetrieve2Execute(r ApiEndpointsVersionsRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsVersionsRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/versions/{version_number}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version_number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsVersionsRetrieve2_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	versionNumber string
}

func (r ApiEndpointsVersionsRetrieve2_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsVersionsRetrieve2_10Execute(r)
}

/*
EndpointsVersionsRetrieve2_0 Method for EndpointsVersionsRetrieve2_0

Get details of a specific endpoint version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param versionNumber
 @return ApiEndpointsVersionsRetrieve2_0Request
*/
func (a *EndpointsAPIService) EndpointsVersionsRetrieve2_10(ctx context.Context, name string, projectId string, versionNumber string) ApiEndpointsVersionsRetrieve2_0Request {
	return ApiEndpointsVersionsRetrieve2_0Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsVersionsRetrieve2_10Execute(r ApiEndpointsVersionsRetrieve2_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsVersionsRetrieve2_10")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/versions/{version_number}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version_number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEndpointsVersionsRetrieve_0Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEndpointsVersionsRetrieve_0Request) Execute() (*http.Response, error) {
	return r.ApiService.EndpointsVersionsRetrieve_11Execute(r)
}

/*
EndpointsVersionsRetrieve_0 Method for EndpointsVersionsRetrieve_0

List all versions for an endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEndpointsVersionsRetrieve_0Request
*/
func (a *EndpointsAPIService) EndpointsVersionsRetrieve_11(ctx context.Context, name string, projectId string) ApiEndpointsVersionsRetrieve_0Request {
	return ApiEndpointsVersionsRetrieve_0Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EndpointsVersionsRetrieve_11Execute(r ApiEndpointsVersionsRetrieve_0Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EndpointsVersionsRetrieve_11")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/endpoints/{name}/versions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsCreateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
	endpointRequest *EndpointRequest
}

func (r ApiEnvironmentsEndpointsCreateRequest) EndpointRequest(endpointRequest EndpointRequest) ApiEnvironmentsEndpointsCreateRequest {
	r.endpointRequest = &endpointRequest
	return r
}

func (r ApiEnvironmentsEndpointsCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsCreateExecute(r)
}

/*
EnvironmentsEndpointsCreate Method for EnvironmentsEndpointsCreate

Create a new endpoint

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsCreateRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsCreate(ctx context.Context, projectId string) ApiEnvironmentsEndpointsCreateRequest {
	return ApiEnvironmentsEndpointsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsCreateExecute(r ApiEnvironmentsEndpointsCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsDestroyRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsDestroyExecute(r)
}

/*
EnvironmentsEndpointsDestroy Method for EnvironmentsEndpointsDestroy

Delete an endpoint and clean up materialized query.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsDestroyRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsDestroy(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsDestroyRequest {
	return ApiEnvironmentsEndpointsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsDestroyExecute(r ApiEnvironmentsEndpointsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
	endpointLastExecutionTimesRequest *EndpointLastExecutionTimesRequest
}

func (r ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest) EndpointLastExecutionTimesRequest(endpointLastExecutionTimesRequest EndpointLastExecutionTimesRequest) ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest {
	r.endpointLastExecutionTimesRequest = &endpointLastExecutionTimesRequest
	return r
}

func (r ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest) Execute() (*QueryStatusResponse, *http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsLastExecutionTimesCreateExecute(r)
}

/*
EnvironmentsEndpointsLastExecutionTimesCreate Method for EnvironmentsEndpointsLastExecutionTimesCreate

Get the last execution times in the past 6 months for multiple endpoints.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsLastExecutionTimesCreate(ctx context.Context, projectId string) ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest {
	return ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return QueryStatusResponse
func (a *EndpointsAPIService) EnvironmentsEndpointsLastExecutionTimesCreateExecute(r ApiEnvironmentsEndpointsLastExecutionTimesCreateRequest) (*QueryStatusResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *QueryStatusResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsLastExecutionTimesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/last_execution_times/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.endpointLastExecutionTimesRequest == nil {
		return localVarReturnValue, nil, reportError("endpointLastExecutionTimesRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointLastExecutionTimesRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsPartialUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsPartialUpdateExecute(r)
}

/*
EnvironmentsEndpointsPartialUpdate Method for EnvironmentsEndpointsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsPartialUpdateRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsPartialUpdate(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsPartialUpdateRequest {
	return ApiEnvironmentsEndpointsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsPartialUpdateExecute(r ApiEnvironmentsEndpointsPartialUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsPartialUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsRetrieveRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	projectId string
}

func (r ApiEnvironmentsEndpointsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsRetrieveExecute(r)
}

/*
EnvironmentsEndpointsRetrieve Method for EnvironmentsEndpointsRetrieve

List all endpoints for the team.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsRetrieveRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsRetrieve(ctx context.Context, projectId string) ApiEnvironmentsEndpointsRetrieveRequest {
	return ApiEnvironmentsEndpointsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsRetrieveExecute(r ApiEnvironmentsEndpointsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsRetrieve2Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsRetrieve2Execute(r)
}

/*
EnvironmentsEndpointsRetrieve2 Method for EnvironmentsEndpointsRetrieve2

Retrieve an endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsRetrieve2Request
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsRetrieve2(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsRetrieve2Request {
	return ApiEnvironmentsEndpointsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsRetrieve2Execute(r ApiEnvironmentsEndpointsRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsRunCreateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	endpointRunRequest *EndpointRunRequest
}

func (r ApiEnvironmentsEndpointsRunCreateRequest) EndpointRunRequest(endpointRunRequest EndpointRunRequest) ApiEnvironmentsEndpointsRunCreateRequest {
	r.endpointRunRequest = &endpointRunRequest
	return r
}

func (r ApiEnvironmentsEndpointsRunCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsRunCreateExecute(r)
}

/*
EnvironmentsEndpointsRunCreate Method for EnvironmentsEndpointsRunCreate

Execute endpoint with optional materialization. Supports version parameter, runs latest version if not set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsRunCreateRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsRunCreate(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsRunCreateRequest {
	return ApiEnvironmentsEndpointsRunCreateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsRunCreateExecute(r ApiEnvironmentsEndpointsRunCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsRunCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRunRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsRunRetrieveRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsRunRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsRunRetrieveExecute(r)
}

/*
EnvironmentsEndpointsRunRetrieve Method for EnvironmentsEndpointsRunRetrieve

Execute endpoint with optional materialization. Supports version parameter, runs latest version if not set.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsRunRetrieveRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsRunRetrieve(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsRunRetrieveRequest {
	return ApiEnvironmentsEndpointsRunRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsRunRetrieveExecute(r ApiEnvironmentsEndpointsRunRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsRunRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/run/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsUpdateRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	endpointRequest *EndpointRequest
}

func (r ApiEnvironmentsEndpointsUpdateRequest) EndpointRequest(endpointRequest EndpointRequest) ApiEnvironmentsEndpointsUpdateRequest {
	r.endpointRequest = &endpointRequest
	return r
}

func (r ApiEnvironmentsEndpointsUpdateRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsUpdateExecute(r)
}

/*
EnvironmentsEndpointsUpdate Method for EnvironmentsEndpointsUpdate

Update an existing endpoint. Parameters are optional.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsUpdateRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsUpdate(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsUpdateRequest {
	return ApiEnvironmentsEndpointsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsUpdateExecute(r ApiEnvironmentsEndpointsUpdateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsUpdate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.endpointRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsVersionsRetrieveRequest struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
}

func (r ApiEnvironmentsEndpointsVersionsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsVersionsRetrieveExecute(r)
}

/*
EnvironmentsEndpointsVersionsRetrieve Method for EnvironmentsEndpointsVersionsRetrieve

List all versions for an endpoint.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiEnvironmentsEndpointsVersionsRetrieveRequest
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsVersionsRetrieve(ctx context.Context, name string, projectId string) ApiEnvironmentsEndpointsVersionsRetrieveRequest {
	return ApiEnvironmentsEndpointsVersionsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsVersionsRetrieveExecute(r ApiEnvironmentsEndpointsVersionsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsVersionsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/versions/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiEnvironmentsEndpointsVersionsRetrieve2Request struct {
	ctx context.Context
	ApiService *EndpointsAPIService
	name string
	projectId string
	versionNumber string
}

func (r ApiEnvironmentsEndpointsVersionsRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.EnvironmentsEndpointsVersionsRetrieve2Execute(r)
}

/*
EnvironmentsEndpointsVersionsRetrieve2 Method for EnvironmentsEndpointsVersionsRetrieve2

Get details of a specific endpoint version.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param name
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @param versionNumber
 @return ApiEnvironmentsEndpointsVersionsRetrieve2Request
*/
func (a *EndpointsAPIService) EnvironmentsEndpointsVersionsRetrieve2(ctx context.Context, name string, projectId string, versionNumber string) ApiEnvironmentsEndpointsVersionsRetrieve2Request {
	return ApiEnvironmentsEndpointsVersionsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		name: name,
		projectId: projectId,
		versionNumber: versionNumber,
	}
}

// Execute executes the request
func (a *EndpointsAPIService) EnvironmentsEndpointsVersionsRetrieve2Execute(r ApiEnvironmentsEndpointsVersionsRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "EndpointsAPIService.EnvironmentsEndpointsVersionsRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/environments/{project_id}/endpoints/{name}/versions/{version_number}/"
	localVarPath = strings.Replace(localVarPath, "{"+"name"+"}", url.PathEscape(parameterValueToString(r.name, "name")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"version_number"+"}", url.PathEscape(parameterValueToString(r.versionNumber, "versionNumber")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

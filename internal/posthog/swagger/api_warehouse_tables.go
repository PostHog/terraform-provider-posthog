/*
PostHog API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package posthogapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"
)


// WarehouseTablesAPIService WarehouseTablesAPI service
type WarehouseTablesAPIService service

type ApiWarehouseTablesCreateRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	projectId string
	table *Table
}

func (r ApiWarehouseTablesCreateRequest) Table(table Table) ApiWarehouseTablesCreateRequest {
	r.table = &table
	return r
}

func (r ApiWarehouseTablesCreateRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.WarehouseTablesCreateExecute(r)
}

/*
WarehouseTablesCreate Method for WarehouseTablesCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesCreateRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesCreate(ctx context.Context, projectId string) ApiWarehouseTablesCreateRequest {
	return ApiWarehouseTablesCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *WarehouseTablesAPIService) WarehouseTablesCreateExecute(r ApiWarehouseTablesCreateRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return localVarReturnValue, nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWarehouseTablesDestroyRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	id string
	projectId string
}

func (r ApiWarehouseTablesDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.WarehouseTablesDestroyExecute(r)
}

/*
WarehouseTablesDestroy Method for WarehouseTablesDestroy

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesDestroyRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesDestroy(ctx context.Context, id string, projectId string) ApiWarehouseTablesDestroyRequest {
	return ApiWarehouseTablesDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *WarehouseTablesAPIService) WarehouseTablesDestroyExecute(r ApiWarehouseTablesDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWarehouseTablesFileCreateRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	projectId string
	id *string
	name *string
	format *TableFormatEnum
	createdBy *UserBasic
	createdAt *time.Time
	urlPattern *string
	credential *Credential
	columns *string
	externalDataSource *SimpleExternalDataSourceSerializers
	externalSchema *string
	deleted *bool
}

func (r ApiWarehouseTablesFileCreateRequest) Id(id string) ApiWarehouseTablesFileCreateRequest {
	r.id = &id
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) Name(name string) ApiWarehouseTablesFileCreateRequest {
	r.name = &name
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) Format(format TableFormatEnum) ApiWarehouseTablesFileCreateRequest {
	r.format = &format
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) CreatedBy(createdBy UserBasic) ApiWarehouseTablesFileCreateRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) CreatedAt(createdAt time.Time) ApiWarehouseTablesFileCreateRequest {
	r.createdAt = &createdAt
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) UrlPattern(urlPattern string) ApiWarehouseTablesFileCreateRequest {
	r.urlPattern = &urlPattern
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) Credential(credential Credential) ApiWarehouseTablesFileCreateRequest {
	r.credential = &credential
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) Columns(columns string) ApiWarehouseTablesFileCreateRequest {
	r.columns = &columns
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) ExternalDataSource(externalDataSource SimpleExternalDataSourceSerializers) ApiWarehouseTablesFileCreateRequest {
	r.externalDataSource = &externalDataSource
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) ExternalSchema(externalSchema string) ApiWarehouseTablesFileCreateRequest {
	r.externalSchema = &externalSchema
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) Deleted(deleted bool) ApiWarehouseTablesFileCreateRequest {
	r.deleted = &deleted
	return r
}

func (r ApiWarehouseTablesFileCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.WarehouseTablesFileCreateExecute(r)
}

/*
WarehouseTablesFileCreate Method for WarehouseTablesFileCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesFileCreateRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesFileCreate(ctx context.Context, projectId string) ApiWarehouseTablesFileCreateRequest {
	return ApiWarehouseTablesFileCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *WarehouseTablesAPIService) WarehouseTablesFileCreateExecute(r ApiWarehouseTablesFileCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesFileCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/file/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.id == nil {
		return nil, reportError("id is required and must be specified")
	}
	if r.name == nil {
		return nil, reportError("name is required and must be specified")
	}
	if strlen(*r.name) > 128 {
		return nil, reportError("name must have less than 128 elements")
	}
	if r.format == nil {
		return nil, reportError("format is required and must be specified")
	}
	if r.createdBy == nil {
		return nil, reportError("createdBy is required and must be specified")
	}
	if r.createdAt == nil {
		return nil, reportError("createdAt is required and must be specified")
	}
	if r.urlPattern == nil {
		return nil, reportError("urlPattern is required and must be specified")
	}
	if strlen(*r.urlPattern) > 500 {
		return nil, reportError("urlPattern must have less than 500 elements")
	}
	if r.credential == nil {
		return nil, reportError("credential is required and must be specified")
	}
	if r.columns == nil {
		return nil, reportError("columns is required and must be specified")
	}
	if r.externalDataSource == nil {
		return nil, reportError("externalDataSource is required and must be specified")
	}
	if r.externalSchema == nil {
		return nil, reportError("externalSchema is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"multipart/form-data", "application/x-www-form-urlencoded"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "id", r.id, "", "")
	if r.deleted != nil {
		parameterAddToHeaderOrQuery(localVarFormParams, "deleted", r.deleted, "", "")
	}
	parameterAddToHeaderOrQuery(localVarFormParams, "name", r.name, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "format", r.format, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_by", r.createdBy, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "created_at", r.createdAt, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "url_pattern", r.urlPattern, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "credential", r.credential, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "columns", r.columns, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "external_data_source", r.externalDataSource, "", "")
	parameterAddToHeaderOrQuery(localVarFormParams, "external_schema", r.externalSchema, "", "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWarehouseTablesListRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	projectId string
	limit *int32
	offset *int32
	search *string
}

// Number of results to return per page.
func (r ApiWarehouseTablesListRequest) Limit(limit int32) ApiWarehouseTablesListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiWarehouseTablesListRequest) Offset(offset int32) ApiWarehouseTablesListRequest {
	r.offset = &offset
	return r
}

// A search term.
func (r ApiWarehouseTablesListRequest) Search(search string) ApiWarehouseTablesListRequest {
	r.search = &search
	return r
}

func (r ApiWarehouseTablesListRequest) Execute() (*PaginatedTableList, *http.Response, error) {
	return r.ApiService.WarehouseTablesListExecute(r)
}

/*
WarehouseTablesList Method for WarehouseTablesList

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesListRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesList(ctx context.Context, projectId string) ApiWarehouseTablesListRequest {
	return ApiWarehouseTablesListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedTableList
func (a *WarehouseTablesAPIService) WarehouseTablesListExecute(r ApiWarehouseTablesListRequest) (*PaginatedTableList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedTableList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWarehouseTablesPartialUpdateRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	id string
	projectId string
	patchedTable *PatchedTable
}

func (r ApiWarehouseTablesPartialUpdateRequest) PatchedTable(patchedTable PatchedTable) ApiWarehouseTablesPartialUpdateRequest {
	r.patchedTable = &patchedTable
	return r
}

func (r ApiWarehouseTablesPartialUpdateRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.WarehouseTablesPartialUpdateExecute(r)
}

/*
WarehouseTablesPartialUpdate Method for WarehouseTablesPartialUpdate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesPartialUpdateRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesPartialUpdate(ctx context.Context, id string, projectId string) ApiWarehouseTablesPartialUpdateRequest {
	return ApiWarehouseTablesPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *WarehouseTablesAPIService) WarehouseTablesPartialUpdateExecute(r ApiWarehouseTablesPartialUpdateRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedTable
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWarehouseTablesRefreshSchemaCreateRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	id string
	projectId string
	table *Table
}

func (r ApiWarehouseTablesRefreshSchemaCreateRequest) Table(table Table) ApiWarehouseTablesRefreshSchemaCreateRequest {
	r.table = &table
	return r
}

func (r ApiWarehouseTablesRefreshSchemaCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.WarehouseTablesRefreshSchemaCreateExecute(r)
}

/*
WarehouseTablesRefreshSchemaCreate Method for WarehouseTablesRefreshSchemaCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesRefreshSchemaCreateRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesRefreshSchemaCreate(ctx context.Context, id string, projectId string) ApiWarehouseTablesRefreshSchemaCreateRequest {
	return ApiWarehouseTablesRefreshSchemaCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *WarehouseTablesAPIService) WarehouseTablesRefreshSchemaCreateExecute(r ApiWarehouseTablesRefreshSchemaCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesRefreshSchemaCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/{id}/refresh_schema/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiWarehouseTablesRetrieveRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	id string
	projectId string
}

func (r ApiWarehouseTablesRetrieveRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.WarehouseTablesRetrieveExecute(r)
}

/*
WarehouseTablesRetrieve Method for WarehouseTablesRetrieve

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesRetrieveRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesRetrieve(ctx context.Context, id string, projectId string) ApiWarehouseTablesRetrieveRequest {
	return ApiWarehouseTablesRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *WarehouseTablesAPIService) WarehouseTablesRetrieveExecute(r ApiWarehouseTablesRetrieveRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWarehouseTablesUpdateRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	id string
	projectId string
	table *Table
}

func (r ApiWarehouseTablesUpdateRequest) Table(table Table) ApiWarehouseTablesUpdateRequest {
	r.table = &table
	return r
}

func (r ApiWarehouseTablesUpdateRequest) Execute() (*Table, *http.Response, error) {
	return r.ApiService.WarehouseTablesUpdateExecute(r)
}

/*
WarehouseTablesUpdate Method for WarehouseTablesUpdate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesUpdateRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesUpdate(ctx context.Context, id string, projectId string) ApiWarehouseTablesUpdateRequest {
	return ApiWarehouseTablesUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Table
func (a *WarehouseTablesAPIService) WarehouseTablesUpdateExecute(r ApiWarehouseTablesUpdateRequest) (*Table, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Table
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return localVarReturnValue, nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWarehouseTablesUpdateSchemaCreateRequest struct {
	ctx context.Context
	ApiService *WarehouseTablesAPIService
	id string
	projectId string
	table *Table
}

func (r ApiWarehouseTablesUpdateSchemaCreateRequest) Table(table Table) ApiWarehouseTablesUpdateSchemaCreateRequest {
	r.table = &table
	return r
}

func (r ApiWarehouseTablesUpdateSchemaCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.WarehouseTablesUpdateSchemaCreateExecute(r)
}

/*
WarehouseTablesUpdateSchemaCreate Method for WarehouseTablesUpdateSchemaCreate

Create, Read, Update and Delete Warehouse Tables.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this data warehouse table.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWarehouseTablesUpdateSchemaCreateRequest
*/
func (a *WarehouseTablesAPIService) WarehouseTablesUpdateSchemaCreate(ctx context.Context, id string, projectId string) ApiWarehouseTablesUpdateSchemaCreateRequest {
	return ApiWarehouseTablesUpdateSchemaCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *WarehouseTablesAPIService) WarehouseTablesUpdateSchemaCreateExecute(r ApiWarehouseTablesUpdateSchemaCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WarehouseTablesAPIService.WarehouseTablesUpdateSchemaCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/warehouse_tables/{id}/update_schema/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.table == nil {
		return nil, reportError("table is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.table
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

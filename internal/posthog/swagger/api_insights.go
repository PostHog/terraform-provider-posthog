/*
PostHog API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package posthogapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// InsightsAPIService InsightsAPI service
type InsightsAPIService service

type ApiInsightsActivityRetrieveRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	projectId string
	format *string
}

func (r ApiInsightsActivityRetrieveRequest) Format(format string) ApiInsightsActivityRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiInsightsActivityRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.InsightsActivityRetrieveExecute(r)
}

/*
InsightsActivityRetrieve Method for InsightsActivityRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsActivityRetrieveRequest
*/
func (a *InsightsAPIService) InsightsActivityRetrieve(ctx context.Context, projectId string) ApiInsightsActivityRetrieveRequest {
	return ApiInsightsActivityRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *InsightsAPIService) InsightsActivityRetrieveExecute(r ApiInsightsActivityRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsActivityRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInsightsActivityRetrieve2Request struct {
	ctx context.Context
	ApiService *InsightsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiInsightsActivityRetrieve2Request) Format(format string) ApiInsightsActivityRetrieve2Request {
	r.format = &format
	return r
}

func (r ApiInsightsActivityRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.InsightsActivityRetrieve2Execute(r)
}

/*
InsightsActivityRetrieve2 Method for InsightsActivityRetrieve2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsActivityRetrieve2Request
*/
func (a *InsightsAPIService) InsightsActivityRetrieve2(ctx context.Context, id int32, projectId string) ApiInsightsActivityRetrieve2Request {
	return ApiInsightsActivityRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *InsightsAPIService) InsightsActivityRetrieve2Execute(r ApiInsightsActivityRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsActivityRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{id}/activity/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInsightsCancelCreateRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiInsightsCancelCreateRequest) Format(format string) ApiInsightsCancelCreateRequest {
	r.format = &format
	return r
}

func (r ApiInsightsCancelCreateRequest) Insight(insight Insight) ApiInsightsCancelCreateRequest {
	r.insight = &insight
	return r
}

func (r ApiInsightsCancelCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.InsightsCancelCreateExecute(r)
}

/*
InsightsCancelCreate Method for InsightsCancelCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsCancelCreateRequest
*/
func (a *InsightsAPIService) InsightsCancelCreate(ctx context.Context, projectId string) ApiInsightsCancelCreateRequest {
	return ApiInsightsCancelCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *InsightsAPIService) InsightsCancelCreateExecute(r ApiInsightsCancelCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsCancelCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInsightsCreateRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiInsightsCreateRequest) Format(format string) ApiInsightsCreateRequest {
	r.format = &format
	return r
}

func (r ApiInsightsCreateRequest) Insight(insight Insight) ApiInsightsCreateRequest {
	r.insight = &insight
	return r
}

func (r ApiInsightsCreateRequest) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.InsightsCreateExecute(r)
}

/*
InsightsCreate Method for InsightsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsCreateRequest
*/
func (a *InsightsAPIService) InsightsCreate(ctx context.Context, projectId string) ApiInsightsCreateRequest {
	return ApiInsightsCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *InsightsAPIService) InsightsCreateExecute(r ApiInsightsCreateRequest) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightsDestroyRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	id int32
	projectId string
	format *string
}

func (r ApiInsightsDestroyRequest) Format(format string) ApiInsightsDestroyRequest {
	r.format = &format
	return r
}

func (r ApiInsightsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.InsightsDestroyExecute(r)
}

/*
InsightsDestroy Method for InsightsDestroy

Hard delete of this model is not allowed. Use a patch API call to set "deleted" to true

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsDestroyRequest
*/
func (a *InsightsAPIService) InsightsDestroy(ctx context.Context, id int32, projectId string) ApiInsightsDestroyRequest {
	return ApiInsightsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *InsightsAPIService) InsightsDestroyExecute(r ApiInsightsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInsightsListRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	projectId string
	basic *bool
	createdBy *int32
	format *string
	limit *int32
	offset *int32
	refresh *string
	shortId *string
}

// Return basic insight metadata only (no results, faster).
func (r ApiInsightsListRequest) Basic(basic bool) ApiInsightsListRequest {
	r.basic = &basic
	return r
}

func (r ApiInsightsListRequest) CreatedBy(createdBy int32) ApiInsightsListRequest {
	r.createdBy = &createdBy
	return r
}

func (r ApiInsightsListRequest) Format(format string) ApiInsightsListRequest {
	r.format = &format
	return r
}

// Number of results to return per page.
func (r ApiInsightsListRequest) Limit(limit int32) ApiInsightsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiInsightsListRequest) Offset(offset int32) ApiInsightsListRequest {
	r.offset = &offset
	return r
}

//  Whether to refresh the retrieved insights, how aggresively, and if sync or async: - &#x60;&#39;force_cache&#39;&#x60; - return cached data or a cache miss; always completes immediately as it never calculates - &#x60;&#39;blocking&#39;&#x60; - calculate synchronously (returning only when the query is done), UNLESS there are very fresh results in the cache - &#x60;&#39;async&#39;&#x60; - kick off background calculation (returning immediately with a query status), UNLESS there are very fresh results in the cache - &#x60;&#39;lazy_async&#39;&#x60; - kick off background calculation, UNLESS there are somewhat fresh results in the cache - &#x60;&#39;force_blocking&#39;&#x60; - calculate synchronously, even if fresh results are already cached - &#x60;&#39;force_async&#39;&#x60; - kick off background calculation, even if fresh results are already cached Background calculation can be tracked using the &#x60;query_status&#x60; response field.
func (r ApiInsightsListRequest) Refresh(refresh string) ApiInsightsListRequest {
	r.refresh = &refresh
	return r
}

func (r ApiInsightsListRequest) ShortId(shortId string) ApiInsightsListRequest {
	r.shortId = &shortId
	return r
}

func (r ApiInsightsListRequest) Execute() (*PaginatedInsightList, *http.Response, error) {
	return r.ApiService.InsightsListExecute(r)
}

/*
InsightsList Method for InsightsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsListRequest
*/
func (a *InsightsAPIService) InsightsList(ctx context.Context, projectId string) ApiInsightsListRequest {
	return ApiInsightsListRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedInsightList
func (a *InsightsAPIService) InsightsListExecute(r ApiInsightsListRequest) (*PaginatedInsightList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedInsightList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.basic != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "basic", r.basic, "form", "")
	}
	if r.createdBy != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "created_by", r.createdBy, "form", "")
	}
	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "form", "")
	} else {
        var defaultValue string = "force_cache"
        parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", defaultValue, "form", "")
        r.refresh = &defaultValue
	}
	if r.shortId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "short_id", r.shortId, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightsMyLastViewedRetrieveRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	projectId string
	format *string
}

func (r ApiInsightsMyLastViewedRetrieveRequest) Format(format string) ApiInsightsMyLastViewedRetrieveRequest {
	r.format = &format
	return r
}

func (r ApiInsightsMyLastViewedRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.InsightsMyLastViewedRetrieveExecute(r)
}

/*
InsightsMyLastViewedRetrieve Method for InsightsMyLastViewedRetrieve

Returns basic details about the last 5 insights viewed by this user. Most recently viewed first.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsMyLastViewedRetrieveRequest
*/
func (a *InsightsAPIService) InsightsMyLastViewedRetrieve(ctx context.Context, projectId string) ApiInsightsMyLastViewedRetrieveRequest {
	return ApiInsightsMyLastViewedRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *InsightsAPIService) InsightsMyLastViewedRetrieveExecute(r ApiInsightsMyLastViewedRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsMyLastViewedRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/my_last_viewed/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInsightsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	id int32
	projectId string
	format *string
	patchedInsight *PatchedInsight
}

func (r ApiInsightsPartialUpdateRequest) Format(format string) ApiInsightsPartialUpdateRequest {
	r.format = &format
	return r
}

func (r ApiInsightsPartialUpdateRequest) PatchedInsight(patchedInsight PatchedInsight) ApiInsightsPartialUpdateRequest {
	r.patchedInsight = &patchedInsight
	return r
}

func (r ApiInsightsPartialUpdateRequest) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.InsightsPartialUpdateExecute(r)
}

/*
InsightsPartialUpdate Method for InsightsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsPartialUpdateRequest
*/
func (a *InsightsAPIService) InsightsPartialUpdate(ctx context.Context, id int32, projectId string) ApiInsightsPartialUpdateRequest {
	return ApiInsightsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *InsightsAPIService) InsightsPartialUpdateExecute(r ApiInsightsPartialUpdateRequest) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedInsight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightsRetrieveRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	id int32
	projectId string
	format *string
	fromDashboard *int32
	refresh *string
}

func (r ApiInsightsRetrieveRequest) Format(format string) ApiInsightsRetrieveRequest {
	r.format = &format
	return r
}

//  Only if loading an insight in the context of a dashboard: The relevant dashboard&#39;s ID. When set, the specified dashboard&#39;s filters and date range override will be applied.
func (r ApiInsightsRetrieveRequest) FromDashboard(fromDashboard int32) ApiInsightsRetrieveRequest {
	r.fromDashboard = &fromDashboard
	return r
}

//  Whether to refresh the insight, how aggresively, and if sync or async: - &#x60;&#39;force_cache&#39;&#x60; - return cached data or a cache miss; always completes immediately as it never calculates - &#x60;&#39;blocking&#39;&#x60; - calculate synchronously (returning only when the query is done), UNLESS there are very fresh results in the cache - &#x60;&#39;async&#39;&#x60; - kick off background calculation (returning immediately with a query status), UNLESS there are very fresh results in the cache - &#x60;&#39;lazy_async&#39;&#x60; - kick off background calculation, UNLESS there are somewhat fresh results in the cache - &#x60;&#39;force_blocking&#39;&#x60; - calculate synchronously, even if fresh results are already cached - &#x60;&#39;force_async&#39;&#x60; - kick off background calculation, even if fresh results are already cached Background calculation can be tracked using the &#x60;query_status&#x60; response field.
func (r ApiInsightsRetrieveRequest) Refresh(refresh string) ApiInsightsRetrieveRequest {
	r.refresh = &refresh
	return r
}

func (r ApiInsightsRetrieveRequest) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.InsightsRetrieveExecute(r)
}

/*
InsightsRetrieve Method for InsightsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsRetrieveRequest
*/
func (a *InsightsAPIService) InsightsRetrieve(ctx context.Context, id int32, projectId string) ApiInsightsRetrieveRequest {
	return ApiInsightsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *InsightsAPIService) InsightsRetrieveExecute(r ApiInsightsRetrieveRequest) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	if r.fromDashboard != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "from_dashboard", r.fromDashboard, "form", "")
	}
	if r.refresh != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", r.refresh, "form", "")
	} else {
        var defaultValue string = "force_cache"
        parameterAddToHeaderOrQuery(localVarQueryParams, "refresh", defaultValue, "form", "")
        r.refresh = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightsSharingListRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	insightId int32
	projectId string
}

func (r ApiInsightsSharingListRequest) Execute() ([]SharingConfiguration, *http.Response, error) {
	return r.ApiService.InsightsSharingListExecute(r)
}

/*
InsightsSharingList Method for InsightsSharingList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsSharingListRequest
*/
func (a *InsightsAPIService) InsightsSharingList(ctx context.Context, insightId int32, projectId string) ApiInsightsSharingListRequest {
	return ApiInsightsSharingListRequest{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return []SharingConfiguration
func (a *InsightsAPIService) InsightsSharingListExecute(r ApiInsightsSharingListRequest) ([]SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsSharingList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{insight_id}/sharing/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightsSharingPasswordsCreateRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	insightId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiInsightsSharingPasswordsCreateRequest) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiInsightsSharingPasswordsCreateRequest {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiInsightsSharingPasswordsCreateRequest) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.InsightsSharingPasswordsCreateExecute(r)
}

/*
InsightsSharingPasswordsCreate Method for InsightsSharingPasswordsCreate

Create a new password for the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsSharingPasswordsCreateRequest
*/
func (a *InsightsAPIService) InsightsSharingPasswordsCreate(ctx context.Context, insightId int32, projectId string) ApiInsightsSharingPasswordsCreateRequest {
	return ApiInsightsSharingPasswordsCreateRequest{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *InsightsAPIService) InsightsSharingPasswordsCreateExecute(r ApiInsightsSharingPasswordsCreateRequest) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsSharingPasswordsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{insight_id}/sharing/passwords/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightsSharingPasswordsDestroyRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	insightId int32
	passwordId string
	projectId string
}

func (r ApiInsightsSharingPasswordsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.InsightsSharingPasswordsDestroyExecute(r)
}

/*
InsightsSharingPasswordsDestroy Method for InsightsSharingPasswordsDestroy

Delete a password from the sharing configuration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param passwordId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsSharingPasswordsDestroyRequest
*/
func (a *InsightsAPIService) InsightsSharingPasswordsDestroy(ctx context.Context, insightId int32, passwordId string, projectId string) ApiInsightsSharingPasswordsDestroyRequest {
	return ApiInsightsSharingPasswordsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		passwordId: passwordId,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *InsightsAPIService) InsightsSharingPasswordsDestroyExecute(r ApiInsightsSharingPasswordsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsSharingPasswordsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{insight_id}/sharing/passwords/{password_id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"password_id"+"}", url.PathEscape(parameterValueToString(r.passwordId, "passwordId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiInsightsSharingRefreshCreateRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	insightId int32
	projectId string
	sharingConfiguration *SharingConfiguration
}

func (r ApiInsightsSharingRefreshCreateRequest) SharingConfiguration(sharingConfiguration SharingConfiguration) ApiInsightsSharingRefreshCreateRequest {
	r.sharingConfiguration = &sharingConfiguration
	return r
}

func (r ApiInsightsSharingRefreshCreateRequest) Execute() (*SharingConfiguration, *http.Response, error) {
	return r.ApiService.InsightsSharingRefreshCreateExecute(r)
}

/*
InsightsSharingRefreshCreate Method for InsightsSharingRefreshCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param insightId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsSharingRefreshCreateRequest
*/
func (a *InsightsAPIService) InsightsSharingRefreshCreate(ctx context.Context, insightId int32, projectId string) ApiInsightsSharingRefreshCreateRequest {
	return ApiInsightsSharingRefreshCreateRequest{
		ApiService: a,
		ctx: ctx,
		insightId: insightId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return SharingConfiguration
func (a *InsightsAPIService) InsightsSharingRefreshCreateExecute(r ApiInsightsSharingRefreshCreateRequest) (*SharingConfiguration, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SharingConfiguration
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsSharingRefreshCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{insight_id}/sharing/refresh/"
	localVarPath = strings.Replace(localVarPath, "{"+"insight_id"+"}", url.PathEscape(parameterValueToString(r.insightId, "insightId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.sharingConfiguration
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightsUpdateRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	id int32
	projectId string
	format *string
	insight *Insight
}

func (r ApiInsightsUpdateRequest) Format(format string) ApiInsightsUpdateRequest {
	r.format = &format
	return r
}

func (r ApiInsightsUpdateRequest) Insight(insight Insight) ApiInsightsUpdateRequest {
	r.insight = &insight
	return r
}

func (r ApiInsightsUpdateRequest) Execute() (*Insight, *http.Response, error) {
	return r.ApiService.InsightsUpdateExecute(r)
}

/*
InsightsUpdate Method for InsightsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A unique integer value identifying this insight.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsUpdateRequest
*/
func (a *InsightsAPIService) InsightsUpdate(ctx context.Context, id int32, projectId string) ApiInsightsUpdateRequest {
	return ApiInsightsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return Insight
func (a *InsightsAPIService) InsightsUpdateExecute(r ApiInsightsUpdateRequest) (*Insight, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *Insight
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "text/csv"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInsightsViewedCreateRequest struct {
	ctx context.Context
	ApiService *InsightsAPIService
	projectId string
	format *string
	insight *Insight
}

func (r ApiInsightsViewedCreateRequest) Format(format string) ApiInsightsViewedCreateRequest {
	r.format = &format
	return r
}

func (r ApiInsightsViewedCreateRequest) Insight(insight Insight) ApiInsightsViewedCreateRequest {
	r.insight = &insight
	return r
}

func (r ApiInsightsViewedCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.InsightsViewedCreateExecute(r)
}

/*
InsightsViewedCreate Method for InsightsViewedCreate

Update insight view timestamps.
Expects: {"insight_ids": [1, 2, 3, ...]}

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiInsightsViewedCreateRequest
*/
func (a *InsightsAPIService) InsightsViewedCreate(ctx context.Context, projectId string) ApiInsightsViewedCreateRequest {
	return ApiInsightsViewedCreateRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *InsightsAPIService) InsightsViewedCreateExecute(r ApiInsightsViewedCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "InsightsAPIService.InsightsViewedCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/insights/viewed/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.format != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "format", r.format, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.insight
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

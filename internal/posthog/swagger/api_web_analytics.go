/*
PostHog API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package posthogapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// WebAnalyticsAPIService WebAnalyticsAPI service
type WebAnalyticsAPIService service

type ApiWebAnalyticsBreakdownRetrieveRequest struct {
	ctx context.Context
	ApiService *WebAnalyticsAPIService
	breakdownBy *string
	dateFrom *string
	dateTo *string
	projectId string
	applyPathCleaning *bool
	filterTestAccounts *bool
	host *string
	limit *int32
	offset *int32
}

// Property to break down by  * &#x60;DeviceType&#x60; - DeviceType * &#x60;Browser&#x60; - Browser * &#x60;OS&#x60; - OS * &#x60;Viewport&#x60; - Viewport * &#x60;InitialReferringDomain&#x60; - InitialReferringDomain * &#x60;InitialUTMSource&#x60; - InitialUTMSource * &#x60;InitialUTMMedium&#x60; - InitialUTMMedium * &#x60;InitialUTMCampaign&#x60; - InitialUTMCampaign * &#x60;InitialUTMTerm&#x60; - InitialUTMTerm * &#x60;InitialUTMContent&#x60; - InitialUTMContent * &#x60;Country&#x60; - Country * &#x60;Region&#x60; - Region * &#x60;City&#x60; - City * &#x60;InitialPage&#x60; - InitialPage * &#x60;Page&#x60; - Page * &#x60;ExitPage&#x60; - ExitPage * &#x60;InitialChannelType&#x60; - InitialChannelType
func (r ApiWebAnalyticsBreakdownRetrieveRequest) BreakdownBy(breakdownBy string) ApiWebAnalyticsBreakdownRetrieveRequest {
	r.breakdownBy = &breakdownBy
	return r
}

// Start date for the query (format: YYYY-MM-DD)
func (r ApiWebAnalyticsBreakdownRetrieveRequest) DateFrom(dateFrom string) ApiWebAnalyticsBreakdownRetrieveRequest {
	r.dateFrom = &dateFrom
	return r
}

// End date for the query (format: YYYY-MM-DD)
func (r ApiWebAnalyticsBreakdownRetrieveRequest) DateTo(dateTo string) ApiWebAnalyticsBreakdownRetrieveRequest {
	r.dateTo = &dateTo
	return r
}

// Apply URL path cleaning
func (r ApiWebAnalyticsBreakdownRetrieveRequest) ApplyPathCleaning(applyPathCleaning bool) ApiWebAnalyticsBreakdownRetrieveRequest {
	r.applyPathCleaning = &applyPathCleaning
	return r
}

// Filter out test accounts
func (r ApiWebAnalyticsBreakdownRetrieveRequest) FilterTestAccounts(filterTestAccounts bool) ApiWebAnalyticsBreakdownRetrieveRequest {
	r.filterTestAccounts = &filterTestAccounts
	return r
}

// Host to filter by (e.g. example.com)
func (r ApiWebAnalyticsBreakdownRetrieveRequest) Host(host string) ApiWebAnalyticsBreakdownRetrieveRequest {
	r.host = &host
	return r
}

// Number of results to return
func (r ApiWebAnalyticsBreakdownRetrieveRequest) Limit(limit int32) ApiWebAnalyticsBreakdownRetrieveRequest {
	r.limit = &limit
	return r
}

// Number of results to skip
func (r ApiWebAnalyticsBreakdownRetrieveRequest) Offset(offset int32) ApiWebAnalyticsBreakdownRetrieveRequest {
	r.offset = &offset
	return r
}

func (r ApiWebAnalyticsBreakdownRetrieveRequest) Execute() (*WebAnalyticsBreakdownResponse, *http.Response, error) {
	return r.ApiService.WebAnalyticsBreakdownRetrieveExecute(r)
}

/*
WebAnalyticsBreakdownRetrieve Method for WebAnalyticsBreakdownRetrieve

This endpoint is in Concept state, please join the feature preview to try it out when it's ready. Get a breakdown by a property (e.g. browser, device type, country, etc.).

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWebAnalyticsBreakdownRetrieveRequest
*/
func (a *WebAnalyticsAPIService) WebAnalyticsBreakdownRetrieve(ctx context.Context, projectId string) ApiWebAnalyticsBreakdownRetrieveRequest {
	return ApiWebAnalyticsBreakdownRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return WebAnalyticsBreakdownResponse
func (a *WebAnalyticsAPIService) WebAnalyticsBreakdownRetrieveExecute(r ApiWebAnalyticsBreakdownRetrieveRequest) (*WebAnalyticsBreakdownResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebAnalyticsBreakdownResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebAnalyticsAPIService.WebAnalyticsBreakdownRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/web_analytics/breakdown/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.breakdownBy == nil {
		return localVarReturnValue, nil, reportError("breakdownBy is required and must be specified")
	}
	if strlen(*r.breakdownBy) < 1 {
		return localVarReturnValue, nil, reportError("breakdownBy must have at least 1 elements")
	}
	if r.dateFrom == nil {
		return localVarReturnValue, nil, reportError("dateFrom is required and must be specified")
	}
	if r.dateTo == nil {
		return localVarReturnValue, nil, reportError("dateTo is required and must be specified")
	}

	if r.applyPathCleaning != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "apply_path_cleaning", r.applyPathCleaning, "form", "")
	} else {
        var defaultValue bool = true
        parameterAddToHeaderOrQuery(localVarQueryParams, "apply_path_cleaning", defaultValue, "form", "")
        r.applyPathCleaning = &defaultValue
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "breakdown_by", r.breakdownBy, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "form", "")
	if r.filterTestAccounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_test_accounts", r.filterTestAccounts, "form", "")
	} else {
        var defaultValue bool = true
        parameterAddToHeaderOrQuery(localVarQueryParams, "filter_test_accounts", defaultValue, "form", "")
        r.filterTestAccounts = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	} else {
        var defaultValue int32 = 100
        parameterAddToHeaderOrQuery(localVarQueryParams, "limit", defaultValue, "form", "")
        r.limit = &defaultValue
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	} else {
        var defaultValue int32 = 0
        parameterAddToHeaderOrQuery(localVarQueryParams, "offset", defaultValue, "form", "")
        r.offset = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWebAnalyticsOverviewRetrieveRequest struct {
	ctx context.Context
	ApiService *WebAnalyticsAPIService
	dateFrom *string
	dateTo *string
	projectId string
	filterTestAccounts *bool
	host *string
}

// Start date for the query (format: YYYY-MM-DD)
func (r ApiWebAnalyticsOverviewRetrieveRequest) DateFrom(dateFrom string) ApiWebAnalyticsOverviewRetrieveRequest {
	r.dateFrom = &dateFrom
	return r
}

// End date for the query (format: YYYY-MM-DD)
func (r ApiWebAnalyticsOverviewRetrieveRequest) DateTo(dateTo string) ApiWebAnalyticsOverviewRetrieveRequest {
	r.dateTo = &dateTo
	return r
}

// Filter out test accounts
func (r ApiWebAnalyticsOverviewRetrieveRequest) FilterTestAccounts(filterTestAccounts bool) ApiWebAnalyticsOverviewRetrieveRequest {
	r.filterTestAccounts = &filterTestAccounts
	return r
}

// Host to filter by (e.g. example.com)
func (r ApiWebAnalyticsOverviewRetrieveRequest) Host(host string) ApiWebAnalyticsOverviewRetrieveRequest {
	r.host = &host
	return r
}

func (r ApiWebAnalyticsOverviewRetrieveRequest) Execute() (*WebAnalyticsOverviewResponse, *http.Response, error) {
	return r.ApiService.WebAnalyticsOverviewRetrieveExecute(r)
}

/*
WebAnalyticsOverviewRetrieve Method for WebAnalyticsOverviewRetrieve

This endpoint is in Concept state, please join the feature preview to try it out when it's ready. Get an overview of web analytics data including visitors, views, sessions, bounce rate, and session duration.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiWebAnalyticsOverviewRetrieveRequest
*/
func (a *WebAnalyticsAPIService) WebAnalyticsOverviewRetrieve(ctx context.Context, projectId string) ApiWebAnalyticsOverviewRetrieveRequest {
	return ApiWebAnalyticsOverviewRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return WebAnalyticsOverviewResponse
func (a *WebAnalyticsAPIService) WebAnalyticsOverviewRetrieveExecute(r ApiWebAnalyticsOverviewRetrieveRequest) (*WebAnalyticsOverviewResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *WebAnalyticsOverviewResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WebAnalyticsAPIService.WebAnalyticsOverviewRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/web_analytics/overview/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.dateFrom == nil {
		return localVarReturnValue, nil, reportError("dateFrom is required and must be specified")
	}
	if r.dateTo == nil {
		return localVarReturnValue, nil, reportError("dateTo is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "date_from", r.dateFrom, "form", "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "date_to", r.dateTo, "form", "")
	if r.filterTestAccounts != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "filter_test_accounts", r.filterTestAccounts, "form", "")
	} else {
        var defaultValue bool = true
        parameterAddToHeaderOrQuery(localVarQueryParams, "filter_test_accounts", defaultValue, "form", "")
        r.filterTestAccounts = &defaultValue
	}
	if r.host != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "host", r.host, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
PostHog API

No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)

API version: 1.0.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package posthogapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// BatchExportsAPIService BatchExportsAPI service
type BatchExportsAPIService service

type ApiBatchExportsBackfillCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
	batchExport *BatchExport
}

func (r ApiBatchExportsBackfillCreateRequest) BatchExport(batchExport BatchExport) ApiBatchExportsBackfillCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsBackfillCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsBackfillCreateExecute(r)
}

/*
BatchExportsBackfillCreate Method for BatchExportsBackfillCreate

Trigger a backfill for a BatchExport.

Note: This endpoint is deprecated. Please use POST /batch_exports/<id>/backfills/ instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsBackfillCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsBackfillCreate(ctx context.Context, id string, organizationId string) ApiBatchExportsBackfillCreateRequest {
	return ApiBatchExportsBackfillCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsBackfillCreateExecute(r ApiBatchExportsBackfillCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsBackfillCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/backfill/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsBackfillCreate2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiBatchExportsBackfillCreate2Request) BatchExport(batchExport BatchExport) ApiBatchExportsBackfillCreate2Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsBackfillCreate2Request) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsBackfillCreate2Execute(r)
}

/*
BatchExportsBackfillCreate2 Method for BatchExportsBackfillCreate2

Trigger a backfill for a BatchExport.

Note: This endpoint is deprecated. Please use POST /batch_exports/<id>/backfills/ instead.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsBackfillCreate2Request
*/
func (a *BatchExportsAPIService) BatchExportsBackfillCreate2(ctx context.Context, id string, projectId string) ApiBatchExportsBackfillCreate2Request {
	return ApiBatchExportsBackfillCreate2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsBackfillCreate2Execute(r ApiBatchExportsBackfillCreate2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsBackfillCreate2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/backfill/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsBackfillsCancelCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	id string
	projectId string
	batchExportBackfill *BatchExportBackfill
}

func (r ApiBatchExportsBackfillsCancelCreateRequest) BatchExportBackfill(batchExportBackfill BatchExportBackfill) ApiBatchExportsBackfillsCancelCreateRequest {
	r.batchExportBackfill = &batchExportBackfill
	return r
}

func (r ApiBatchExportsBackfillsCancelCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsBackfillsCancelCreateExecute(r)
}

/*
BatchExportsBackfillsCancelCreate Method for BatchExportsBackfillsCancelCreate

Cancel a batch export backfill.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export backfill.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsBackfillsCancelCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsBackfillsCancelCreate(ctx context.Context, batchExportId string, id string, projectId string) ApiBatchExportsBackfillsCancelCreateRequest {
	return ApiBatchExportsBackfillsCancelCreateRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsBackfillsCancelCreateExecute(r ApiBatchExportsBackfillsCancelCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsBackfillsCancelCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/backfills/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportBackfill == nil {
		return nil, reportError("batchExportBackfill is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportBackfill
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsBackfillsCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	projectId string
	batchExportBackfill *BatchExportBackfill
}

func (r ApiBatchExportsBackfillsCreateRequest) BatchExportBackfill(batchExportBackfill BatchExportBackfill) ApiBatchExportsBackfillsCreateRequest {
	r.batchExportBackfill = &batchExportBackfill
	return r
}

func (r ApiBatchExportsBackfillsCreateRequest) Execute() (*BatchExportBackfill, *http.Response, error) {
	return r.ApiService.BatchExportsBackfillsCreateExecute(r)
}

/*
BatchExportsBackfillsCreate Method for BatchExportsBackfillsCreate

Create a new backfill for a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsBackfillsCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsBackfillsCreate(ctx context.Context, batchExportId string, projectId string) ApiBatchExportsBackfillsCreateRequest {
	return ApiBatchExportsBackfillsCreateRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportBackfill
func (a *BatchExportsAPIService) BatchExportsBackfillsCreateExecute(r ApiBatchExportsBackfillsCreateRequest) (*BatchExportBackfill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportBackfill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsBackfillsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/backfills/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportBackfill == nil {
		return localVarReturnValue, nil, reportError("batchExportBackfill is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportBackfill
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsBackfillsListRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	projectId string
	cursor *string
	ordering *string
}

// The pagination cursor value.
func (r ApiBatchExportsBackfillsListRequest) Cursor(cursor string) ApiBatchExportsBackfillsListRequest {
	r.cursor = &cursor
	return r
}

// Which field to use when ordering the results.
func (r ApiBatchExportsBackfillsListRequest) Ordering(ordering string) ApiBatchExportsBackfillsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiBatchExportsBackfillsListRequest) Execute() (*PaginatedBatchExportBackfillList, *http.Response, error) {
	return r.ApiService.BatchExportsBackfillsListExecute(r)
}

/*
BatchExportsBackfillsList Method for BatchExportsBackfillsList

ViewSet for BatchExportBackfill models.

Allows creating and reading backfills, but not updating or deleting them.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsBackfillsListRequest
*/
func (a *BatchExportsAPIService) BatchExportsBackfillsList(ctx context.Context, batchExportId string, projectId string) ApiBatchExportsBackfillsListRequest {
	return ApiBatchExportsBackfillsListRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportBackfillList
func (a *BatchExportsAPIService) BatchExportsBackfillsListExecute(r ApiBatchExportsBackfillsListRequest) (*PaginatedBatchExportBackfillList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportBackfillList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsBackfillsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/backfills/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsBackfillsRetrieveRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiBatchExportsBackfillsRetrieveRequest) Execute() (*BatchExportBackfill, *http.Response, error) {
	return r.ApiService.BatchExportsBackfillsRetrieveExecute(r)
}

/*
BatchExportsBackfillsRetrieve Method for BatchExportsBackfillsRetrieve

ViewSet for BatchExportBackfill models.

Allows creating and reading backfills, but not updating or deleting them.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export backfill.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsBackfillsRetrieveRequest
*/
func (a *BatchExportsAPIService) BatchExportsBackfillsRetrieve(ctx context.Context, batchExportId string, id string, projectId string) ApiBatchExportsBackfillsRetrieveRequest {
	return ApiBatchExportsBackfillsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportBackfill
func (a *BatchExportsAPIService) BatchExportsBackfillsRetrieveExecute(r ApiBatchExportsBackfillsRetrieveRequest) (*BatchExportBackfill, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportBackfill
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsBackfillsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/backfills/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	organizationId string
	batchExport *BatchExport
}

func (r ApiBatchExportsCreateRequest) BatchExport(batchExport BatchExport) ApiBatchExportsCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsCreateRequest) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.BatchExportsCreateExecute(r)
}

/*
BatchExportsCreate Method for BatchExportsCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId
 @return ApiBatchExportsCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsCreate(ctx context.Context, organizationId string) ApiBatchExportsCreateRequest {
	return ApiBatchExportsCreateRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *BatchExportsAPIService) BatchExportsCreateExecute(r ApiBatchExportsCreateRequest) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsCreate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return localVarReturnValue, nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsCreate2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	projectId string
	batchExport *BatchExport
}

func (r ApiBatchExportsCreate2Request) BatchExport(batchExport BatchExport) ApiBatchExportsCreate2Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsCreate2Request) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.BatchExportsCreate2Execute(r)
}

/*
BatchExportsCreate2 Method for BatchExportsCreate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsCreate2Request
*/
func (a *BatchExportsAPIService) BatchExportsCreate2(ctx context.Context, projectId string) ApiBatchExportsCreate2Request {
	return ApiBatchExportsCreate2Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *BatchExportsAPIService) BatchExportsCreate2Execute(r ApiBatchExportsCreate2Request) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsCreate2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return localVarReturnValue, nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsDestroyRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
}

func (r ApiBatchExportsDestroyRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsDestroyExecute(r)
}

/*
BatchExportsDestroy Method for BatchExportsDestroy

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsDestroyRequest
*/
func (a *BatchExportsAPIService) BatchExportsDestroy(ctx context.Context, id string, organizationId string) ApiBatchExportsDestroyRequest {
	return ApiBatchExportsDestroyRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsDestroyExecute(r ApiBatchExportsDestroyRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsDestroy")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsDestroy2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
}

func (r ApiBatchExportsDestroy2Request) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsDestroy2Execute(r)
}

/*
BatchExportsDestroy2 Method for BatchExportsDestroy2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsDestroy2Request
*/
func (a *BatchExportsAPIService) BatchExportsDestroy2(ctx context.Context, id string, projectId string) ApiBatchExportsDestroy2Request {
	return ApiBatchExportsDestroy2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsDestroy2Execute(r ApiBatchExportsDestroy2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsDestroy2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsListRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	organizationId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiBatchExportsListRequest) Limit(limit int32) ApiBatchExportsListRequest {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiBatchExportsListRequest) Offset(offset int32) ApiBatchExportsListRequest {
	r.offset = &offset
	return r
}

func (r ApiBatchExportsListRequest) Execute() (*PaginatedBatchExportList, *http.Response, error) {
	return r.ApiService.BatchExportsListExecute(r)
}

/*
BatchExportsList Method for BatchExportsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId
 @return ApiBatchExportsListRequest
*/
func (a *BatchExportsAPIService) BatchExportsList(ctx context.Context, organizationId string) ApiBatchExportsListRequest {
	return ApiBatchExportsListRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportList
func (a *BatchExportsAPIService) BatchExportsListExecute(r ApiBatchExportsListRequest) (*PaginatedBatchExportList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsList2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	projectId string
	limit *int32
	offset *int32
}

// Number of results to return per page.
func (r ApiBatchExportsList2Request) Limit(limit int32) ApiBatchExportsList2Request {
	r.limit = &limit
	return r
}

// The initial index from which to return the results.
func (r ApiBatchExportsList2Request) Offset(offset int32) ApiBatchExportsList2Request {
	r.offset = &offset
	return r
}

func (r ApiBatchExportsList2Request) Execute() (*PaginatedBatchExportList, *http.Response, error) {
	return r.ApiService.BatchExportsList2Execute(r)
}

/*
BatchExportsList2 Method for BatchExportsList2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsList2Request
*/
func (a *BatchExportsAPIService) BatchExportsList2(ctx context.Context, projectId string) ApiBatchExportsList2Request {
	return ApiBatchExportsList2Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportList
func (a *BatchExportsAPIService) BatchExportsList2Execute(r ApiBatchExportsList2Request) (*PaginatedBatchExportList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsList2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsLogsRetrieveRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
}

func (r ApiBatchExportsLogsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsLogsRetrieveExecute(r)
}

/*
BatchExportsLogsRetrieve Method for BatchExportsLogsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsLogsRetrieveRequest
*/
func (a *BatchExportsAPIService) BatchExportsLogsRetrieve(ctx context.Context, id string, organizationId string) ApiBatchExportsLogsRetrieveRequest {
	return ApiBatchExportsLogsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsLogsRetrieveExecute(r ApiBatchExportsLogsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsLogsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsLogsRetrieve2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
}

func (r ApiBatchExportsLogsRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsLogsRetrieve2Execute(r)
}

/*
BatchExportsLogsRetrieve2 Method for BatchExportsLogsRetrieve2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsLogsRetrieve2Request
*/
func (a *BatchExportsAPIService) BatchExportsLogsRetrieve2(ctx context.Context, id string, projectId string) ApiBatchExportsLogsRetrieve2Request {
	return ApiBatchExportsLogsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsLogsRetrieve2Execute(r ApiBatchExportsLogsRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsLogsRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsPartialUpdateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
	patchedBatchExport *PatchedBatchExport
}

func (r ApiBatchExportsPartialUpdateRequest) PatchedBatchExport(patchedBatchExport PatchedBatchExport) ApiBatchExportsPartialUpdateRequest {
	r.patchedBatchExport = &patchedBatchExport
	return r
}

func (r ApiBatchExportsPartialUpdateRequest) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.BatchExportsPartialUpdateExecute(r)
}

/*
BatchExportsPartialUpdate Method for BatchExportsPartialUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsPartialUpdateRequest
*/
func (a *BatchExportsAPIService) BatchExportsPartialUpdate(ctx context.Context, id string, organizationId string) ApiBatchExportsPartialUpdateRequest {
	return ApiBatchExportsPartialUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *BatchExportsAPIService) BatchExportsPartialUpdateExecute(r ApiBatchExportsPartialUpdateRequest) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsPartialUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBatchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsPartialUpdate2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
	patchedBatchExport *PatchedBatchExport
}

func (r ApiBatchExportsPartialUpdate2Request) PatchedBatchExport(patchedBatchExport PatchedBatchExport) ApiBatchExportsPartialUpdate2Request {
	r.patchedBatchExport = &patchedBatchExport
	return r
}

func (r ApiBatchExportsPartialUpdate2Request) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.BatchExportsPartialUpdate2Execute(r)
}

/*
BatchExportsPartialUpdate2 Method for BatchExportsPartialUpdate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsPartialUpdate2Request
*/
func (a *BatchExportsAPIService) BatchExportsPartialUpdate2(ctx context.Context, id string, projectId string) ApiBatchExportsPartialUpdate2Request {
	return ApiBatchExportsPartialUpdate2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *BatchExportsAPIService) BatchExportsPartialUpdate2Execute(r ApiBatchExportsPartialUpdate2Request) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsPartialUpdate2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.patchedBatchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsPauseCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
	batchExport *BatchExport
}

func (r ApiBatchExportsPauseCreateRequest) BatchExport(batchExport BatchExport) ApiBatchExportsPauseCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsPauseCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsPauseCreateExecute(r)
}

/*
BatchExportsPauseCreate Method for BatchExportsPauseCreate

Pause a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsPauseCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsPauseCreate(ctx context.Context, id string, organizationId string) ApiBatchExportsPauseCreateRequest {
	return ApiBatchExportsPauseCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsPauseCreateExecute(r ApiBatchExportsPauseCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsPauseCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/pause/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsPauseCreate2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiBatchExportsPauseCreate2Request) BatchExport(batchExport BatchExport) ApiBatchExportsPauseCreate2Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsPauseCreate2Request) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsPauseCreate2Execute(r)
}

/*
BatchExportsPauseCreate2 Method for BatchExportsPauseCreate2

Pause a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsPauseCreate2Request
*/
func (a *BatchExportsAPIService) BatchExportsPauseCreate2(ctx context.Context, id string, projectId string) ApiBatchExportsPauseCreate2Request {
	return ApiBatchExportsPauseCreate2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsPauseCreate2Execute(r ApiBatchExportsPauseCreate2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsPauseCreate2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/pause/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsRetrieveRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
}

func (r ApiBatchExportsRetrieveRequest) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.BatchExportsRetrieveExecute(r)
}

/*
BatchExportsRetrieve Method for BatchExportsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsRetrieveRequest
*/
func (a *BatchExportsAPIService) BatchExportsRetrieve(ctx context.Context, id string, organizationId string) ApiBatchExportsRetrieveRequest {
	return ApiBatchExportsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *BatchExportsAPIService) BatchExportsRetrieveExecute(r ApiBatchExportsRetrieveRequest) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsRetrieve2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
}

func (r ApiBatchExportsRetrieve2Request) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.BatchExportsRetrieve2Execute(r)
}

/*
BatchExportsRetrieve2 Method for BatchExportsRetrieve2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsRetrieve2Request
*/
func (a *BatchExportsAPIService) BatchExportsRetrieve2(ctx context.Context, id string, projectId string) ApiBatchExportsRetrieve2Request {
	return ApiBatchExportsRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *BatchExportsAPIService) BatchExportsRetrieve2Execute(r ApiBatchExportsRetrieve2Request) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRetrieve2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsRunTestStepCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
	batchExport *BatchExport
}

func (r ApiBatchExportsRunTestStepCreateRequest) BatchExport(batchExport BatchExport) ApiBatchExportsRunTestStepCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsRunTestStepCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsRunTestStepCreateExecute(r)
}

/*
BatchExportsRunTestStepCreate Method for BatchExportsRunTestStepCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsRunTestStepCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsRunTestStepCreate(ctx context.Context, id string, organizationId string) ApiBatchExportsRunTestStepCreateRequest {
	return ApiBatchExportsRunTestStepCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsRunTestStepCreateExecute(r ApiBatchExportsRunTestStepCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunTestStepCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/run_test_step/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsRunTestStepCreate2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiBatchExportsRunTestStepCreate2Request) BatchExport(batchExport BatchExport) ApiBatchExportsRunTestStepCreate2Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsRunTestStepCreate2Request) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsRunTestStepCreate2Execute(r)
}

/*
BatchExportsRunTestStepCreate2 Method for BatchExportsRunTestStepCreate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsRunTestStepCreate2Request
*/
func (a *BatchExportsAPIService) BatchExportsRunTestStepCreate2(ctx context.Context, id string, projectId string) ApiBatchExportsRunTestStepCreate2Request {
	return ApiBatchExportsRunTestStepCreate2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsRunTestStepCreate2Execute(r ApiBatchExportsRunTestStepCreate2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunTestStepCreate2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/run_test_step/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsRunTestStepNewCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	organizationId string
	batchExport *BatchExport
}

func (r ApiBatchExportsRunTestStepNewCreateRequest) BatchExport(batchExport BatchExport) ApiBatchExportsRunTestStepNewCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsRunTestStepNewCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsRunTestStepNewCreateExecute(r)
}

/*
BatchExportsRunTestStepNewCreate Method for BatchExportsRunTestStepNewCreate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId
 @return ApiBatchExportsRunTestStepNewCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsRunTestStepNewCreate(ctx context.Context, organizationId string) ApiBatchExportsRunTestStepNewCreateRequest {
	return ApiBatchExportsRunTestStepNewCreateRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsRunTestStepNewCreateExecute(r ApiBatchExportsRunTestStepNewCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunTestStepNewCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/run_test_step_new/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsRunTestStepNewCreate2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	projectId string
	batchExport *BatchExport
}

func (r ApiBatchExportsRunTestStepNewCreate2Request) BatchExport(batchExport BatchExport) ApiBatchExportsRunTestStepNewCreate2Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsRunTestStepNewCreate2Request) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsRunTestStepNewCreate2Execute(r)
}

/*
BatchExportsRunTestStepNewCreate2 Method for BatchExportsRunTestStepNewCreate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsRunTestStepNewCreate2Request
*/
func (a *BatchExportsAPIService) BatchExportsRunTestStepNewCreate2(ctx context.Context, projectId string) ApiBatchExportsRunTestStepNewCreate2Request {
	return ApiBatchExportsRunTestStepNewCreate2Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsRunTestStepNewCreate2Execute(r ApiBatchExportsRunTestStepNewCreate2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunTestStepNewCreate2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/run_test_step_new/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsRunsCancelCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	id string
	projectId string
	batchExportRun *BatchExportRun
}

func (r ApiBatchExportsRunsCancelCreateRequest) BatchExportRun(batchExportRun BatchExportRun) ApiBatchExportsRunsCancelCreateRequest {
	r.batchExportRun = &batchExportRun
	return r
}

func (r ApiBatchExportsRunsCancelCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsRunsCancelCreateExecute(r)
}

/*
BatchExportsRunsCancelCreate Method for BatchExportsRunsCancelCreate

Cancel a batch export run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsRunsCancelCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsRunsCancelCreate(ctx context.Context, batchExportId string, id string, projectId string) ApiBatchExportsRunsCancelCreateRequest {
	return ApiBatchExportsRunsCancelCreateRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsRunsCancelCreateExecute(r ApiBatchExportsRunsCancelCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunsCancelCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/runs/{id}/cancel/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportRun == nil {
		return nil, reportError("batchExportRun is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportRun
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsRunsListRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	projectId string
	cursor *string
	ordering *string
}

// The pagination cursor value.
func (r ApiBatchExportsRunsListRequest) Cursor(cursor string) ApiBatchExportsRunsListRequest {
	r.cursor = &cursor
	return r
}

// Which field to use when ordering the results.
func (r ApiBatchExportsRunsListRequest) Ordering(ordering string) ApiBatchExportsRunsListRequest {
	r.ordering = &ordering
	return r
}

func (r ApiBatchExportsRunsListRequest) Execute() (*PaginatedBatchExportRunList, *http.Response, error) {
	return r.ApiService.BatchExportsRunsListExecute(r)
}

/*
BatchExportsRunsList Method for BatchExportsRunsList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsRunsListRequest
*/
func (a *BatchExportsAPIService) BatchExportsRunsList(ctx context.Context, batchExportId string, projectId string) ApiBatchExportsRunsListRequest {
	return ApiBatchExportsRunsListRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return PaginatedBatchExportRunList
func (a *BatchExportsAPIService) BatchExportsRunsListExecute(r ApiBatchExportsRunsListRequest) (*PaginatedBatchExportRunList, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PaginatedBatchExportRunList
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunsList")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/runs/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.cursor != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "cursor", r.cursor, "form", "")
	}
	if r.ordering != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ordering", r.ordering, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsRunsLogsRetrieveRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiBatchExportsRunsLogsRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsRunsLogsRetrieveExecute(r)
}

/*
BatchExportsRunsLogsRetrieve Method for BatchExportsRunsLogsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsRunsLogsRetrieveRequest
*/
func (a *BatchExportsAPIService) BatchExportsRunsLogsRetrieve(ctx context.Context, batchExportId string, id string, projectId string) ApiBatchExportsRunsLogsRetrieveRequest {
	return ApiBatchExportsRunsLogsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsRunsLogsRetrieveExecute(r ApiBatchExportsRunsLogsRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunsLogsRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/runs/{id}/logs/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsRunsRetrieveRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	id string
	projectId string
}

func (r ApiBatchExportsRunsRetrieveRequest) Execute() (*BatchExportRun, *http.Response, error) {
	return r.ApiService.BatchExportsRunsRetrieveExecute(r)
}

/*
BatchExportsRunsRetrieve Method for BatchExportsRunsRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsRunsRetrieveRequest
*/
func (a *BatchExportsAPIService) BatchExportsRunsRetrieve(ctx context.Context, batchExportId string, id string, projectId string) ApiBatchExportsRunsRetrieveRequest {
	return ApiBatchExportsRunsRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExportRun
func (a *BatchExportsAPIService) BatchExportsRunsRetrieveExecute(r ApiBatchExportsRunsRetrieveRequest) (*BatchExportRun, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExportRun
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunsRetrieve")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/runs/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsRunsRetryCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	batchExportId string
	id string
	projectId string
	batchExportRun *BatchExportRun
}

func (r ApiBatchExportsRunsRetryCreateRequest) BatchExportRun(batchExportRun BatchExportRun) ApiBatchExportsRunsRetryCreateRequest {
	r.batchExportRun = &batchExportRun
	return r
}

func (r ApiBatchExportsRunsRetryCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsRunsRetryCreateExecute(r)
}

/*
BatchExportsRunsRetryCreate Method for BatchExportsRunsRetryCreate

Retry a batch export run.

We use the same underlying mechanism as when backfilling a batch export, as retrying
a run is the same as backfilling one run.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param batchExportId
 @param id A UUID string identifying this batch export run.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsRunsRetryCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsRunsRetryCreate(ctx context.Context, batchExportId string, id string, projectId string) ApiBatchExportsRunsRetryCreateRequest {
	return ApiBatchExportsRunsRetryCreateRequest{
		ApiService: a,
		ctx: ctx,
		batchExportId: batchExportId,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsRunsRetryCreateExecute(r ApiBatchExportsRunsRetryCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsRunsRetryCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{batch_export_id}/runs/{id}/retry/"
	localVarPath = strings.Replace(localVarPath, "{"+"batch_export_id"+"}", url.PathEscape(parameterValueToString(r.batchExportId, "batchExportId")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExportRun == nil {
		return nil, reportError("batchExportRun is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExportRun
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsTestRetrieveRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	organizationId string
}

func (r ApiBatchExportsTestRetrieveRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsTestRetrieveExecute(r)
}

/*
BatchExportsTestRetrieve Method for BatchExportsTestRetrieve

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param organizationId
 @return ApiBatchExportsTestRetrieveRequest
*/
func (a *BatchExportsAPIService) BatchExportsTestRetrieve(ctx context.Context, organizationId string) ApiBatchExportsTestRetrieveRequest {
	return ApiBatchExportsTestRetrieveRequest{
		ApiService: a,
		ctx: ctx,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsTestRetrieveExecute(r ApiBatchExportsTestRetrieveRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsTestRetrieve")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/test/"
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsTestRetrieve2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	projectId string
}

func (r ApiBatchExportsTestRetrieve2Request) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsTestRetrieve2Execute(r)
}

/*
BatchExportsTestRetrieve2 Method for BatchExportsTestRetrieve2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsTestRetrieve2Request
*/
func (a *BatchExportsAPIService) BatchExportsTestRetrieve2(ctx context.Context, projectId string) ApiBatchExportsTestRetrieve2Request {
	return ApiBatchExportsTestRetrieve2Request{
		ApiService: a,
		ctx: ctx,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsTestRetrieve2Execute(r ApiBatchExportsTestRetrieve2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsTestRetrieve2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/test/"
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsUnpauseCreateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
	batchExport *BatchExport
}

func (r ApiBatchExportsUnpauseCreateRequest) BatchExport(batchExport BatchExport) ApiBatchExportsUnpauseCreateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsUnpauseCreateRequest) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsUnpauseCreateExecute(r)
}

/*
BatchExportsUnpauseCreate Method for BatchExportsUnpauseCreate

Unpause a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsUnpauseCreateRequest
*/
func (a *BatchExportsAPIService) BatchExportsUnpauseCreate(ctx context.Context, id string, organizationId string) ApiBatchExportsUnpauseCreateRequest {
	return ApiBatchExportsUnpauseCreateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsUnpauseCreateExecute(r ApiBatchExportsUnpauseCreateRequest) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsUnpauseCreate")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/unpause/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsUnpauseCreate2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiBatchExportsUnpauseCreate2Request) BatchExport(batchExport BatchExport) ApiBatchExportsUnpauseCreate2Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsUnpauseCreate2Request) Execute() (*http.Response, error) {
	return r.ApiService.BatchExportsUnpauseCreate2Execute(r)
}

/*
BatchExportsUnpauseCreate2 Method for BatchExportsUnpauseCreate2

Unpause a BatchExport.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsUnpauseCreate2Request
*/
func (a *BatchExportsAPIService) BatchExportsUnpauseCreate2(ctx context.Context, id string, projectId string) ApiBatchExportsUnpauseCreate2Request {
	return ApiBatchExportsUnpauseCreate2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
func (a *BatchExportsAPIService) BatchExportsUnpauseCreate2Execute(r ApiBatchExportsUnpauseCreate2Request) (*http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsUnpauseCreate2")
	if err != nil {
		return nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/unpause/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarHTTPResponse, newErr
	}

	return localVarHTTPResponse, nil
}

type ApiBatchExportsUpdateRequest struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	organizationId string
	batchExport *BatchExport
}

func (r ApiBatchExportsUpdateRequest) BatchExport(batchExport BatchExport) ApiBatchExportsUpdateRequest {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsUpdateRequest) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.BatchExportsUpdateExecute(r)
}

/*
BatchExportsUpdate Method for BatchExportsUpdate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param organizationId
 @return ApiBatchExportsUpdateRequest
*/
func (a *BatchExportsAPIService) BatchExportsUpdate(ctx context.Context, id string, organizationId string) ApiBatchExportsUpdateRequest {
	return ApiBatchExportsUpdateRequest{
		ApiService: a,
		ctx: ctx,
		id: id,
		organizationId: organizationId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *BatchExportsAPIService) BatchExportsUpdateExecute(r ApiBatchExportsUpdateRequest) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsUpdate")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/organizations/{organization_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"organization_id"+"}", url.PathEscape(parameterValueToString(r.organizationId, "organizationId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return localVarReturnValue, nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiBatchExportsUpdate2Request struct {
	ctx context.Context
	ApiService *BatchExportsAPIService
	id string
	projectId string
	batchExport *BatchExport
}

func (r ApiBatchExportsUpdate2Request) BatchExport(batchExport BatchExport) ApiBatchExportsUpdate2Request {
	r.batchExport = &batchExport
	return r
}

func (r ApiBatchExportsUpdate2Request) Execute() (*BatchExport, *http.Response, error) {
	return r.ApiService.BatchExportsUpdate2Execute(r)
}

/*
BatchExportsUpdate2 Method for BatchExportsUpdate2

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param id A UUID string identifying this batch export.
 @param projectId Project ID of the project you're trying to access. To find the ID of the project, make a call to /api/projects/.
 @return ApiBatchExportsUpdate2Request
*/
func (a *BatchExportsAPIService) BatchExportsUpdate2(ctx context.Context, id string, projectId string) ApiBatchExportsUpdate2Request {
	return ApiBatchExportsUpdate2Request{
		ApiService: a,
		ctx: ctx,
		id: id,
		projectId: projectId,
	}
}

// Execute executes the request
//  @return BatchExport
func (a *BatchExportsAPIService) BatchExportsUpdate2Execute(r ApiBatchExportsUpdate2Request) (*BatchExport, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *BatchExport
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "BatchExportsAPIService.BatchExportsUpdate2")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/projects/{project_id}/batch_exports/{id}/"
	localVarPath = strings.Replace(localVarPath, "{"+"id"+"}", url.PathEscape(parameterValueToString(r.id, "id")), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"project_id"+"}", url.PathEscape(parameterValueToString(r.projectId, "projectId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.batchExport == nil {
		return localVarReturnValue, nil, reportError("batchExport is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json", "application/x-www-form-urlencoded", "multipart/form-data"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.batchExport
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
